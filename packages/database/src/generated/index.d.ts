/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model BusinessInfo
 *
 */
export type BusinessInfo =
  $Result.DefaultSelection<Prisma.$BusinessInfoPayload>;
/**
 * Model VehicleCompatibility
 *
 */
export type VehicleCompatibility =
  $Result.DefaultSelection<Prisma.$VehicleCompatibilityPayload>;
/**
 * Model Role
 *
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>;
/**
 * Model StaffUser
 *
 */
export type StaffUser = $Result.DefaultSelection<Prisma.$StaffUserPayload>;
/**
 * Model Setting
 *
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>;
/**
 * Model Banner
 *
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>;
/**
 * Model HeroSlide
 *
 */
export type HeroSlide = $Result.DefaultSelection<Prisma.$HeroSlidePayload>;
/**
 * Model SiteCustomization
 *
 */
export type SiteCustomization =
  $Result.DefaultSelection<Prisma.$SiteCustomizationPayload>;
/**
 * Model ActivityLog
 *
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>;
/**
 * Model Customer
 *
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>;
/**
 * Model Address
 *
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>;
/**
 * Model Category
 *
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>;
/**
 * Model Product
 *
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>;
/**
 * Model ProductReview
 *
 */
export type ProductReview =
  $Result.DefaultSelection<Prisma.$ProductReviewPayload>;
/**
 * Model Order
 *
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>;
/**
 * Model OrderItem
 *
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const SettingDataType: {
    STRING: "STRING";
    NUMBER: "NUMBER";
    BOOLEAN: "BOOLEAN";
    JSON: "JSON";
    EMAIL: "EMAIL";
    URL: "URL";
    PASSWORD: "PASSWORD";
    COLOR: "COLOR";
    IMAGE: "IMAGE";
  };

  export type SettingDataType =
    (typeof SettingDataType)[keyof typeof SettingDataType];

  export const BannerPosition: {
    TOP: "TOP";
    HEADER: "HEADER";
    HERO: "HERO";
    SIDEBAR: "SIDEBAR";
    FOOTER: "FOOTER";
    FLOATING: "FLOATING";
    BETWEEN_CONTENT: "BETWEEN_CONTENT";
  };

  export type BannerPosition =
    (typeof BannerPosition)[keyof typeof BannerPosition];

  export const BannerType: {
    INFO: "INFO";
    PROMOTION: "PROMOTION";
    ALERT: "ALERT";
    ANNOUNCEMENT: "ANNOUNCEMENT";
    CTA: "CTA";
  };

  export type BannerType = (typeof BannerType)[keyof typeof BannerType];

  export const SlideTextPosition: {
    CENTER_LEFT: "CENTER_LEFT";
    CENTER_RIGHT: "CENTER_RIGHT";
    CENTER_CENTER: "CENTER_CENTER";
    TOP_LEFT: "TOP_LEFT";
    TOP_RIGHT: "TOP_RIGHT";
    BOTTOM_LEFT: "BOTTOM_LEFT";
    BOTTOM_RIGHT: "BOTTOM_RIGHT";
  };

  export type SlideTextPosition =
    (typeof SlideTextPosition)[keyof typeof SlideTextPosition];

  export const SlideAnimation: {
    FADE: "FADE";
    SLIDE_LEFT: "SLIDE_LEFT";
    SLIDE_RIGHT: "SLIDE_RIGHT";
    SLIDE_UP: "SLIDE_UP";
    SLIDE_DOWN: "SLIDE_DOWN";
    ZOOM_IN: "ZOOM_IN";
    ZOOM_OUT: "ZOOM_OUT";
  };

  export type SlideAnimation =
    (typeof SlideAnimation)[keyof typeof SlideAnimation];

  export const ProfessionalTier: {
    BRONZE: "BRONZE";
    SILVER: "SILVER";
    GOLD: "GOLD";
    PLATINUM: "PLATINUM";
  };

  export type ProfessionalTier =
    (typeof ProfessionalTier)[keyof typeof ProfessionalTier];

  export const CustomerType: {
    RETAIL: "RETAIL";
    BUSINESS: "BUSINESS";
    DISTRIBUTOR: "DISTRIBUTOR";
    GOVERNMENT: "GOVERNMENT";
  };

  export type CustomerType = (typeof CustomerType)[keyof typeof CustomerType];

  export const RiskLevel: {
    LOW: "LOW";
    MEDIUM: "MEDIUM";
    HIGH: "HIGH";
    BLOCKED: "BLOCKED";
  };

  export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel];

  export const AddressType: {
    BILLING: "BILLING";
    SHIPPING: "SHIPPING";
    BOTH: "BOTH";
  };

  export type AddressType = (typeof AddressType)[keyof typeof AddressType];

  export const ProductStatus: {
    DRAFT: "DRAFT";
    PENDING: "PENDING";
    APPROVED: "APPROVED";
    ACTIVE: "ACTIVE";
    INACTIVE: "INACTIVE";
    DISCONTINUED: "DISCONTINUED";
    OUT_OF_STOCK: "OUT_OF_STOCK";
  };

  export type ProductStatus =
    (typeof ProductStatus)[keyof typeof ProductStatus];

  export const ApprovalStatus: {
    PENDING: "PENDING";
    APPROVED: "APPROVED";
    REJECTED: "REJECTED";
    CHANGES_REQUESTED: "CHANGES_REQUESTED";
  };

  export type ApprovalStatus =
    (typeof ApprovalStatus)[keyof typeof ApprovalStatus];

  export const ReviewStatus: {
    PENDING: "PENDING";
    APPROVED: "APPROVED";
    REJECTED: "REJECTED";
    SPAM: "SPAM";
  };

  export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus];

  export const OrderStatus: {
    PENDING: "PENDING";
    CONFIRMED: "CONFIRMED";
    PROCESSING: "PROCESSING";
    SHIPPED: "SHIPPED";
    DELIVERED: "DELIVERED";
    CANCELLED: "CANCELLED";
    REFUNDED: "REFUNDED";
    ON_HOLD: "ON_HOLD";
  };

  export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus];

  export const PaymentStatus: {
    PENDING: "PENDING";
    AUTHORIZED: "AUTHORIZED";
    PAID: "PAID";
    FAILED: "FAILED";
    REFUNDED: "REFUNDED";
    PARTIALLY_REFUNDED: "PARTIALLY_REFUNDED";
    CANCELLED: "CANCELLED";
  };

  export type PaymentStatus =
    (typeof PaymentStatus)[keyof typeof PaymentStatus];

  export const FulfillmentStatus: {
    UNFULFILLED: "UNFULFILLED";
    PARTIALLY_FULFILLED: "PARTIALLY_FULFILLED";
    FULFILLED: "FULFILLED";
    CANCELLED: "CANCELLED";
    RETURNED: "RETURNED";
  };

  export type FulfillmentStatus =
    (typeof FulfillmentStatus)[keyof typeof FulfillmentStatus];

  export const OrderPriority: {
    LOW: "LOW";
    NORMAL: "NORMAL";
    HIGH: "HIGH";
    URGENT: "URGENT";
  };

  export type OrderPriority =
    (typeof OrderPriority)[keyof typeof OrderPriority];
}

export type SettingDataType = $Enums.SettingDataType;

export const SettingDataType: typeof $Enums.SettingDataType;

export type BannerPosition = $Enums.BannerPosition;

export const BannerPosition: typeof $Enums.BannerPosition;

export type BannerType = $Enums.BannerType;

export const BannerType: typeof $Enums.BannerType;

export type SlideTextPosition = $Enums.SlideTextPosition;

export const SlideTextPosition: typeof $Enums.SlideTextPosition;

export type SlideAnimation = $Enums.SlideAnimation;

export const SlideAnimation: typeof $Enums.SlideAnimation;

export type ProfessionalTier = $Enums.ProfessionalTier;

export const ProfessionalTier: typeof $Enums.ProfessionalTier;

export type CustomerType = $Enums.CustomerType;

export const CustomerType: typeof $Enums.CustomerType;

export type RiskLevel = $Enums.RiskLevel;

export const RiskLevel: typeof $Enums.RiskLevel;

export type AddressType = $Enums.AddressType;

export const AddressType: typeof $Enums.AddressType;

export type ProductStatus = $Enums.ProductStatus;

export const ProductStatus: typeof $Enums.ProductStatus;

export type ApprovalStatus = $Enums.ApprovalStatus;

export const ApprovalStatus: typeof $Enums.ApprovalStatus;

export type ReviewStatus = $Enums.ReviewStatus;

export const ReviewStatus: typeof $Enums.ReviewStatus;

export type OrderStatus = $Enums.OrderStatus;

export const OrderStatus: typeof $Enums.OrderStatus;

export type PaymentStatus = $Enums.PaymentStatus;

export const PaymentStatus: typeof $Enums.PaymentStatus;

export type FulfillmentStatus = $Enums.FulfillmentStatus;

export const FulfillmentStatus: typeof $Enums.FulfillmentStatus;

export type OrderPriority = $Enums.OrderPriority;

export const OrderPriority: typeof $Enums.OrderPriority;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: { maxWait?: number; timeout?: number },
  ): $Utils.JsPromise<R>;

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(
    command: Prisma.InputJsonObject,
  ): Prisma.PrismaPromise<Prisma.JsonObject>;

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.staffUser`: Exposes CRUD operations for the **StaffUser** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more StaffUsers
   * const staffUsers = await prisma.staffUser.findMany()
   * ```
   */
  get staffUser(): Prisma.StaffUserDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Settings
   * const settings = await prisma.setting.findMany()
   * ```
   */
  get setting(): Prisma.SettingDelegate<ExtArgs>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Banners
   * const banners = await prisma.banner.findMany()
   * ```
   */
  get banner(): Prisma.BannerDelegate<ExtArgs>;

  /**
   * `prisma.heroSlide`: Exposes CRUD operations for the **HeroSlide** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more HeroSlides
   * const heroSlides = await prisma.heroSlide.findMany()
   * ```
   */
  get heroSlide(): Prisma.HeroSlideDelegate<ExtArgs>;

  /**
   * `prisma.siteCustomization`: Exposes CRUD operations for the **SiteCustomization** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SiteCustomizations
   * const siteCustomizations = await prisma.siteCustomization.findMany()
   * ```
   */
  get siteCustomization(): Prisma.SiteCustomizationDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ActivityLogs
   * const activityLogs = await prisma.activityLog.findMany()
   * ```
   */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   */
  get address(): Prisma.AddressDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.productReview`: Exposes CRUD operations for the **ProductReview** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProductReviews
   * const productReviews = await prisma.productReview.findMany()
   * ```
   */
  get productReview(): Prisma.ProductReviewDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Orders
   * const orders = await prisma.order.findMany()
   * ```
   */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more OrderItems
   * const orderItems = await prisma.orderItem.findMany()
   * ```
   */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;
  export import NotFoundError = runtime.NotFoundError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? K : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Role: "Role";
    StaffUser: "StaffUser";
    Setting: "Setting";
    Banner: "Banner";
    HeroSlide: "HeroSlide";
    SiteCustomization: "SiteCustomization";
    ActivityLog: "ActivityLog";
    Customer: "Customer";
    Address: "Address";
    Category: "Category";
    Product: "Product";
    ProductReview: "ProductReview";
    Order: "Order";
    OrderItem: "OrderItem";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs; clientOptions: PrismaClientOptions },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      this["params"]["clientOptions"]
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    ClientOptions = {},
  > = {
    meta: {
      modelProps:
        | "role"
        | "staffUser"
        | "setting"
        | "banner"
        | "heroSlide"
        | "siteCustomization"
        | "activityLog"
        | "customer"
        | "address"
        | "category"
        | "product"
        | "productReview"
        | "order"
        | "orderItem";
      txIsolationLevel: never;
    };
    model: {
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>;
        fields: Prisma.RoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRole>;
          };
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.RoleFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.RoleAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleCountAggregateOutputType> | number;
          };
        };
      };
      StaffUser: {
        payload: Prisma.$StaffUserPayload<ExtArgs>;
        fields: Prisma.StaffUserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.StaffUserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.StaffUserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>;
          };
          findFirst: {
            args: Prisma.StaffUserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.StaffUserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>;
          };
          findMany: {
            args: Prisma.StaffUserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>[];
          };
          create: {
            args: Prisma.StaffUserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>;
          };
          createMany: {
            args: Prisma.StaffUserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.StaffUserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>;
          };
          update: {
            args: Prisma.StaffUserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>;
          };
          deleteMany: {
            args: Prisma.StaffUserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.StaffUserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.StaffUserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>;
          };
          aggregate: {
            args: Prisma.StaffUserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStaffUser>;
          };
          groupBy: {
            args: Prisma.StaffUserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StaffUserGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.StaffUserFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.StaffUserAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.StaffUserCountArgs<ExtArgs>;
            result: $Utils.Optional<StaffUserCountAggregateOutputType> | number;
          };
        };
      };
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>;
        fields: Prisma.SettingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[];
          };
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSetting>;
          };
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SettingGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.SettingFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.SettingAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>;
            result: $Utils.Optional<SettingCountAggregateOutputType> | number;
          };
        };
      };
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>;
        fields: Prisma.BannerFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>;
          };
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>;
          };
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[];
          };
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>;
          };
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>;
          };
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>;
          };
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>;
          };
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBanner>;
          };
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BannerGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.BannerFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.BannerAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>;
            result: $Utils.Optional<BannerCountAggregateOutputType> | number;
          };
        };
      };
      HeroSlide: {
        payload: Prisma.$HeroSlidePayload<ExtArgs>;
        fields: Prisma.HeroSlideFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.HeroSlideFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.HeroSlideFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>;
          };
          findFirst: {
            args: Prisma.HeroSlideFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.HeroSlideFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>;
          };
          findMany: {
            args: Prisma.HeroSlideFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>[];
          };
          create: {
            args: Prisma.HeroSlideCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>;
          };
          createMany: {
            args: Prisma.HeroSlideCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.HeroSlideDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>;
          };
          update: {
            args: Prisma.HeroSlideUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>;
          };
          deleteMany: {
            args: Prisma.HeroSlideDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.HeroSlideUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.HeroSlideUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HeroSlidePayload>;
          };
          aggregate: {
            args: Prisma.HeroSlideAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateHeroSlide>;
          };
          groupBy: {
            args: Prisma.HeroSlideGroupByArgs<ExtArgs>;
            result: $Utils.Optional<HeroSlideGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.HeroSlideFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.HeroSlideAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.HeroSlideCountArgs<ExtArgs>;
            result: $Utils.Optional<HeroSlideCountAggregateOutputType> | number;
          };
        };
      };
      SiteCustomization: {
        payload: Prisma.$SiteCustomizationPayload<ExtArgs>;
        fields: Prisma.SiteCustomizationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SiteCustomizationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SiteCustomizationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload>;
          };
          findFirst: {
            args: Prisma.SiteCustomizationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SiteCustomizationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload>;
          };
          findMany: {
            args: Prisma.SiteCustomizationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload>[];
          };
          create: {
            args: Prisma.SiteCustomizationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload>;
          };
          createMany: {
            args: Prisma.SiteCustomizationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.SiteCustomizationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload>;
          };
          update: {
            args: Prisma.SiteCustomizationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload>;
          };
          deleteMany: {
            args: Prisma.SiteCustomizationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SiteCustomizationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SiteCustomizationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SiteCustomizationPayload>;
          };
          aggregate: {
            args: Prisma.SiteCustomizationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSiteCustomization>;
          };
          groupBy: {
            args: Prisma.SiteCustomizationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SiteCustomizationGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.SiteCustomizationFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.SiteCustomizationAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.SiteCustomizationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<SiteCustomizationCountAggregateOutputType>
              | number;
          };
        };
      };
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>;
        fields: Prisma.ActivityLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>;
          };
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>;
          };
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[];
          };
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>;
          };
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>;
          };
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>;
          };
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>;
          };
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateActivityLog>;
          };
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ActivityLogGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ActivityLogFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ActivityLogAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ActivityLogCountAggregateOutputType>
              | number;
          };
        };
      };
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>;
        fields: Prisma.CustomerFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>;
          };
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>;
          };
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[];
          };
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>;
          };
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>;
          };
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>;
          };
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>;
          };
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCustomer>;
          };
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CustomerGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.CustomerFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.CustomerAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>;
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number;
          };
        };
      };
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>;
        fields: Prisma.AddressFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[];
          };
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAddress>;
          };
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AddressGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.AddressFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.AddressAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>;
            result: $Utils.Optional<AddressCountAggregateOutputType> | number;
          };
        };
      };
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>;
        fields: Prisma.CategoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[];
          };
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCategory>;
          };
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CategoryGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.CategoryFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.CategoryAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>;
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number;
          };
        };
      };
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>;
        fields: Prisma.ProductFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[];
          };
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>;
          };
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProduct>;
          };
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProductGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ProductFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ProductAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>;
            result: $Utils.Optional<ProductCountAggregateOutputType> | number;
          };
        };
      };
      ProductReview: {
        payload: Prisma.$ProductReviewPayload<ExtArgs>;
        fields: Prisma.ProductReviewFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProductReviewFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProductReviewFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>;
          };
          findFirst: {
            args: Prisma.ProductReviewFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProductReviewFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>;
          };
          findMany: {
            args: Prisma.ProductReviewFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>[];
          };
          create: {
            args: Prisma.ProductReviewCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>;
          };
          createMany: {
            args: Prisma.ProductReviewCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ProductReviewDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>;
          };
          update: {
            args: Prisma.ProductReviewUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>;
          };
          deleteMany: {
            args: Prisma.ProductReviewDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProductReviewUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ProductReviewUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>;
          };
          aggregate: {
            args: Prisma.ProductReviewAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProductReview>;
          };
          groupBy: {
            args: Prisma.ProductReviewGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProductReviewGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ProductReviewFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ProductReviewAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ProductReviewCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ProductReviewCountAggregateOutputType>
              | number;
          };
        };
      };
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>;
        fields: Prisma.OrderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrder>;
          };
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrderGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.OrderFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.OrderAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>;
            result: $Utils.Optional<OrderCountAggregateOutputType> | number;
          };
        };
      };
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>;
        fields: Prisma.OrderItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
          };
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrderItem>;
          };
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrderItemGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.OrderItemFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.OrderItemAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>;
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject;
          result: Prisma.JsonObject;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
    };
  }

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T["emit"] extends "event"
        ? T["level"]
        : never
      : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ?
          | GetLogType<T[0]>
          | GetLogType<T[1]>
          | GetLogType<T[2]>
          | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    staffUsers: number;
  };

  export type RoleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    staffUsers?: boolean | RoleCountOutputTypeCountStaffUsersArgs;
  };

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountStaffUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StaffUserWhereInput;
  };

  /**
   * Count Type StaffUserCountOutputType
   */

  export type StaffUserCountOutputType = {
    activityLogs: number;
  };

  export type StaffUserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    activityLogs?: boolean | StaffUserCountOutputTypeCountActivityLogsArgs;
  };

  // Custom InputTypes
  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUserCountOutputType
     */
    select?: StaffUserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountActivityLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ActivityLogWhereInput;
  };

  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    addresses: number;
    orders: number;
    reviews: number;
  };

  export type CustomerCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    addresses?: boolean | CustomerCountOutputTypeCountAddressesArgs;
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs;
    reviews?: boolean | CustomerCountOutputTypeCountReviewsArgs;
  };

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAddressesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AddressWhereInput;
  };

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductReviewWhereInput;
  };

  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number;
    products: number;
  };

  export type CategoryCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs;
    products?: boolean | CategoryCountOutputTypeCountProductsArgs;
  };

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CategoryWhereInput;
  };

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductWhereInput;
  };

  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    reviews: number;
    orderItems: number;
  };

  export type ProductCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    reviews?: boolean | ProductCountOutputTypeCountReviewsArgs;
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs;
  };

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductReviewWhereInput;
  };

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderItemWhereInput;
  };

  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItems: number;
  };

  export type OrderCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs;
  };

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderItemWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model BusinessInfo
   */

  export type BusinessInfoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      companyName?: boolean;
      taxId?: boolean;
      licenseNumber?: boolean;
      website?: boolean;
      verified?: boolean;
      verificationDocs?: boolean;
      yearEstablished?: boolean;
      employeeCount?: boolean;
    },
    ExtArgs["result"]["businessInfo"]
  >;

  export type BusinessInfoSelectScalar = {
    companyName?: boolean;
    taxId?: boolean;
    licenseNumber?: boolean;
    website?: boolean;
    verified?: boolean;
    verificationDocs?: boolean;
    yearEstablished?: boolean;
    employeeCount?: boolean;
  };

  export type $BusinessInfoPayload = {
    name: "BusinessInfo";
    objects: {};
    scalars: {
      companyName: string;
      taxId: string | null;
      licenseNumber: string | null;
      website: string | null;
      verified: boolean;
      verificationDocs: string[];
      yearEstablished: number | null;
      employeeCount: string | null;
    };
    composites: {};
  };

  type BusinessInfoGetPayload<
    S extends boolean | null | undefined | BusinessInfoDefaultArgs,
  > = $Result.GetResult<Prisma.$BusinessInfoPayload, S>;

  /**
   * Fields of the BusinessInfo model
   */
  interface BusinessInfoFieldRefs {
    readonly companyName: FieldRef<"BusinessInfo", "String">;
    readonly taxId: FieldRef<"BusinessInfo", "String">;
    readonly licenseNumber: FieldRef<"BusinessInfo", "String">;
    readonly website: FieldRef<"BusinessInfo", "String">;
    readonly verified: FieldRef<"BusinessInfo", "Boolean">;
    readonly verificationDocs: FieldRef<"BusinessInfo", "String[]">;
    readonly yearEstablished: FieldRef<"BusinessInfo", "Int">;
    readonly employeeCount: FieldRef<"BusinessInfo", "String">;
  }

  // Custom InputTypes
  /**
   * BusinessInfo without action
   */
  export type BusinessInfoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BusinessInfo
     */
    select?: BusinessInfoSelect<ExtArgs> | null;
  };

  /**
   * Model VehicleCompatibility
   */

  export type VehicleCompatibilitySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      makes?: boolean;
      models?: boolean;
      years?: boolean;
      engineTypes?: boolean;
      transmissions?: boolean;
      notes?: boolean;
    },
    ExtArgs["result"]["vehicleCompatibility"]
  >;

  export type VehicleCompatibilitySelectScalar = {
    makes?: boolean;
    models?: boolean;
    years?: boolean;
    engineTypes?: boolean;
    transmissions?: boolean;
    notes?: boolean;
  };

  export type $VehicleCompatibilityPayload = {
    name: "VehicleCompatibility";
    objects: {};
    scalars: {
      makes: string[];
      models: string[];
      years: string[];
      engineTypes: string[];
      transmissions: string[];
      notes: string | null;
    };
    composites: {};
  };

  type VehicleCompatibilityGetPayload<
    S extends boolean | null | undefined | VehicleCompatibilityDefaultArgs,
  > = $Result.GetResult<Prisma.$VehicleCompatibilityPayload, S>;

  /**
   * Fields of the VehicleCompatibility model
   */
  interface VehicleCompatibilityFieldRefs {
    readonly makes: FieldRef<"VehicleCompatibility", "String[]">;
    readonly models: FieldRef<"VehicleCompatibility", "String[]">;
    readonly years: FieldRef<"VehicleCompatibility", "String[]">;
    readonly engineTypes: FieldRef<"VehicleCompatibility", "String[]">;
    readonly transmissions: FieldRef<"VehicleCompatibility", "String[]">;
    readonly notes: FieldRef<"VehicleCompatibility", "String">;
  }

  // Custom InputTypes
  /**
   * VehicleCompatibility without action
   */
  export type VehicleCompatibilityDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VehicleCompatibility
     */
    select?: VehicleCompatibilitySelect<ExtArgs> | null;
  };

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _avg: RoleAvgAggregateOutputType | null;
    _sum: RoleSumAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleAvgAggregateOutputType = {
    hierarchyLevel: number | null;
    maxUsers: number | null;
  };

  export type RoleSumAggregateOutputType = {
    hierarchyLevel: number | null;
    maxUsers: number | null;
  };

  export type RoleMinAggregateOutputType = {
    id: string | null;
    roleName: string | null;
    hierarchyLevel: number | null;
    description: string | null;
    isActive: boolean | null;
    maxUsers: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleMaxAggregateOutputType = {
    id: string | null;
    roleName: string | null;
    hierarchyLevel: number | null;
    description: string | null;
    isActive: boolean | null;
    maxUsers: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleCountAggregateOutputType = {
    id: number;
    roleName: number;
    hierarchyLevel: number;
    permissions: number;
    description: number;
    isActive: number;
    maxUsers: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RoleAvgAggregateInputType = {
    hierarchyLevel?: true;
    maxUsers?: true;
  };

  export type RoleSumAggregateInputType = {
    hierarchyLevel?: true;
    maxUsers?: true;
  };

  export type RoleMinAggregateInputType = {
    id?: true;
    roleName?: true;
    hierarchyLevel?: true;
    description?: true;
    isActive?: true;
    maxUsers?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleMaxAggregateInputType = {
    id?: true;
    roleName?: true;
    hierarchyLevel?: true;
    description?: true;
    isActive?: true;
    maxUsers?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleCountAggregateInputType = {
    id?: true;
    roleName?: true;
    hierarchyLevel?: true;
    permissions?: true;
    description?: true;
    isActive?: true;
    maxUsers?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RoleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RoleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type RoleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleWhereInput;
    orderBy?:
      | RoleOrderByWithAggregationInput
      | RoleOrderByWithAggregationInput[];
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum;
    having?: RoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RoleCountAggregateInputType | true;
    _avg?: RoleAvgAggregateInputType;
    _sum?: RoleSumAggregateInputType;
    _min?: RoleMinAggregateInputType;
    _max?: RoleMaxAggregateInputType;
  };

  export type RoleGroupByOutputType = {
    id: string;
    roleName: string;
    hierarchyLevel: number;
    permissions: JsonValue;
    description: string | null;
    isActive: boolean;
    maxUsers: number | null;
    createdAt: Date;
    updatedAt: Date;
    _count: RoleCountAggregateOutputType | null;
    _avg: RoleAvgAggregateOutputType | null;
    _sum: RoleSumAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type RoleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleName?: boolean;
      hierarchyLevel?: boolean;
      permissions?: boolean;
      description?: boolean;
      isActive?: boolean;
      maxUsers?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      staffUsers?: boolean | Role$staffUsersArgs<ExtArgs>;
      _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["role"]
  >;

  export type RoleSelectScalar = {
    id?: boolean;
    roleName?: boolean;
    hierarchyLevel?: boolean;
    permissions?: boolean;
    description?: boolean;
    isActive?: boolean;
    maxUsers?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RoleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    staffUsers?: boolean | Role$staffUsersArgs<ExtArgs>;
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $RolePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Role";
    objects: {
      staffUsers: Prisma.$StaffUserPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        roleName: string;
        hierarchyLevel: number;
        permissions: Prisma.JsonValue;
        description: string | null;
        isActive: boolean;
        maxUsers: number | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["role"]
    >;
    composites: {};
  };

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> =
    $Result.GetResult<Prisma.$RolePayload, S>;

  type RoleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RoleFindManyArgs, "select" | "include" | "distinct"> & {
    select?: RoleCountAggregateInputType | true;
  };

  export interface RoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Role"];
      meta: { name: "Role" };
    };
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     */
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     */
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * @param {RoleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const role = await prisma.role.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RoleFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Role.
     * @param {RoleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const role = await prisma.role.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RoleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>,
    ): Prisma.PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs["orderBy"] }
        : { orderBy?: RoleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetRoleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Role model
     */
    readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    staffUsers<T extends Role$staffUsersArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$staffUsersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findMany"> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", "String">;
    readonly roleName: FieldRef<"Role", "String">;
    readonly hierarchyLevel: FieldRef<"Role", "Int">;
    readonly permissions: FieldRef<"Role", "Json">;
    readonly description: FieldRef<"Role", "String">;
    readonly isActive: FieldRef<"Role", "Boolean">;
    readonly maxUsers: FieldRef<"Role", "Int">;
    readonly createdAt: FieldRef<"Role", "DateTime">;
    readonly updatedAt: FieldRef<"Role", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role create
   */
  export type RoleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
  };

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
  };

  /**
   * Role update
   */
  export type RoleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
  };

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput;
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
  };

  /**
   * Role delete
   */
  export type RoleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput;
  };

  /**
   * Role findRaw
   */
  export type RoleFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Role aggregateRaw
   */
  export type RoleAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Role.staffUsers
   */
  export type Role$staffUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    where?: StaffUserWhereInput;
    orderBy?:
      | StaffUserOrderByWithRelationInput
      | StaffUserOrderByWithRelationInput[];
    cursor?: StaffUserWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: StaffUserScalarFieldEnum | StaffUserScalarFieldEnum[];
  };

  /**
   * Role without action
   */
  export type RoleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
  };

  /**
   * Model StaffUser
   */

  export type AggregateStaffUser = {
    _count: StaffUserCountAggregateOutputType | null;
    _avg: StaffUserAvgAggregateOutputType | null;
    _sum: StaffUserSumAggregateOutputType | null;
    _min: StaffUserMinAggregateOutputType | null;
    _max: StaffUserMaxAggregateOutputType | null;
  };

  export type StaffUserAvgAggregateOutputType = {
    loginAttempts: number | null;
  };

  export type StaffUserSumAggregateOutputType = {
    loginAttempts: number | null;
  };

  export type StaffUserMinAggregateOutputType = {
    id: string | null;
    roleId: string | null;
    firstName: string | null;
    lastName: string | null;
    email: string | null;
    phone: string | null;
    passwordHash: string | null;
    isActive: boolean | null;
    emailVerified: boolean | null;
    twoFactorEnabled: boolean | null;
    twoFactorSecret: string | null;
    lastLogin: Date | null;
    lastLoginIp: string | null;
    loginAttempts: number | null;
    lockedUntil: Date | null;
    passwordChangedAt: Date | null;
    mustChangePassword: boolean | null;
    avatar: string | null;
    timezone: string | null;
    language: string | null;
    canAccessAdmin: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
    lastModifiedBy: string | null;
  };

  export type StaffUserMaxAggregateOutputType = {
    id: string | null;
    roleId: string | null;
    firstName: string | null;
    lastName: string | null;
    email: string | null;
    phone: string | null;
    passwordHash: string | null;
    isActive: boolean | null;
    emailVerified: boolean | null;
    twoFactorEnabled: boolean | null;
    twoFactorSecret: string | null;
    lastLogin: Date | null;
    lastLoginIp: string | null;
    loginAttempts: number | null;
    lockedUntil: Date | null;
    passwordChangedAt: Date | null;
    mustChangePassword: boolean | null;
    avatar: string | null;
    timezone: string | null;
    language: string | null;
    canAccessAdmin: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
    lastModifiedBy: string | null;
  };

  export type StaffUserCountAggregateOutputType = {
    id: number;
    roleId: number;
    firstName: number;
    lastName: number;
    email: number;
    phone: number;
    passwordHash: number;
    isActive: number;
    emailVerified: number;
    twoFactorEnabled: number;
    twoFactorSecret: number;
    lastLogin: number;
    lastLoginIp: number;
    loginAttempts: number;
    lockedUntil: number;
    passwordChangedAt: number;
    mustChangePassword: number;
    avatar: number;
    timezone: number;
    language: number;
    canAccessAdmin: number;
    departmentAccess: number;
    createdAt: number;
    updatedAt: number;
    createdBy: number;
    lastModifiedBy: number;
    _all: number;
  };

  export type StaffUserAvgAggregateInputType = {
    loginAttempts?: true;
  };

  export type StaffUserSumAggregateInputType = {
    loginAttempts?: true;
  };

  export type StaffUserMinAggregateInputType = {
    id?: true;
    roleId?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    isActive?: true;
    emailVerified?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    lastLogin?: true;
    lastLoginIp?: true;
    loginAttempts?: true;
    lockedUntil?: true;
    passwordChangedAt?: true;
    mustChangePassword?: true;
    avatar?: true;
    timezone?: true;
    language?: true;
    canAccessAdmin?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    lastModifiedBy?: true;
  };

  export type StaffUserMaxAggregateInputType = {
    id?: true;
    roleId?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    isActive?: true;
    emailVerified?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    lastLogin?: true;
    lastLoginIp?: true;
    loginAttempts?: true;
    lockedUntil?: true;
    passwordChangedAt?: true;
    mustChangePassword?: true;
    avatar?: true;
    timezone?: true;
    language?: true;
    canAccessAdmin?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    lastModifiedBy?: true;
  };

  export type StaffUserCountAggregateInputType = {
    id?: true;
    roleId?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    isActive?: true;
    emailVerified?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    lastLogin?: true;
    lastLoginIp?: true;
    loginAttempts?: true;
    lockedUntil?: true;
    passwordChangedAt?: true;
    mustChangePassword?: true;
    avatar?: true;
    timezone?: true;
    language?: true;
    canAccessAdmin?: true;
    departmentAccess?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    lastModifiedBy?: true;
    _all?: true;
  };

  export type StaffUserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which StaffUser to aggregate.
     */
    where?: StaffUserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StaffUsers to fetch.
     */
    orderBy?:
      | StaffUserOrderByWithRelationInput
      | StaffUserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: StaffUserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StaffUsers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StaffUsers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned StaffUsers
     **/
    _count?: true | StaffUserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: StaffUserAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: StaffUserSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StaffUserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StaffUserMaxAggregateInputType;
  };

  export type GetStaffUserAggregateType<T extends StaffUserAggregateArgs> = {
    [P in keyof T & keyof AggregateStaffUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffUser[P]>
      : GetScalarType<T[P], AggregateStaffUser[P]>;
  };

  export type StaffUserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StaffUserWhereInput;
    orderBy?:
      | StaffUserOrderByWithAggregationInput
      | StaffUserOrderByWithAggregationInput[];
    by: StaffUserScalarFieldEnum[] | StaffUserScalarFieldEnum;
    having?: StaffUserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StaffUserCountAggregateInputType | true;
    _avg?: StaffUserAvgAggregateInputType;
    _sum?: StaffUserSumAggregateInputType;
    _min?: StaffUserMinAggregateInputType;
    _max?: StaffUserMaxAggregateInputType;
  };

  export type StaffUserGroupByOutputType = {
    id: string;
    roleId: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string | null;
    passwordHash: string;
    isActive: boolean;
    emailVerified: boolean;
    twoFactorEnabled: boolean;
    twoFactorSecret: string | null;
    lastLogin: Date | null;
    lastLoginIp: string | null;
    loginAttempts: number;
    lockedUntil: Date | null;
    passwordChangedAt: Date;
    mustChangePassword: boolean;
    avatar: string | null;
    timezone: string;
    language: string;
    canAccessAdmin: boolean;
    departmentAccess: string[];
    createdAt: Date;
    updatedAt: Date;
    createdBy: string | null;
    lastModifiedBy: string | null;
    _count: StaffUserCountAggregateOutputType | null;
    _avg: StaffUserAvgAggregateOutputType | null;
    _sum: StaffUserSumAggregateOutputType | null;
    _min: StaffUserMinAggregateOutputType | null;
    _max: StaffUserMaxAggregateOutputType | null;
  };

  type GetStaffUserGroupByPayload<T extends StaffUserGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StaffUserGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof StaffUserGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffUserGroupByOutputType[P]>
            : GetScalarType<T[P], StaffUserGroupByOutputType[P]>;
        }
      >
    >;

  export type StaffUserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleId?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      email?: boolean;
      phone?: boolean;
      passwordHash?: boolean;
      isActive?: boolean;
      emailVerified?: boolean;
      twoFactorEnabled?: boolean;
      twoFactorSecret?: boolean;
      lastLogin?: boolean;
      lastLoginIp?: boolean;
      loginAttempts?: boolean;
      lockedUntil?: boolean;
      passwordChangedAt?: boolean;
      mustChangePassword?: boolean;
      avatar?: boolean;
      timezone?: boolean;
      language?: boolean;
      canAccessAdmin?: boolean;
      departmentAccess?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
      lastModifiedBy?: boolean;
      role?: boolean | RoleDefaultArgs<ExtArgs>;
      activityLogs?: boolean | StaffUser$activityLogsArgs<ExtArgs>;
      _count?: boolean | StaffUserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["staffUser"]
  >;

  export type StaffUserSelectScalar = {
    id?: boolean;
    roleId?: boolean;
    firstName?: boolean;
    lastName?: boolean;
    email?: boolean;
    phone?: boolean;
    passwordHash?: boolean;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: boolean;
    lastLogin?: boolean;
    lastLoginIp?: boolean;
    loginAttempts?: boolean;
    lockedUntil?: boolean;
    passwordChangedAt?: boolean;
    mustChangePassword?: boolean;
    avatar?: boolean;
    timezone?: boolean;
    language?: boolean;
    canAccessAdmin?: boolean;
    departmentAccess?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean;
    lastModifiedBy?: boolean;
  };

  export type StaffUserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    role?: boolean | RoleDefaultArgs<ExtArgs>;
    activityLogs?: boolean | StaffUser$activityLogsArgs<ExtArgs>;
    _count?: boolean | StaffUserCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $StaffUserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "StaffUser";
    objects: {
      role: Prisma.$RolePayload<ExtArgs>;
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        roleId: string;
        firstName: string;
        lastName: string;
        email: string;
        phone: string | null;
        passwordHash: string;
        isActive: boolean;
        emailVerified: boolean;
        twoFactorEnabled: boolean;
        twoFactorSecret: string | null;
        lastLogin: Date | null;
        lastLoginIp: string | null;
        loginAttempts: number;
        lockedUntil: Date | null;
        passwordChangedAt: Date;
        mustChangePassword: boolean;
        avatar: string | null;
        timezone: string;
        language: string;
        canAccessAdmin: boolean;
        departmentAccess: string[];
        createdAt: Date;
        updatedAt: Date;
        createdBy: string | null;
        lastModifiedBy: string | null;
      },
      ExtArgs["result"]["staffUser"]
    >;
    composites: {};
  };

  type StaffUserGetPayload<
    S extends boolean | null | undefined | StaffUserDefaultArgs,
  > = $Result.GetResult<Prisma.$StaffUserPayload, S>;

  type StaffUserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<StaffUserFindManyArgs, "select" | "include" | "distinct"> & {
    select?: StaffUserCountAggregateInputType | true;
  };

  export interface StaffUserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["StaffUser"];
      meta: { name: "StaffUser" };
    };
    /**
     * Find zero or one StaffUser that matches the filter.
     * @param {StaffUserFindUniqueArgs} args - Arguments to find a StaffUser
     * @example
     * // Get one StaffUser
     * const staffUser = await prisma.staffUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffUserFindUniqueArgs>(
      args: SelectSubset<T, StaffUserFindUniqueArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      $Result.GetResult<
        Prisma.$StaffUserPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one StaffUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffUserFindUniqueOrThrowArgs} args - Arguments to find a StaffUser
     * @example
     * // Get one StaffUser
     * const staffUser = await prisma.staffUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffUserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, StaffUserFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      $Result.GetResult<
        Prisma.$StaffUserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first StaffUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserFindFirstArgs} args - Arguments to find a StaffUser
     * @example
     * // Get one StaffUser
     * const staffUser = await prisma.staffUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffUserFindFirstArgs>(
      args?: SelectSubset<T, StaffUserFindFirstArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      $Result.GetResult<
        Prisma.$StaffUserPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first StaffUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserFindFirstOrThrowArgs} args - Arguments to find a StaffUser
     * @example
     * // Get one StaffUser
     * const staffUser = await prisma.staffUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StaffUserFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      $Result.GetResult<
        Prisma.$StaffUserPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more StaffUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffUsers
     * const staffUsers = await prisma.staffUser.findMany()
     *
     * // Get first 10 StaffUsers
     * const staffUsers = await prisma.staffUser.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const staffUserWithIdOnly = await prisma.staffUser.findMany({ select: { id: true } })
     *
     */
    findMany<T extends StaffUserFindManyArgs>(
      args?: SelectSubset<T, StaffUserFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a StaffUser.
     * @param {StaffUserCreateArgs} args - Arguments to create a StaffUser.
     * @example
     * // Create one StaffUser
     * const StaffUser = await prisma.staffUser.create({
     *   data: {
     *     // ... data to create a StaffUser
     *   }
     * })
     *
     */
    create<T extends StaffUserCreateArgs>(
      args: SelectSubset<T, StaffUserCreateArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      $Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many StaffUsers.
     * @param {StaffUserCreateManyArgs} args - Arguments to create many StaffUsers.
     * @example
     * // Create many StaffUsers
     * const staffUser = await prisma.staffUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends StaffUserCreateManyArgs>(
      args?: SelectSubset<T, StaffUserCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a StaffUser.
     * @param {StaffUserDeleteArgs} args - Arguments to delete one StaffUser.
     * @example
     * // Delete one StaffUser
     * const StaffUser = await prisma.staffUser.delete({
     *   where: {
     *     // ... filter to delete one StaffUser
     *   }
     * })
     *
     */
    delete<T extends StaffUserDeleteArgs>(
      args: SelectSubset<T, StaffUserDeleteArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      $Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one StaffUser.
     * @param {StaffUserUpdateArgs} args - Arguments to update one StaffUser.
     * @example
     * // Update one StaffUser
     * const staffUser = await prisma.staffUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends StaffUserUpdateArgs>(
      args: SelectSubset<T, StaffUserUpdateArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      $Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more StaffUsers.
     * @param {StaffUserDeleteManyArgs} args - Arguments to filter StaffUsers to delete.
     * @example
     * // Delete a few StaffUsers
     * const { count } = await prisma.staffUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends StaffUserDeleteManyArgs>(
      args?: SelectSubset<T, StaffUserDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more StaffUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffUsers
     * const staffUser = await prisma.staffUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends StaffUserUpdateManyArgs>(
      args: SelectSubset<T, StaffUserUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one StaffUser.
     * @param {StaffUserUpsertArgs} args - Arguments to update or create a StaffUser.
     * @example
     * // Update or create a StaffUser
     * const staffUser = await prisma.staffUser.upsert({
     *   create: {
     *     // ... data to create a StaffUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffUser we want to update
     *   }
     * })
     */
    upsert<T extends StaffUserUpsertArgs>(
      args: SelectSubset<T, StaffUserUpsertArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      $Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more StaffUsers that matches the filter.
     * @param {StaffUserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const staffUser = await prisma.staffUser.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StaffUserFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a StaffUser.
     * @param {StaffUserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const staffUser = await prisma.staffUser.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: StaffUserAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of StaffUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserCountArgs} args - Arguments to filter StaffUsers to count.
     * @example
     * // Count the number of StaffUsers
     * const count = await prisma.staffUser.count({
     *   where: {
     *     // ... the filter for the StaffUsers we want to count
     *   }
     * })
     **/
    count<T extends StaffUserCountArgs>(
      args?: Subset<T, StaffUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], StaffUserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a StaffUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StaffUserAggregateArgs>(
      args: Subset<T, StaffUserAggregateArgs>,
    ): Prisma.PrismaPromise<GetStaffUserAggregateType<T>>;

    /**
     * Group by StaffUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends StaffUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffUserGroupByArgs["orderBy"] }
        : { orderBy?: StaffUserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, StaffUserGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetStaffUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the StaffUser model
     */
    readonly fields: StaffUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffUserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RoleDefaultArgs<ExtArgs>>,
    ): Prisma__RoleClient<
      | $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;
    activityLogs<T extends StaffUser$activityLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, StaffUser$activityLogsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the StaffUser model
   */
  interface StaffUserFieldRefs {
    readonly id: FieldRef<"StaffUser", "String">;
    readonly roleId: FieldRef<"StaffUser", "String">;
    readonly firstName: FieldRef<"StaffUser", "String">;
    readonly lastName: FieldRef<"StaffUser", "String">;
    readonly email: FieldRef<"StaffUser", "String">;
    readonly phone: FieldRef<"StaffUser", "String">;
    readonly passwordHash: FieldRef<"StaffUser", "String">;
    readonly isActive: FieldRef<"StaffUser", "Boolean">;
    readonly emailVerified: FieldRef<"StaffUser", "Boolean">;
    readonly twoFactorEnabled: FieldRef<"StaffUser", "Boolean">;
    readonly twoFactorSecret: FieldRef<"StaffUser", "String">;
    readonly lastLogin: FieldRef<"StaffUser", "DateTime">;
    readonly lastLoginIp: FieldRef<"StaffUser", "String">;
    readonly loginAttempts: FieldRef<"StaffUser", "Int">;
    readonly lockedUntil: FieldRef<"StaffUser", "DateTime">;
    readonly passwordChangedAt: FieldRef<"StaffUser", "DateTime">;
    readonly mustChangePassword: FieldRef<"StaffUser", "Boolean">;
    readonly avatar: FieldRef<"StaffUser", "String">;
    readonly timezone: FieldRef<"StaffUser", "String">;
    readonly language: FieldRef<"StaffUser", "String">;
    readonly canAccessAdmin: FieldRef<"StaffUser", "Boolean">;
    readonly departmentAccess: FieldRef<"StaffUser", "String[]">;
    readonly createdAt: FieldRef<"StaffUser", "DateTime">;
    readonly updatedAt: FieldRef<"StaffUser", "DateTime">;
    readonly createdBy: FieldRef<"StaffUser", "String">;
    readonly lastModifiedBy: FieldRef<"StaffUser", "String">;
  }

  // Custom InputTypes
  /**
   * StaffUser findUnique
   */
  export type StaffUserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * Filter, which StaffUser to fetch.
     */
    where: StaffUserWhereUniqueInput;
  };

  /**
   * StaffUser findUniqueOrThrow
   */
  export type StaffUserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * Filter, which StaffUser to fetch.
     */
    where: StaffUserWhereUniqueInput;
  };

  /**
   * StaffUser findFirst
   */
  export type StaffUserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * Filter, which StaffUser to fetch.
     */
    where?: StaffUserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StaffUsers to fetch.
     */
    orderBy?:
      | StaffUserOrderByWithRelationInput
      | StaffUserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StaffUsers.
     */
    cursor?: StaffUserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StaffUsers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StaffUsers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StaffUsers.
     */
    distinct?: StaffUserScalarFieldEnum | StaffUserScalarFieldEnum[];
  };

  /**
   * StaffUser findFirstOrThrow
   */
  export type StaffUserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * Filter, which StaffUser to fetch.
     */
    where?: StaffUserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StaffUsers to fetch.
     */
    orderBy?:
      | StaffUserOrderByWithRelationInput
      | StaffUserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StaffUsers.
     */
    cursor?: StaffUserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StaffUsers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StaffUsers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StaffUsers.
     */
    distinct?: StaffUserScalarFieldEnum | StaffUserScalarFieldEnum[];
  };

  /**
   * StaffUser findMany
   */
  export type StaffUserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * Filter, which StaffUsers to fetch.
     */
    where?: StaffUserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StaffUsers to fetch.
     */
    orderBy?:
      | StaffUserOrderByWithRelationInput
      | StaffUserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing StaffUsers.
     */
    cursor?: StaffUserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StaffUsers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StaffUsers.
     */
    skip?: number;
    distinct?: StaffUserScalarFieldEnum | StaffUserScalarFieldEnum[];
  };

  /**
   * StaffUser create
   */
  export type StaffUserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * The data needed to create a StaffUser.
     */
    data: XOR<StaffUserCreateInput, StaffUserUncheckedCreateInput>;
  };

  /**
   * StaffUser createMany
   */
  export type StaffUserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many StaffUsers.
     */
    data: StaffUserCreateManyInput | StaffUserCreateManyInput[];
  };

  /**
   * StaffUser update
   */
  export type StaffUserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * The data needed to update a StaffUser.
     */
    data: XOR<StaffUserUpdateInput, StaffUserUncheckedUpdateInput>;
    /**
     * Choose, which StaffUser to update.
     */
    where: StaffUserWhereUniqueInput;
  };

  /**
   * StaffUser updateMany
   */
  export type StaffUserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update StaffUsers.
     */
    data: XOR<
      StaffUserUpdateManyMutationInput,
      StaffUserUncheckedUpdateManyInput
    >;
    /**
     * Filter which StaffUsers to update
     */
    where?: StaffUserWhereInput;
  };

  /**
   * StaffUser upsert
   */
  export type StaffUserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * The filter to search for the StaffUser to update in case it exists.
     */
    where: StaffUserWhereUniqueInput;
    /**
     * In case the StaffUser found by the `where` argument doesn't exist, create a new StaffUser with this data.
     */
    create: XOR<StaffUserCreateInput, StaffUserUncheckedCreateInput>;
    /**
     * In case the StaffUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUserUpdateInput, StaffUserUncheckedUpdateInput>;
  };

  /**
   * StaffUser delete
   */
  export type StaffUserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
    /**
     * Filter which StaffUser to delete.
     */
    where: StaffUserWhereUniqueInput;
  };

  /**
   * StaffUser deleteMany
   */
  export type StaffUserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which StaffUsers to delete
     */
    where?: StaffUserWhereInput;
  };

  /**
   * StaffUser findRaw
   */
  export type StaffUserFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * StaffUser aggregateRaw
   */
  export type StaffUserAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * StaffUser.activityLogs
   */
  export type StaffUser$activityLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    where?: ActivityLogWhereInput;
    orderBy?:
      | ActivityLogOrderByWithRelationInput
      | ActivityLogOrderByWithRelationInput[];
    cursor?: ActivityLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[];
  };

  /**
   * StaffUser without action
   */
  export type StaffUserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null;
  };

  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null;
    _avg: SettingAvgAggregateOutputType | null;
    _sum: SettingSumAggregateOutputType | null;
    _min: SettingMinAggregateOutputType | null;
    _max: SettingMaxAggregateOutputType | null;
  };

  export type SettingAvgAggregateOutputType = {
    sortOrder: number | null;
  };

  export type SettingSumAggregateOutputType = {
    sortOrder: number | null;
  };

  export type SettingMinAggregateOutputType = {
    id: string | null;
    settingKey: string | null;
    category: string | null;
    subcategory: string | null;
    dataType: $Enums.SettingDataType | null;
    isEncrypted: boolean | null;
    isPublic: boolean | null;
    displayName: string | null;
    description: string | null;
    sortOrder: number | null;
    isVisible: boolean | null;
    isEditable: boolean | null;
    updatedBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SettingMaxAggregateOutputType = {
    id: string | null;
    settingKey: string | null;
    category: string | null;
    subcategory: string | null;
    dataType: $Enums.SettingDataType | null;
    isEncrypted: boolean | null;
    isPublic: boolean | null;
    displayName: string | null;
    description: string | null;
    sortOrder: number | null;
    isVisible: boolean | null;
    isEditable: boolean | null;
    updatedBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SettingCountAggregateOutputType = {
    id: number;
    settingKey: number;
    settingValue: number;
    category: number;
    subcategory: number;
    dataType: number;
    isEncrypted: number;
    isPublic: number;
    displayName: number;
    description: number;
    defaultValue: number;
    validation: number;
    sortOrder: number;
    isVisible: number;
    isEditable: number;
    updatedBy: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SettingAvgAggregateInputType = {
    sortOrder?: true;
  };

  export type SettingSumAggregateInputType = {
    sortOrder?: true;
  };

  export type SettingMinAggregateInputType = {
    id?: true;
    settingKey?: true;
    category?: true;
    subcategory?: true;
    dataType?: true;
    isEncrypted?: true;
    isPublic?: true;
    displayName?: true;
    description?: true;
    sortOrder?: true;
    isVisible?: true;
    isEditable?: true;
    updatedBy?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SettingMaxAggregateInputType = {
    id?: true;
    settingKey?: true;
    category?: true;
    subcategory?: true;
    dataType?: true;
    isEncrypted?: true;
    isPublic?: true;
    displayName?: true;
    description?: true;
    sortOrder?: true;
    isVisible?: true;
    isEditable?: true;
    updatedBy?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SettingCountAggregateInputType = {
    id?: true;
    settingKey?: true;
    settingValue?: true;
    category?: true;
    subcategory?: true;
    dataType?: true;
    isEncrypted?: true;
    isPublic?: true;
    displayName?: true;
    description?: true;
    defaultValue?: true;
    validation?: true;
    sortOrder?: true;
    isVisible?: true;
    isEditable?: true;
    updatedBy?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SettingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?:
      | SettingOrderByWithRelationInput
      | SettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Settings
     **/
    _count?: true | SettingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SettingAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SettingSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SettingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SettingMaxAggregateInputType;
  };

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
    [P in keyof T & keyof AggregateSetting]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>;
  };

  export type SettingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SettingWhereInput;
    orderBy?:
      | SettingOrderByWithAggregationInput
      | SettingOrderByWithAggregationInput[];
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum;
    having?: SettingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SettingCountAggregateInputType | true;
    _avg?: SettingAvgAggregateInputType;
    _sum?: SettingSumAggregateInputType;
    _min?: SettingMinAggregateInputType;
    _max?: SettingMaxAggregateInputType;
  };

  export type SettingGroupByOutputType = {
    id: string;
    settingKey: string;
    settingValue: JsonValue;
    category: string;
    subcategory: string | null;
    dataType: $Enums.SettingDataType;
    isEncrypted: boolean;
    isPublic: boolean;
    displayName: string | null;
    description: string | null;
    defaultValue: JsonValue | null;
    validation: JsonValue | null;
    sortOrder: number;
    isVisible: boolean;
    isEditable: boolean;
    updatedBy: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: SettingCountAggregateOutputType | null;
    _avg: SettingAvgAggregateOutputType | null;
    _sum: SettingSumAggregateOutputType | null;
    _min: SettingMinAggregateOutputType | null;
    _max: SettingMaxAggregateOutputType | null;
  };

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SettingGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SettingGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>;
        }
      >
    >;

  export type SettingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      settingKey?: boolean;
      settingValue?: boolean;
      category?: boolean;
      subcategory?: boolean;
      dataType?: boolean;
      isEncrypted?: boolean;
      isPublic?: boolean;
      displayName?: boolean;
      description?: boolean;
      defaultValue?: boolean;
      validation?: boolean;
      sortOrder?: boolean;
      isVisible?: boolean;
      isEditable?: boolean;
      updatedBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["setting"]
  >;

  export type SettingSelectScalar = {
    id?: boolean;
    settingKey?: boolean;
    settingValue?: boolean;
    category?: boolean;
    subcategory?: boolean;
    dataType?: boolean;
    isEncrypted?: boolean;
    isPublic?: boolean;
    displayName?: boolean;
    description?: boolean;
    defaultValue?: boolean;
    validation?: boolean;
    sortOrder?: boolean;
    isVisible?: boolean;
    isEditable?: boolean;
    updatedBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type $SettingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Setting";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        settingKey: string;
        settingValue: Prisma.JsonValue;
        category: string;
        subcategory: string | null;
        dataType: $Enums.SettingDataType;
        isEncrypted: boolean;
        isPublic: boolean;
        displayName: string | null;
        description: string | null;
        defaultValue: Prisma.JsonValue | null;
        validation: Prisma.JsonValue | null;
        sortOrder: number;
        isVisible: boolean;
        isEditable: boolean;
        updatedBy: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["setting"]
    >;
    composites: {};
  };

  type SettingGetPayload<
    S extends boolean | null | undefined | SettingDefaultArgs,
  > = $Result.GetResult<Prisma.$SettingPayload, S>;

  type SettingCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SettingFindManyArgs, "select" | "include" | "distinct"> & {
    select?: SettingCountAggregateInputType | true;
  };

  export interface SettingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Setting"];
      meta: { name: "Setting" };
    };
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(
      args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>,
    ): Prisma__SettingClient<
      $Result.GetResult<
        Prisma.$SettingPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SettingClient<
      $Result.GetResult<
        Prisma.$SettingPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(
      args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>,
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     *
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SettingFindManyArgs>(
      args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     *
     */
    create<T extends SettingCreateArgs>(
      args: SelectSubset<T, SettingCreateArgs<ExtArgs>>,
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SettingCreateManyArgs>(
      args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     *
     */
    delete<T extends SettingDeleteArgs>(
      args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>,
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SettingUpdateArgs>(
      args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>,
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SettingDeleteManyArgs>(
      args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SettingUpdateManyArgs>(
      args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(
      args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>,
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Settings that matches the filter.
     * @param {SettingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const setting = await prisma.setting.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SettingFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Setting.
     * @param {SettingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const setting = await prisma.setting.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: SettingAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
     **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SettingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SettingAggregateArgs>(
      args: Subset<T, SettingAggregateArgs>,
    ): Prisma.PrismaPromise<GetSettingAggregateType<T>>;

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs["orderBy"] }
        : { orderBy?: SettingGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetSettingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Setting model
     */
    readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", "String">;
    readonly settingKey: FieldRef<"Setting", "String">;
    readonly settingValue: FieldRef<"Setting", "Json">;
    readonly category: FieldRef<"Setting", "String">;
    readonly subcategory: FieldRef<"Setting", "String">;
    readonly dataType: FieldRef<"Setting", "SettingDataType">;
    readonly isEncrypted: FieldRef<"Setting", "Boolean">;
    readonly isPublic: FieldRef<"Setting", "Boolean">;
    readonly displayName: FieldRef<"Setting", "String">;
    readonly description: FieldRef<"Setting", "String">;
    readonly defaultValue: FieldRef<"Setting", "Json">;
    readonly validation: FieldRef<"Setting", "Json">;
    readonly sortOrder: FieldRef<"Setting", "Int">;
    readonly isVisible: FieldRef<"Setting", "Boolean">;
    readonly isEditable: FieldRef<"Setting", "Boolean">;
    readonly updatedBy: FieldRef<"Setting", "String">;
    readonly createdAt: FieldRef<"Setting", "DateTime">;
    readonly updatedAt: FieldRef<"Setting", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput;
  };

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput;
  };

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?:
      | SettingOrderByWithRelationInput
      | SettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[];
  };

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?:
      | SettingOrderByWithRelationInput
      | SettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[];
  };

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?:
      | SettingOrderByWithRelationInput
      | SettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number;
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[];
  };

  /**
   * Setting create
   */
  export type SettingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>;
  };

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[];
  };

  /**
   * Setting update
   */
  export type SettingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>;
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput;
  };

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>;
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput;
  };

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput;
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>;
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>;
  };

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput;
  };

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput;
  };

  /**
   * Setting findRaw
   */
  export type SettingFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Setting aggregateRaw
   */
  export type SettingAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
  };

  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null;
    _avg: BannerAvgAggregateOutputType | null;
    _sum: BannerSumAggregateOutputType | null;
    _min: BannerMinAggregateOutputType | null;
    _max: BannerMaxAggregateOutputType | null;
  };

  export type BannerAvgAggregateOutputType = {
    priority: number | null;
    clickCount: number | null;
    viewCount: number | null;
  };

  export type BannerSumAggregateOutputType = {
    priority: number | null;
    clickCount: number | null;
    viewCount: number | null;
  };

  export type BannerMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    subtitle: string | null;
    description: string | null;
    imageUrl: string | null;
    videoUrl: string | null;
    altText: string | null;
    buttonText: string | null;
    buttonUrl: string | null;
    linkTarget: string | null;
    position: $Enums.BannerPosition | null;
    displayType: $Enums.BannerType | null;
    priority: number | null;
    showOnMobile: boolean | null;
    showOnTablet: boolean | null;
    showOnDesktop: boolean | null;
    backgroundColor: string | null;
    textColor: string | null;
    borderColor: string | null;
    startDate: Date | null;
    endDate: Date | null;
    isActive: boolean | null;
    clickCount: number | null;
    viewCount: number | null;
    metaTitle: string | null;
    metaDescription: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type BannerMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    subtitle: string | null;
    description: string | null;
    imageUrl: string | null;
    videoUrl: string | null;
    altText: string | null;
    buttonText: string | null;
    buttonUrl: string | null;
    linkTarget: string | null;
    position: $Enums.BannerPosition | null;
    displayType: $Enums.BannerType | null;
    priority: number | null;
    showOnMobile: boolean | null;
    showOnTablet: boolean | null;
    showOnDesktop: boolean | null;
    backgroundColor: string | null;
    textColor: string | null;
    borderColor: string | null;
    startDate: Date | null;
    endDate: Date | null;
    isActive: boolean | null;
    clickCount: number | null;
    viewCount: number | null;
    metaTitle: string | null;
    metaDescription: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type BannerCountAggregateOutputType = {
    id: number;
    title: number;
    subtitle: number;
    description: number;
    imageUrl: number;
    videoUrl: number;
    altText: number;
    buttonText: number;
    buttonUrl: number;
    linkTarget: number;
    position: number;
    displayType: number;
    priority: number;
    showOnMobile: number;
    showOnTablet: number;
    showOnDesktop: number;
    backgroundColor: number;
    textColor: number;
    borderColor: number;
    startDate: number;
    endDate: number;
    isActive: number;
    clickCount: number;
    viewCount: number;
    metaTitle: number;
    metaDescription: number;
    createdAt: number;
    updatedAt: number;
    createdBy: number;
    _all: number;
  };

  export type BannerAvgAggregateInputType = {
    priority?: true;
    clickCount?: true;
    viewCount?: true;
  };

  export type BannerSumAggregateInputType = {
    priority?: true;
    clickCount?: true;
    viewCount?: true;
  };

  export type BannerMinAggregateInputType = {
    id?: true;
    title?: true;
    subtitle?: true;
    description?: true;
    imageUrl?: true;
    videoUrl?: true;
    altText?: true;
    buttonText?: true;
    buttonUrl?: true;
    linkTarget?: true;
    position?: true;
    displayType?: true;
    priority?: true;
    showOnMobile?: true;
    showOnTablet?: true;
    showOnDesktop?: true;
    backgroundColor?: true;
    textColor?: true;
    borderColor?: true;
    startDate?: true;
    endDate?: true;
    isActive?: true;
    clickCount?: true;
    viewCount?: true;
    metaTitle?: true;
    metaDescription?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type BannerMaxAggregateInputType = {
    id?: true;
    title?: true;
    subtitle?: true;
    description?: true;
    imageUrl?: true;
    videoUrl?: true;
    altText?: true;
    buttonText?: true;
    buttonUrl?: true;
    linkTarget?: true;
    position?: true;
    displayType?: true;
    priority?: true;
    showOnMobile?: true;
    showOnTablet?: true;
    showOnDesktop?: true;
    backgroundColor?: true;
    textColor?: true;
    borderColor?: true;
    startDate?: true;
    endDate?: true;
    isActive?: true;
    clickCount?: true;
    viewCount?: true;
    metaTitle?: true;
    metaDescription?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type BannerCountAggregateInputType = {
    id?: true;
    title?: true;
    subtitle?: true;
    description?: true;
    imageUrl?: true;
    videoUrl?: true;
    altText?: true;
    buttonText?: true;
    buttonUrl?: true;
    linkTarget?: true;
    position?: true;
    displayType?: true;
    priority?: true;
    showOnMobile?: true;
    showOnTablet?: true;
    showOnDesktop?: true;
    backgroundColor?: true;
    textColor?: true;
    borderColor?: true;
    startDate?: true;
    endDate?: true;
    isActive?: true;
    clickCount?: true;
    viewCount?: true;
    metaTitle?: true;
    metaDescription?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    _all?: true;
  };

  export type BannerAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Banners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Banners
     **/
    _count?: true | BannerCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: BannerAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: BannerSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BannerMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BannerMaxAggregateInputType;
  };

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
    [P in keyof T & keyof AggregateBanner]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>;
  };

  export type BannerGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BannerWhereInput;
    orderBy?:
      | BannerOrderByWithAggregationInput
      | BannerOrderByWithAggregationInput[];
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum;
    having?: BannerScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BannerCountAggregateInputType | true;
    _avg?: BannerAvgAggregateInputType;
    _sum?: BannerSumAggregateInputType;
    _min?: BannerMinAggregateInputType;
    _max?: BannerMaxAggregateInputType;
  };

  export type BannerGroupByOutputType = {
    id: string;
    title: string;
    subtitle: string | null;
    description: string | null;
    imageUrl: string | null;
    videoUrl: string | null;
    altText: string | null;
    buttonText: string | null;
    buttonUrl: string | null;
    linkTarget: string;
    position: $Enums.BannerPosition;
    displayType: $Enums.BannerType;
    priority: number;
    showOnMobile: boolean;
    showOnTablet: boolean;
    showOnDesktop: boolean;
    backgroundColor: string | null;
    textColor: string | null;
    borderColor: string | null;
    startDate: Date | null;
    endDate: Date | null;
    isActive: boolean;
    clickCount: number;
    viewCount: number;
    metaTitle: string | null;
    metaDescription: string | null;
    createdAt: Date;
    updatedAt: Date;
    createdBy: string | null;
    _count: BannerCountAggregateOutputType | null;
    _avg: BannerAvgAggregateOutputType | null;
    _sum: BannerSumAggregateOutputType | null;
    _min: BannerMinAggregateOutputType | null;
    _max: BannerMaxAggregateOutputType | null;
  };

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<BannerGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof BannerGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>;
        }
      >
    >;

  export type BannerSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      subtitle?: boolean;
      description?: boolean;
      imageUrl?: boolean;
      videoUrl?: boolean;
      altText?: boolean;
      buttonText?: boolean;
      buttonUrl?: boolean;
      linkTarget?: boolean;
      position?: boolean;
      displayType?: boolean;
      priority?: boolean;
      showOnMobile?: boolean;
      showOnTablet?: boolean;
      showOnDesktop?: boolean;
      backgroundColor?: boolean;
      textColor?: boolean;
      borderColor?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      isActive?: boolean;
      clickCount?: boolean;
      viewCount?: boolean;
      metaTitle?: boolean;
      metaDescription?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs["result"]["banner"]
  >;

  export type BannerSelectScalar = {
    id?: boolean;
    title?: boolean;
    subtitle?: boolean;
    description?: boolean;
    imageUrl?: boolean;
    videoUrl?: boolean;
    altText?: boolean;
    buttonText?: boolean;
    buttonUrl?: boolean;
    linkTarget?: boolean;
    position?: boolean;
    displayType?: boolean;
    priority?: boolean;
    showOnMobile?: boolean;
    showOnTablet?: boolean;
    showOnDesktop?: boolean;
    backgroundColor?: boolean;
    textColor?: boolean;
    borderColor?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    isActive?: boolean;
    clickCount?: boolean;
    viewCount?: boolean;
    metaTitle?: boolean;
    metaDescription?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean;
  };

  export type $BannerPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Banner";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        subtitle: string | null;
        description: string | null;
        imageUrl: string | null;
        videoUrl: string | null;
        altText: string | null;
        buttonText: string | null;
        buttonUrl: string | null;
        linkTarget: string;
        position: $Enums.BannerPosition;
        displayType: $Enums.BannerType;
        priority: number;
        showOnMobile: boolean;
        showOnTablet: boolean;
        showOnDesktop: boolean;
        backgroundColor: string | null;
        textColor: string | null;
        borderColor: string | null;
        startDate: Date | null;
        endDate: Date | null;
        isActive: boolean;
        clickCount: number;
        viewCount: number;
        metaTitle: string | null;
        metaDescription: string | null;
        createdAt: Date;
        updatedAt: Date;
        createdBy: string | null;
      },
      ExtArgs["result"]["banner"]
    >;
    composites: {};
  };

  type BannerGetPayload<
    S extends boolean | null | undefined | BannerDefaultArgs,
  > = $Result.GetResult<Prisma.$BannerPayload, S>;

  type BannerCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<BannerFindManyArgs, "select" | "include" | "distinct"> & {
    select?: BannerCountAggregateInputType | true;
  };

  export interface BannerDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Banner"];
      meta: { name: "Banner" };
    };
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(
      args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>,
    ): Prisma__BannerClient<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(
      args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__BannerClient<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(
      args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>,
    ): Prisma__BannerClient<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__BannerClient<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     *
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BannerFindManyArgs>(
      args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     *
     */
    create<T extends BannerCreateArgs>(
      args: SelectSubset<T, BannerCreateArgs<ExtArgs>>,
    ): Prisma__BannerClient<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BannerCreateManyArgs>(
      args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     *
     */
    delete<T extends BannerDeleteArgs>(
      args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>,
    ): Prisma__BannerClient<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BannerUpdateArgs>(
      args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>,
    ): Prisma__BannerClient<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BannerDeleteManyArgs>(
      args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BannerUpdateManyArgs>(
      args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(
      args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>,
    ): Prisma__BannerClient<
      $Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Banners that matches the filter.
     * @param {BannerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const banner = await prisma.banner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BannerFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Banner.
     * @param {BannerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const banner = await prisma.banner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: BannerAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
     **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], BannerCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BannerAggregateArgs>(
      args: Subset<T, BannerAggregateArgs>,
    ): Prisma.PrismaPromise<GetBannerAggregateType<T>>;

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs["orderBy"] }
        : { orderBy?: BannerGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetBannerGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Banner model
     */
    readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", "String">;
    readonly title: FieldRef<"Banner", "String">;
    readonly subtitle: FieldRef<"Banner", "String">;
    readonly description: FieldRef<"Banner", "String">;
    readonly imageUrl: FieldRef<"Banner", "String">;
    readonly videoUrl: FieldRef<"Banner", "String">;
    readonly altText: FieldRef<"Banner", "String">;
    readonly buttonText: FieldRef<"Banner", "String">;
    readonly buttonUrl: FieldRef<"Banner", "String">;
    readonly linkTarget: FieldRef<"Banner", "String">;
    readonly position: FieldRef<"Banner", "BannerPosition">;
    readonly displayType: FieldRef<"Banner", "BannerType">;
    readonly priority: FieldRef<"Banner", "Int">;
    readonly showOnMobile: FieldRef<"Banner", "Boolean">;
    readonly showOnTablet: FieldRef<"Banner", "Boolean">;
    readonly showOnDesktop: FieldRef<"Banner", "Boolean">;
    readonly backgroundColor: FieldRef<"Banner", "String">;
    readonly textColor: FieldRef<"Banner", "String">;
    readonly borderColor: FieldRef<"Banner", "String">;
    readonly startDate: FieldRef<"Banner", "DateTime">;
    readonly endDate: FieldRef<"Banner", "DateTime">;
    readonly isActive: FieldRef<"Banner", "Boolean">;
    readonly clickCount: FieldRef<"Banner", "Int">;
    readonly viewCount: FieldRef<"Banner", "Int">;
    readonly metaTitle: FieldRef<"Banner", "String">;
    readonly metaDescription: FieldRef<"Banner", "String">;
    readonly createdAt: FieldRef<"Banner", "DateTime">;
    readonly updatedAt: FieldRef<"Banner", "DateTime">;
    readonly createdBy: FieldRef<"Banner", "String">;
  }

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput;
  };

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput;
  };

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Banners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[];
  };

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Banners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[];
  };

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Banners.
     */
    skip?: number;
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[];
  };

  /**
   * Banner create
   */
  export type BannerCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>;
  };

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[];
  };

  /**
   * Banner update
   */
  export type BannerUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>;
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput;
  };

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>;
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput;
  };

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput;
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>;
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>;
  };

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput;
  };

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput;
  };

  /**
   * Banner findRaw
   */
  export type BannerFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Banner aggregateRaw
   */
  export type BannerAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null;
  };

  /**
   * Model HeroSlide
   */

  export type AggregateHeroSlide = {
    _count: HeroSlideCountAggregateOutputType | null;
    _avg: HeroSlideAvgAggregateOutputType | null;
    _sum: HeroSlideSumAggregateOutputType | null;
    _min: HeroSlideMinAggregateOutputType | null;
    _max: HeroSlideMaxAggregateOutputType | null;
  };

  export type HeroSlideAvgAggregateOutputType = {
    overlayOpacity: number | null;
    displayDuration: number | null;
    sortOrder: number | null;
    clickCount: number | null;
    viewCount: number | null;
  };

  export type HeroSlideSumAggregateOutputType = {
    overlayOpacity: number | null;
    displayDuration: number | null;
    sortOrder: number | null;
    clickCount: number | null;
    viewCount: number | null;
  };

  export type HeroSlideMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    subtitle: string | null;
    description: string | null;
    imageUrl: string | null;
    mobileImageUrl: string | null;
    altText: string | null;
    primaryButtonText: string | null;
    primaryButtonUrl: string | null;
    secondaryButtonText: string | null;
    secondaryButtonUrl: string | null;
    textPosition: $Enums.SlideTextPosition | null;
    overlayOpacity: number | null;
    textColor: string | null;
    animationType: $Enums.SlideAnimation | null;
    displayDuration: number | null;
    sortOrder: number | null;
    isActive: boolean | null;
    startDate: Date | null;
    endDate: Date | null;
    showOnMobile: boolean | null;
    showOnTablet: boolean | null;
    showOnDesktop: boolean | null;
    clickCount: number | null;
    viewCount: number | null;
    metaTitle: string | null;
    metaDescription: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type HeroSlideMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    subtitle: string | null;
    description: string | null;
    imageUrl: string | null;
    mobileImageUrl: string | null;
    altText: string | null;
    primaryButtonText: string | null;
    primaryButtonUrl: string | null;
    secondaryButtonText: string | null;
    secondaryButtonUrl: string | null;
    textPosition: $Enums.SlideTextPosition | null;
    overlayOpacity: number | null;
    textColor: string | null;
    animationType: $Enums.SlideAnimation | null;
    displayDuration: number | null;
    sortOrder: number | null;
    isActive: boolean | null;
    startDate: Date | null;
    endDate: Date | null;
    showOnMobile: boolean | null;
    showOnTablet: boolean | null;
    showOnDesktop: boolean | null;
    clickCount: number | null;
    viewCount: number | null;
    metaTitle: string | null;
    metaDescription: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type HeroSlideCountAggregateOutputType = {
    id: number;
    title: number;
    subtitle: number;
    description: number;
    imageUrl: number;
    mobileImageUrl: number;
    altText: number;
    primaryButtonText: number;
    primaryButtonUrl: number;
    secondaryButtonText: number;
    secondaryButtonUrl: number;
    textPosition: number;
    overlayOpacity: number;
    textColor: number;
    animationType: number;
    displayDuration: number;
    sortOrder: number;
    isActive: number;
    startDate: number;
    endDate: number;
    showOnMobile: number;
    showOnTablet: number;
    showOnDesktop: number;
    clickCount: number;
    viewCount: number;
    metaTitle: number;
    metaDescription: number;
    createdAt: number;
    updatedAt: number;
    createdBy: number;
    _all: number;
  };

  export type HeroSlideAvgAggregateInputType = {
    overlayOpacity?: true;
    displayDuration?: true;
    sortOrder?: true;
    clickCount?: true;
    viewCount?: true;
  };

  export type HeroSlideSumAggregateInputType = {
    overlayOpacity?: true;
    displayDuration?: true;
    sortOrder?: true;
    clickCount?: true;
    viewCount?: true;
  };

  export type HeroSlideMinAggregateInputType = {
    id?: true;
    title?: true;
    subtitle?: true;
    description?: true;
    imageUrl?: true;
    mobileImageUrl?: true;
    altText?: true;
    primaryButtonText?: true;
    primaryButtonUrl?: true;
    secondaryButtonText?: true;
    secondaryButtonUrl?: true;
    textPosition?: true;
    overlayOpacity?: true;
    textColor?: true;
    animationType?: true;
    displayDuration?: true;
    sortOrder?: true;
    isActive?: true;
    startDate?: true;
    endDate?: true;
    showOnMobile?: true;
    showOnTablet?: true;
    showOnDesktop?: true;
    clickCount?: true;
    viewCount?: true;
    metaTitle?: true;
    metaDescription?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type HeroSlideMaxAggregateInputType = {
    id?: true;
    title?: true;
    subtitle?: true;
    description?: true;
    imageUrl?: true;
    mobileImageUrl?: true;
    altText?: true;
    primaryButtonText?: true;
    primaryButtonUrl?: true;
    secondaryButtonText?: true;
    secondaryButtonUrl?: true;
    textPosition?: true;
    overlayOpacity?: true;
    textColor?: true;
    animationType?: true;
    displayDuration?: true;
    sortOrder?: true;
    isActive?: true;
    startDate?: true;
    endDate?: true;
    showOnMobile?: true;
    showOnTablet?: true;
    showOnDesktop?: true;
    clickCount?: true;
    viewCount?: true;
    metaTitle?: true;
    metaDescription?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type HeroSlideCountAggregateInputType = {
    id?: true;
    title?: true;
    subtitle?: true;
    description?: true;
    imageUrl?: true;
    mobileImageUrl?: true;
    altText?: true;
    primaryButtonText?: true;
    primaryButtonUrl?: true;
    secondaryButtonText?: true;
    secondaryButtonUrl?: true;
    textPosition?: true;
    overlayOpacity?: true;
    textColor?: true;
    animationType?: true;
    displayDuration?: true;
    sortOrder?: true;
    isActive?: true;
    startDate?: true;
    endDate?: true;
    showOnMobile?: true;
    showOnTablet?: true;
    showOnDesktop?: true;
    clickCount?: true;
    viewCount?: true;
    metaTitle?: true;
    metaDescription?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    _all?: true;
  };

  export type HeroSlideAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which HeroSlide to aggregate.
     */
    where?: HeroSlideWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HeroSlides to fetch.
     */
    orderBy?:
      | HeroSlideOrderByWithRelationInput
      | HeroSlideOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: HeroSlideWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HeroSlides from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HeroSlides.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned HeroSlides
     **/
    _count?: true | HeroSlideCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: HeroSlideAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: HeroSlideSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: HeroSlideMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: HeroSlideMaxAggregateInputType;
  };

  export type GetHeroSlideAggregateType<T extends HeroSlideAggregateArgs> = {
    [P in keyof T & keyof AggregateHeroSlide]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroSlide[P]>
      : GetScalarType<T[P], AggregateHeroSlide[P]>;
  };

  export type HeroSlideGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: HeroSlideWhereInput;
    orderBy?:
      | HeroSlideOrderByWithAggregationInput
      | HeroSlideOrderByWithAggregationInput[];
    by: HeroSlideScalarFieldEnum[] | HeroSlideScalarFieldEnum;
    having?: HeroSlideScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: HeroSlideCountAggregateInputType | true;
    _avg?: HeroSlideAvgAggregateInputType;
    _sum?: HeroSlideSumAggregateInputType;
    _min?: HeroSlideMinAggregateInputType;
    _max?: HeroSlideMaxAggregateInputType;
  };

  export type HeroSlideGroupByOutputType = {
    id: string;
    title: string;
    subtitle: string | null;
    description: string | null;
    imageUrl: string;
    mobileImageUrl: string | null;
    altText: string | null;
    primaryButtonText: string | null;
    primaryButtonUrl: string | null;
    secondaryButtonText: string | null;
    secondaryButtonUrl: string | null;
    textPosition: $Enums.SlideTextPosition;
    overlayOpacity: number;
    textColor: string;
    animationType: $Enums.SlideAnimation;
    displayDuration: number;
    sortOrder: number;
    isActive: boolean;
    startDate: Date | null;
    endDate: Date | null;
    showOnMobile: boolean;
    showOnTablet: boolean;
    showOnDesktop: boolean;
    clickCount: number;
    viewCount: number;
    metaTitle: string | null;
    metaDescription: string | null;
    createdAt: Date;
    updatedAt: Date;
    createdBy: string | null;
    _count: HeroSlideCountAggregateOutputType | null;
    _avg: HeroSlideAvgAggregateOutputType | null;
    _sum: HeroSlideSumAggregateOutputType | null;
    _min: HeroSlideMinAggregateOutputType | null;
    _max: HeroSlideMaxAggregateOutputType | null;
  };

  type GetHeroSlideGroupByPayload<T extends HeroSlideGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<HeroSlideGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof HeroSlideGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroSlideGroupByOutputType[P]>
            : GetScalarType<T[P], HeroSlideGroupByOutputType[P]>;
        }
      >
    >;

  export type HeroSlideSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      subtitle?: boolean;
      description?: boolean;
      imageUrl?: boolean;
      mobileImageUrl?: boolean;
      altText?: boolean;
      primaryButtonText?: boolean;
      primaryButtonUrl?: boolean;
      secondaryButtonText?: boolean;
      secondaryButtonUrl?: boolean;
      textPosition?: boolean;
      overlayOpacity?: boolean;
      textColor?: boolean;
      animationType?: boolean;
      displayDuration?: boolean;
      sortOrder?: boolean;
      isActive?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      showOnMobile?: boolean;
      showOnTablet?: boolean;
      showOnDesktop?: boolean;
      clickCount?: boolean;
      viewCount?: boolean;
      metaTitle?: boolean;
      metaDescription?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs["result"]["heroSlide"]
  >;

  export type HeroSlideSelectScalar = {
    id?: boolean;
    title?: boolean;
    subtitle?: boolean;
    description?: boolean;
    imageUrl?: boolean;
    mobileImageUrl?: boolean;
    altText?: boolean;
    primaryButtonText?: boolean;
    primaryButtonUrl?: boolean;
    secondaryButtonText?: boolean;
    secondaryButtonUrl?: boolean;
    textPosition?: boolean;
    overlayOpacity?: boolean;
    textColor?: boolean;
    animationType?: boolean;
    displayDuration?: boolean;
    sortOrder?: boolean;
    isActive?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    showOnMobile?: boolean;
    showOnTablet?: boolean;
    showOnDesktop?: boolean;
    clickCount?: boolean;
    viewCount?: boolean;
    metaTitle?: boolean;
    metaDescription?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean;
  };

  export type $HeroSlidePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "HeroSlide";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        subtitle: string | null;
        description: string | null;
        imageUrl: string;
        mobileImageUrl: string | null;
        altText: string | null;
        primaryButtonText: string | null;
        primaryButtonUrl: string | null;
        secondaryButtonText: string | null;
        secondaryButtonUrl: string | null;
        textPosition: $Enums.SlideTextPosition;
        overlayOpacity: number;
        textColor: string;
        animationType: $Enums.SlideAnimation;
        displayDuration: number;
        sortOrder: number;
        isActive: boolean;
        startDate: Date | null;
        endDate: Date | null;
        showOnMobile: boolean;
        showOnTablet: boolean;
        showOnDesktop: boolean;
        clickCount: number;
        viewCount: number;
        metaTitle: string | null;
        metaDescription: string | null;
        createdAt: Date;
        updatedAt: Date;
        createdBy: string | null;
      },
      ExtArgs["result"]["heroSlide"]
    >;
    composites: {};
  };

  type HeroSlideGetPayload<
    S extends boolean | null | undefined | HeroSlideDefaultArgs,
  > = $Result.GetResult<Prisma.$HeroSlidePayload, S>;

  type HeroSlideCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<HeroSlideFindManyArgs, "select" | "include" | "distinct"> & {
    select?: HeroSlideCountAggregateInputType | true;
  };

  export interface HeroSlideDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["HeroSlide"];
      meta: { name: "HeroSlide" };
    };
    /**
     * Find zero or one HeroSlide that matches the filter.
     * @param {HeroSlideFindUniqueArgs} args - Arguments to find a HeroSlide
     * @example
     * // Get one HeroSlide
     * const heroSlide = await prisma.heroSlide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroSlideFindUniqueArgs>(
      args: SelectSubset<T, HeroSlideFindUniqueArgs<ExtArgs>>,
    ): Prisma__HeroSlideClient<
      $Result.GetResult<
        Prisma.$HeroSlidePayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one HeroSlide that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HeroSlideFindUniqueOrThrowArgs} args - Arguments to find a HeroSlide
     * @example
     * // Get one HeroSlide
     * const heroSlide = await prisma.heroSlide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroSlideFindUniqueOrThrowArgs>(
      args: SelectSubset<T, HeroSlideFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__HeroSlideClient<
      $Result.GetResult<
        Prisma.$HeroSlidePayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first HeroSlide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideFindFirstArgs} args - Arguments to find a HeroSlide
     * @example
     * // Get one HeroSlide
     * const heroSlide = await prisma.heroSlide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroSlideFindFirstArgs>(
      args?: SelectSubset<T, HeroSlideFindFirstArgs<ExtArgs>>,
    ): Prisma__HeroSlideClient<
      $Result.GetResult<
        Prisma.$HeroSlidePayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first HeroSlide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideFindFirstOrThrowArgs} args - Arguments to find a HeroSlide
     * @example
     * // Get one HeroSlide
     * const heroSlide = await prisma.heroSlide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroSlideFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HeroSlideFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__HeroSlideClient<
      $Result.GetResult<
        Prisma.$HeroSlidePayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more HeroSlides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroSlides
     * const heroSlides = await prisma.heroSlide.findMany()
     *
     * // Get first 10 HeroSlides
     * const heroSlides = await prisma.heroSlide.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const heroSlideWithIdOnly = await prisma.heroSlide.findMany({ select: { id: true } })
     *
     */
    findMany<T extends HeroSlideFindManyArgs>(
      args?: SelectSubset<T, HeroSlideFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a HeroSlide.
     * @param {HeroSlideCreateArgs} args - Arguments to create a HeroSlide.
     * @example
     * // Create one HeroSlide
     * const HeroSlide = await prisma.heroSlide.create({
     *   data: {
     *     // ... data to create a HeroSlide
     *   }
     * })
     *
     */
    create<T extends HeroSlideCreateArgs>(
      args: SelectSubset<T, HeroSlideCreateArgs<ExtArgs>>,
    ): Prisma__HeroSlideClient<
      $Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many HeroSlides.
     * @param {HeroSlideCreateManyArgs} args - Arguments to create many HeroSlides.
     * @example
     * // Create many HeroSlides
     * const heroSlide = await prisma.heroSlide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends HeroSlideCreateManyArgs>(
      args?: SelectSubset<T, HeroSlideCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a HeroSlide.
     * @param {HeroSlideDeleteArgs} args - Arguments to delete one HeroSlide.
     * @example
     * // Delete one HeroSlide
     * const HeroSlide = await prisma.heroSlide.delete({
     *   where: {
     *     // ... filter to delete one HeroSlide
     *   }
     * })
     *
     */
    delete<T extends HeroSlideDeleteArgs>(
      args: SelectSubset<T, HeroSlideDeleteArgs<ExtArgs>>,
    ): Prisma__HeroSlideClient<
      $Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one HeroSlide.
     * @param {HeroSlideUpdateArgs} args - Arguments to update one HeroSlide.
     * @example
     * // Update one HeroSlide
     * const heroSlide = await prisma.heroSlide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends HeroSlideUpdateArgs>(
      args: SelectSubset<T, HeroSlideUpdateArgs<ExtArgs>>,
    ): Prisma__HeroSlideClient<
      $Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more HeroSlides.
     * @param {HeroSlideDeleteManyArgs} args - Arguments to filter HeroSlides to delete.
     * @example
     * // Delete a few HeroSlides
     * const { count } = await prisma.heroSlide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends HeroSlideDeleteManyArgs>(
      args?: SelectSubset<T, HeroSlideDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more HeroSlides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroSlides
     * const heroSlide = await prisma.heroSlide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends HeroSlideUpdateManyArgs>(
      args: SelectSubset<T, HeroSlideUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one HeroSlide.
     * @param {HeroSlideUpsertArgs} args - Arguments to update or create a HeroSlide.
     * @example
     * // Update or create a HeroSlide
     * const heroSlide = await prisma.heroSlide.upsert({
     *   create: {
     *     // ... data to create a HeroSlide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroSlide we want to update
     *   }
     * })
     */
    upsert<T extends HeroSlideUpsertArgs>(
      args: SelectSubset<T, HeroSlideUpsertArgs<ExtArgs>>,
    ): Prisma__HeroSlideClient<
      $Result.GetResult<Prisma.$HeroSlidePayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more HeroSlides that matches the filter.
     * @param {HeroSlideFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const heroSlide = await prisma.heroSlide.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: HeroSlideFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a HeroSlide.
     * @param {HeroSlideAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const heroSlide = await prisma.heroSlide.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: HeroSlideAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of HeroSlides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideCountArgs} args - Arguments to filter HeroSlides to count.
     * @example
     * // Count the number of HeroSlides
     * const count = await prisma.heroSlide.count({
     *   where: {
     *     // ... the filter for the HeroSlides we want to count
     *   }
     * })
     **/
    count<T extends HeroSlideCountArgs>(
      args?: Subset<T, HeroSlideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], HeroSlideCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a HeroSlide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends HeroSlideAggregateArgs>(
      args: Subset<T, HeroSlideAggregateArgs>,
    ): Prisma.PrismaPromise<GetHeroSlideAggregateType<T>>;

    /**
     * Group by HeroSlide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends HeroSlideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroSlideGroupByArgs["orderBy"] }
        : { orderBy?: HeroSlideGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, HeroSlideGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetHeroSlideGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the HeroSlide model
     */
    readonly fields: HeroSlideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroSlide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroSlideClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the HeroSlide model
   */
  interface HeroSlideFieldRefs {
    readonly id: FieldRef<"HeroSlide", "String">;
    readonly title: FieldRef<"HeroSlide", "String">;
    readonly subtitle: FieldRef<"HeroSlide", "String">;
    readonly description: FieldRef<"HeroSlide", "String">;
    readonly imageUrl: FieldRef<"HeroSlide", "String">;
    readonly mobileImageUrl: FieldRef<"HeroSlide", "String">;
    readonly altText: FieldRef<"HeroSlide", "String">;
    readonly primaryButtonText: FieldRef<"HeroSlide", "String">;
    readonly primaryButtonUrl: FieldRef<"HeroSlide", "String">;
    readonly secondaryButtonText: FieldRef<"HeroSlide", "String">;
    readonly secondaryButtonUrl: FieldRef<"HeroSlide", "String">;
    readonly textPosition: FieldRef<"HeroSlide", "SlideTextPosition">;
    readonly overlayOpacity: FieldRef<"HeroSlide", "Float">;
    readonly textColor: FieldRef<"HeroSlide", "String">;
    readonly animationType: FieldRef<"HeroSlide", "SlideAnimation">;
    readonly displayDuration: FieldRef<"HeroSlide", "Int">;
    readonly sortOrder: FieldRef<"HeroSlide", "Int">;
    readonly isActive: FieldRef<"HeroSlide", "Boolean">;
    readonly startDate: FieldRef<"HeroSlide", "DateTime">;
    readonly endDate: FieldRef<"HeroSlide", "DateTime">;
    readonly showOnMobile: FieldRef<"HeroSlide", "Boolean">;
    readonly showOnTablet: FieldRef<"HeroSlide", "Boolean">;
    readonly showOnDesktop: FieldRef<"HeroSlide", "Boolean">;
    readonly clickCount: FieldRef<"HeroSlide", "Int">;
    readonly viewCount: FieldRef<"HeroSlide", "Int">;
    readonly metaTitle: FieldRef<"HeroSlide", "String">;
    readonly metaDescription: FieldRef<"HeroSlide", "String">;
    readonly createdAt: FieldRef<"HeroSlide", "DateTime">;
    readonly updatedAt: FieldRef<"HeroSlide", "DateTime">;
    readonly createdBy: FieldRef<"HeroSlide", "String">;
  }

  // Custom InputTypes
  /**
   * HeroSlide findUnique
   */
  export type HeroSlideFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * Filter, which HeroSlide to fetch.
     */
    where: HeroSlideWhereUniqueInput;
  };

  /**
   * HeroSlide findUniqueOrThrow
   */
  export type HeroSlideFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * Filter, which HeroSlide to fetch.
     */
    where: HeroSlideWhereUniqueInput;
  };

  /**
   * HeroSlide findFirst
   */
  export type HeroSlideFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * Filter, which HeroSlide to fetch.
     */
    where?: HeroSlideWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HeroSlides to fetch.
     */
    orderBy?:
      | HeroSlideOrderByWithRelationInput
      | HeroSlideOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HeroSlides.
     */
    cursor?: HeroSlideWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HeroSlides from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HeroSlides.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HeroSlides.
     */
    distinct?: HeroSlideScalarFieldEnum | HeroSlideScalarFieldEnum[];
  };

  /**
   * HeroSlide findFirstOrThrow
   */
  export type HeroSlideFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * Filter, which HeroSlide to fetch.
     */
    where?: HeroSlideWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HeroSlides to fetch.
     */
    orderBy?:
      | HeroSlideOrderByWithRelationInput
      | HeroSlideOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HeroSlides.
     */
    cursor?: HeroSlideWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HeroSlides from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HeroSlides.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HeroSlides.
     */
    distinct?: HeroSlideScalarFieldEnum | HeroSlideScalarFieldEnum[];
  };

  /**
   * HeroSlide findMany
   */
  export type HeroSlideFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * Filter, which HeroSlides to fetch.
     */
    where?: HeroSlideWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HeroSlides to fetch.
     */
    orderBy?:
      | HeroSlideOrderByWithRelationInput
      | HeroSlideOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing HeroSlides.
     */
    cursor?: HeroSlideWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HeroSlides from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HeroSlides.
     */
    skip?: number;
    distinct?: HeroSlideScalarFieldEnum | HeroSlideScalarFieldEnum[];
  };

  /**
   * HeroSlide create
   */
  export type HeroSlideCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * The data needed to create a HeroSlide.
     */
    data: XOR<HeroSlideCreateInput, HeroSlideUncheckedCreateInput>;
  };

  /**
   * HeroSlide createMany
   */
  export type HeroSlideCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many HeroSlides.
     */
    data: HeroSlideCreateManyInput | HeroSlideCreateManyInput[];
  };

  /**
   * HeroSlide update
   */
  export type HeroSlideUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * The data needed to update a HeroSlide.
     */
    data: XOR<HeroSlideUpdateInput, HeroSlideUncheckedUpdateInput>;
    /**
     * Choose, which HeroSlide to update.
     */
    where: HeroSlideWhereUniqueInput;
  };

  /**
   * HeroSlide updateMany
   */
  export type HeroSlideUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update HeroSlides.
     */
    data: XOR<
      HeroSlideUpdateManyMutationInput,
      HeroSlideUncheckedUpdateManyInput
    >;
    /**
     * Filter which HeroSlides to update
     */
    where?: HeroSlideWhereInput;
  };

  /**
   * HeroSlide upsert
   */
  export type HeroSlideUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * The filter to search for the HeroSlide to update in case it exists.
     */
    where: HeroSlideWhereUniqueInput;
    /**
     * In case the HeroSlide found by the `where` argument doesn't exist, create a new HeroSlide with this data.
     */
    create: XOR<HeroSlideCreateInput, HeroSlideUncheckedCreateInput>;
    /**
     * In case the HeroSlide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroSlideUpdateInput, HeroSlideUncheckedUpdateInput>;
  };

  /**
   * HeroSlide delete
   */
  export type HeroSlideDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
    /**
     * Filter which HeroSlide to delete.
     */
    where: HeroSlideWhereUniqueInput;
  };

  /**
   * HeroSlide deleteMany
   */
  export type HeroSlideDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which HeroSlides to delete
     */
    where?: HeroSlideWhereInput;
  };

  /**
   * HeroSlide findRaw
   */
  export type HeroSlideFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * HeroSlide aggregateRaw
   */
  export type HeroSlideAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * HeroSlide without action
   */
  export type HeroSlideDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HeroSlide
     */
    select?: HeroSlideSelect<ExtArgs> | null;
  };

  /**
   * Model SiteCustomization
   */

  export type AggregateSiteCustomization = {
    _count: SiteCustomizationCountAggregateOutputType | null;
    _min: SiteCustomizationMinAggregateOutputType | null;
    _max: SiteCustomizationMaxAggregateOutputType | null;
  };

  export type SiteCustomizationMinAggregateOutputType = {
    id: string | null;
    siteName: string | null;
    siteDescription: string | null;
    logoUrl: string | null;
    faviconUrl: string | null;
    primaryColor: string | null;
    secondaryColor: string | null;
    accentColor: string | null;
    backgroundColor: string | null;
    textColor: string | null;
    linkColor: string | null;
    primaryFont: string | null;
    secondaryFont: string | null;
    fontSize: string | null;
    headerStyle: string | null;
    footerStyle: string | null;
    borderRadius: string | null;
    showSearch: boolean | null;
    showWishlist: boolean | null;
    showCompare: boolean | null;
    showReviews: boolean | null;
    enableChat: boolean | null;
    enableNewsletter: boolean | null;
    contactEmail: string | null;
    contactPhone: string | null;
    metaTitle: string | null;
    metaDescription: string | null;
    metaKeywords: string | null;
    googleAnalytics: string | null;
    privacyPolicyUrl: string | null;
    termsOfServiceUrl: string | null;
    isActive: boolean | null;
    updatedAt: Date | null;
    updatedBy: string | null;
  };

  export type SiteCustomizationMaxAggregateOutputType = {
    id: string | null;
    siteName: string | null;
    siteDescription: string | null;
    logoUrl: string | null;
    faviconUrl: string | null;
    primaryColor: string | null;
    secondaryColor: string | null;
    accentColor: string | null;
    backgroundColor: string | null;
    textColor: string | null;
    linkColor: string | null;
    primaryFont: string | null;
    secondaryFont: string | null;
    fontSize: string | null;
    headerStyle: string | null;
    footerStyle: string | null;
    borderRadius: string | null;
    showSearch: boolean | null;
    showWishlist: boolean | null;
    showCompare: boolean | null;
    showReviews: boolean | null;
    enableChat: boolean | null;
    enableNewsletter: boolean | null;
    contactEmail: string | null;
    contactPhone: string | null;
    metaTitle: string | null;
    metaDescription: string | null;
    metaKeywords: string | null;
    googleAnalytics: string | null;
    privacyPolicyUrl: string | null;
    termsOfServiceUrl: string | null;
    isActive: boolean | null;
    updatedAt: Date | null;
    updatedBy: string | null;
  };

  export type SiteCustomizationCountAggregateOutputType = {
    id: number;
    siteName: number;
    siteDescription: number;
    logoUrl: number;
    faviconUrl: number;
    primaryColor: number;
    secondaryColor: number;
    accentColor: number;
    backgroundColor: number;
    textColor: number;
    linkColor: number;
    primaryFont: number;
    secondaryFont: number;
    fontSize: number;
    headerStyle: number;
    footerStyle: number;
    borderRadius: number;
    showSearch: number;
    showWishlist: number;
    showCompare: number;
    showReviews: number;
    enableChat: number;
    enableNewsletter: number;
    contactEmail: number;
    contactPhone: number;
    contactAddress: number;
    businessHours: number;
    socialMedia: number;
    metaTitle: number;
    metaDescription: number;
    metaKeywords: number;
    googleAnalytics: number;
    privacyPolicyUrl: number;
    termsOfServiceUrl: number;
    isActive: number;
    updatedAt: number;
    updatedBy: number;
    _all: number;
  };

  export type SiteCustomizationMinAggregateInputType = {
    id?: true;
    siteName?: true;
    siteDescription?: true;
    logoUrl?: true;
    faviconUrl?: true;
    primaryColor?: true;
    secondaryColor?: true;
    accentColor?: true;
    backgroundColor?: true;
    textColor?: true;
    linkColor?: true;
    primaryFont?: true;
    secondaryFont?: true;
    fontSize?: true;
    headerStyle?: true;
    footerStyle?: true;
    borderRadius?: true;
    showSearch?: true;
    showWishlist?: true;
    showCompare?: true;
    showReviews?: true;
    enableChat?: true;
    enableNewsletter?: true;
    contactEmail?: true;
    contactPhone?: true;
    metaTitle?: true;
    metaDescription?: true;
    metaKeywords?: true;
    googleAnalytics?: true;
    privacyPolicyUrl?: true;
    termsOfServiceUrl?: true;
    isActive?: true;
    updatedAt?: true;
    updatedBy?: true;
  };

  export type SiteCustomizationMaxAggregateInputType = {
    id?: true;
    siteName?: true;
    siteDescription?: true;
    logoUrl?: true;
    faviconUrl?: true;
    primaryColor?: true;
    secondaryColor?: true;
    accentColor?: true;
    backgroundColor?: true;
    textColor?: true;
    linkColor?: true;
    primaryFont?: true;
    secondaryFont?: true;
    fontSize?: true;
    headerStyle?: true;
    footerStyle?: true;
    borderRadius?: true;
    showSearch?: true;
    showWishlist?: true;
    showCompare?: true;
    showReviews?: true;
    enableChat?: true;
    enableNewsletter?: true;
    contactEmail?: true;
    contactPhone?: true;
    metaTitle?: true;
    metaDescription?: true;
    metaKeywords?: true;
    googleAnalytics?: true;
    privacyPolicyUrl?: true;
    termsOfServiceUrl?: true;
    isActive?: true;
    updatedAt?: true;
    updatedBy?: true;
  };

  export type SiteCustomizationCountAggregateInputType = {
    id?: true;
    siteName?: true;
    siteDescription?: true;
    logoUrl?: true;
    faviconUrl?: true;
    primaryColor?: true;
    secondaryColor?: true;
    accentColor?: true;
    backgroundColor?: true;
    textColor?: true;
    linkColor?: true;
    primaryFont?: true;
    secondaryFont?: true;
    fontSize?: true;
    headerStyle?: true;
    footerStyle?: true;
    borderRadius?: true;
    showSearch?: true;
    showWishlist?: true;
    showCompare?: true;
    showReviews?: true;
    enableChat?: true;
    enableNewsletter?: true;
    contactEmail?: true;
    contactPhone?: true;
    contactAddress?: true;
    businessHours?: true;
    socialMedia?: true;
    metaTitle?: true;
    metaDescription?: true;
    metaKeywords?: true;
    googleAnalytics?: true;
    privacyPolicyUrl?: true;
    termsOfServiceUrl?: true;
    isActive?: true;
    updatedAt?: true;
    updatedBy?: true;
    _all?: true;
  };

  export type SiteCustomizationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SiteCustomization to aggregate.
     */
    where?: SiteCustomizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SiteCustomizations to fetch.
     */
    orderBy?:
      | SiteCustomizationOrderByWithRelationInput
      | SiteCustomizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SiteCustomizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SiteCustomizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SiteCustomizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SiteCustomizations
     **/
    _count?: true | SiteCustomizationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SiteCustomizationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SiteCustomizationMaxAggregateInputType;
  };

  export type GetSiteCustomizationAggregateType<
    T extends SiteCustomizationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateSiteCustomization]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteCustomization[P]>
      : GetScalarType<T[P], AggregateSiteCustomization[P]>;
  };

  export type SiteCustomizationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SiteCustomizationWhereInput;
    orderBy?:
      | SiteCustomizationOrderByWithAggregationInput
      | SiteCustomizationOrderByWithAggregationInput[];
    by: SiteCustomizationScalarFieldEnum[] | SiteCustomizationScalarFieldEnum;
    having?: SiteCustomizationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SiteCustomizationCountAggregateInputType | true;
    _min?: SiteCustomizationMinAggregateInputType;
    _max?: SiteCustomizationMaxAggregateInputType;
  };

  export type SiteCustomizationGroupByOutputType = {
    id: string;
    siteName: string;
    siteDescription: string | null;
    logoUrl: string | null;
    faviconUrl: string | null;
    primaryColor: string;
    secondaryColor: string;
    accentColor: string;
    backgroundColor: string;
    textColor: string;
    linkColor: string;
    primaryFont: string;
    secondaryFont: string;
    fontSize: string;
    headerStyle: string;
    footerStyle: string;
    borderRadius: string;
    showSearch: boolean;
    showWishlist: boolean;
    showCompare: boolean;
    showReviews: boolean;
    enableChat: boolean;
    enableNewsletter: boolean;
    contactEmail: string | null;
    contactPhone: string | null;
    contactAddress: JsonValue | null;
    businessHours: JsonValue | null;
    socialMedia: JsonValue | null;
    metaTitle: string | null;
    metaDescription: string | null;
    metaKeywords: string | null;
    googleAnalytics: string | null;
    privacyPolicyUrl: string | null;
    termsOfServiceUrl: string | null;
    isActive: boolean;
    updatedAt: Date;
    updatedBy: string | null;
    _count: SiteCustomizationCountAggregateOutputType | null;
    _min: SiteCustomizationMinAggregateOutputType | null;
    _max: SiteCustomizationMaxAggregateOutputType | null;
  };

  type GetSiteCustomizationGroupByPayload<
    T extends SiteCustomizationGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteCustomizationGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof SiteCustomizationGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SiteCustomizationGroupByOutputType[P]>
          : GetScalarType<T[P], SiteCustomizationGroupByOutputType[P]>;
      }
    >
  >;

  export type SiteCustomizationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      siteName?: boolean;
      siteDescription?: boolean;
      logoUrl?: boolean;
      faviconUrl?: boolean;
      primaryColor?: boolean;
      secondaryColor?: boolean;
      accentColor?: boolean;
      backgroundColor?: boolean;
      textColor?: boolean;
      linkColor?: boolean;
      primaryFont?: boolean;
      secondaryFont?: boolean;
      fontSize?: boolean;
      headerStyle?: boolean;
      footerStyle?: boolean;
      borderRadius?: boolean;
      showSearch?: boolean;
      showWishlist?: boolean;
      showCompare?: boolean;
      showReviews?: boolean;
      enableChat?: boolean;
      enableNewsletter?: boolean;
      contactEmail?: boolean;
      contactPhone?: boolean;
      contactAddress?: boolean;
      businessHours?: boolean;
      socialMedia?: boolean;
      metaTitle?: boolean;
      metaDescription?: boolean;
      metaKeywords?: boolean;
      googleAnalytics?: boolean;
      privacyPolicyUrl?: boolean;
      termsOfServiceUrl?: boolean;
      isActive?: boolean;
      updatedAt?: boolean;
      updatedBy?: boolean;
    },
    ExtArgs["result"]["siteCustomization"]
  >;

  export type SiteCustomizationSelectScalar = {
    id?: boolean;
    siteName?: boolean;
    siteDescription?: boolean;
    logoUrl?: boolean;
    faviconUrl?: boolean;
    primaryColor?: boolean;
    secondaryColor?: boolean;
    accentColor?: boolean;
    backgroundColor?: boolean;
    textColor?: boolean;
    linkColor?: boolean;
    primaryFont?: boolean;
    secondaryFont?: boolean;
    fontSize?: boolean;
    headerStyle?: boolean;
    footerStyle?: boolean;
    borderRadius?: boolean;
    showSearch?: boolean;
    showWishlist?: boolean;
    showCompare?: boolean;
    showReviews?: boolean;
    enableChat?: boolean;
    enableNewsletter?: boolean;
    contactEmail?: boolean;
    contactPhone?: boolean;
    contactAddress?: boolean;
    businessHours?: boolean;
    socialMedia?: boolean;
    metaTitle?: boolean;
    metaDescription?: boolean;
    metaKeywords?: boolean;
    googleAnalytics?: boolean;
    privacyPolicyUrl?: boolean;
    termsOfServiceUrl?: boolean;
    isActive?: boolean;
    updatedAt?: boolean;
    updatedBy?: boolean;
  };

  export type $SiteCustomizationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "SiteCustomization";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        siteName: string;
        siteDescription: string | null;
        logoUrl: string | null;
        faviconUrl: string | null;
        primaryColor: string;
        secondaryColor: string;
        accentColor: string;
        backgroundColor: string;
        textColor: string;
        linkColor: string;
        primaryFont: string;
        secondaryFont: string;
        fontSize: string;
        headerStyle: string;
        footerStyle: string;
        borderRadius: string;
        showSearch: boolean;
        showWishlist: boolean;
        showCompare: boolean;
        showReviews: boolean;
        enableChat: boolean;
        enableNewsletter: boolean;
        contactEmail: string | null;
        contactPhone: string | null;
        contactAddress: Prisma.JsonValue | null;
        businessHours: Prisma.JsonValue | null;
        socialMedia: Prisma.JsonValue | null;
        metaTitle: string | null;
        metaDescription: string | null;
        metaKeywords: string | null;
        googleAnalytics: string | null;
        privacyPolicyUrl: string | null;
        termsOfServiceUrl: string | null;
        isActive: boolean;
        updatedAt: Date;
        updatedBy: string | null;
      },
      ExtArgs["result"]["siteCustomization"]
    >;
    composites: {};
  };

  type SiteCustomizationGetPayload<
    S extends boolean | null | undefined | SiteCustomizationDefaultArgs,
  > = $Result.GetResult<Prisma.$SiteCustomizationPayload, S>;

  type SiteCustomizationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SiteCustomizationFindManyArgs, "select" | "include" | "distinct"> & {
    select?: SiteCustomizationCountAggregateInputType | true;
  };

  export interface SiteCustomizationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["SiteCustomization"];
      meta: { name: "SiteCustomization" };
    };
    /**
     * Find zero or one SiteCustomization that matches the filter.
     * @param {SiteCustomizationFindUniqueArgs} args - Arguments to find a SiteCustomization
     * @example
     * // Get one SiteCustomization
     * const siteCustomization = await prisma.siteCustomization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteCustomizationFindUniqueArgs>(
      args: SelectSubset<T, SiteCustomizationFindUniqueArgs<ExtArgs>>,
    ): Prisma__SiteCustomizationClient<
      $Result.GetResult<
        Prisma.$SiteCustomizationPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one SiteCustomization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteCustomizationFindUniqueOrThrowArgs} args - Arguments to find a SiteCustomization
     * @example
     * // Get one SiteCustomization
     * const siteCustomization = await prisma.siteCustomization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteCustomizationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SiteCustomizationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SiteCustomizationClient<
      $Result.GetResult<
        Prisma.$SiteCustomizationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first SiteCustomization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCustomizationFindFirstArgs} args - Arguments to find a SiteCustomization
     * @example
     * // Get one SiteCustomization
     * const siteCustomization = await prisma.siteCustomization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteCustomizationFindFirstArgs>(
      args?: SelectSubset<T, SiteCustomizationFindFirstArgs<ExtArgs>>,
    ): Prisma__SiteCustomizationClient<
      $Result.GetResult<
        Prisma.$SiteCustomizationPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first SiteCustomization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCustomizationFindFirstOrThrowArgs} args - Arguments to find a SiteCustomization
     * @example
     * // Get one SiteCustomization
     * const siteCustomization = await prisma.siteCustomization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteCustomizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SiteCustomizationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SiteCustomizationClient<
      $Result.GetResult<
        Prisma.$SiteCustomizationPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more SiteCustomizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCustomizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteCustomizations
     * const siteCustomizations = await prisma.siteCustomization.findMany()
     *
     * // Get first 10 SiteCustomizations
     * const siteCustomizations = await prisma.siteCustomization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const siteCustomizationWithIdOnly = await prisma.siteCustomization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SiteCustomizationFindManyArgs>(
      args?: SelectSubset<T, SiteCustomizationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SiteCustomizationPayload<ExtArgs>,
        T,
        "findMany"
      >
    >;

    /**
     * Create a SiteCustomization.
     * @param {SiteCustomizationCreateArgs} args - Arguments to create a SiteCustomization.
     * @example
     * // Create one SiteCustomization
     * const SiteCustomization = await prisma.siteCustomization.create({
     *   data: {
     *     // ... data to create a SiteCustomization
     *   }
     * })
     *
     */
    create<T extends SiteCustomizationCreateArgs>(
      args: SelectSubset<T, SiteCustomizationCreateArgs<ExtArgs>>,
    ): Prisma__SiteCustomizationClient<
      $Result.GetResult<Prisma.$SiteCustomizationPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many SiteCustomizations.
     * @param {SiteCustomizationCreateManyArgs} args - Arguments to create many SiteCustomizations.
     * @example
     * // Create many SiteCustomizations
     * const siteCustomization = await prisma.siteCustomization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SiteCustomizationCreateManyArgs>(
      args?: SelectSubset<T, SiteCustomizationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a SiteCustomization.
     * @param {SiteCustomizationDeleteArgs} args - Arguments to delete one SiteCustomization.
     * @example
     * // Delete one SiteCustomization
     * const SiteCustomization = await prisma.siteCustomization.delete({
     *   where: {
     *     // ... filter to delete one SiteCustomization
     *   }
     * })
     *
     */
    delete<T extends SiteCustomizationDeleteArgs>(
      args: SelectSubset<T, SiteCustomizationDeleteArgs<ExtArgs>>,
    ): Prisma__SiteCustomizationClient<
      $Result.GetResult<Prisma.$SiteCustomizationPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one SiteCustomization.
     * @param {SiteCustomizationUpdateArgs} args - Arguments to update one SiteCustomization.
     * @example
     * // Update one SiteCustomization
     * const siteCustomization = await prisma.siteCustomization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SiteCustomizationUpdateArgs>(
      args: SelectSubset<T, SiteCustomizationUpdateArgs<ExtArgs>>,
    ): Prisma__SiteCustomizationClient<
      $Result.GetResult<Prisma.$SiteCustomizationPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more SiteCustomizations.
     * @param {SiteCustomizationDeleteManyArgs} args - Arguments to filter SiteCustomizations to delete.
     * @example
     * // Delete a few SiteCustomizations
     * const { count } = await prisma.siteCustomization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SiteCustomizationDeleteManyArgs>(
      args?: SelectSubset<T, SiteCustomizationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SiteCustomizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCustomizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteCustomizations
     * const siteCustomization = await prisma.siteCustomization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SiteCustomizationUpdateManyArgs>(
      args: SelectSubset<T, SiteCustomizationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one SiteCustomization.
     * @param {SiteCustomizationUpsertArgs} args - Arguments to update or create a SiteCustomization.
     * @example
     * // Update or create a SiteCustomization
     * const siteCustomization = await prisma.siteCustomization.upsert({
     *   create: {
     *     // ... data to create a SiteCustomization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteCustomization we want to update
     *   }
     * })
     */
    upsert<T extends SiteCustomizationUpsertArgs>(
      args: SelectSubset<T, SiteCustomizationUpsertArgs<ExtArgs>>,
    ): Prisma__SiteCustomizationClient<
      $Result.GetResult<Prisma.$SiteCustomizationPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more SiteCustomizations that matches the filter.
     * @param {SiteCustomizationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const siteCustomization = await prisma.siteCustomization.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(
      args?: SiteCustomizationFindRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a SiteCustomization.
     * @param {SiteCustomizationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const siteCustomization = await prisma.siteCustomization.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: SiteCustomizationAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of SiteCustomizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCustomizationCountArgs} args - Arguments to filter SiteCustomizations to count.
     * @example
     * // Count the number of SiteCustomizations
     * const count = await prisma.siteCustomization.count({
     *   where: {
     *     // ... the filter for the SiteCustomizations we want to count
     *   }
     * })
     **/
    count<T extends SiteCustomizationCountArgs>(
      args?: Subset<T, SiteCustomizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              SiteCustomizationCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SiteCustomization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCustomizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SiteCustomizationAggregateArgs>(
      args: Subset<T, SiteCustomizationAggregateArgs>,
    ): Prisma.PrismaPromise<GetSiteCustomizationAggregateType<T>>;

    /**
     * Group by SiteCustomization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCustomizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SiteCustomizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteCustomizationGroupByArgs["orderBy"] }
        : { orderBy?: SiteCustomizationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SiteCustomizationGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetSiteCustomizationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SiteCustomization model
     */
    readonly fields: SiteCustomizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteCustomization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteCustomizationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SiteCustomization model
   */
  interface SiteCustomizationFieldRefs {
    readonly id: FieldRef<"SiteCustomization", "String">;
    readonly siteName: FieldRef<"SiteCustomization", "String">;
    readonly siteDescription: FieldRef<"SiteCustomization", "String">;
    readonly logoUrl: FieldRef<"SiteCustomization", "String">;
    readonly faviconUrl: FieldRef<"SiteCustomization", "String">;
    readonly primaryColor: FieldRef<"SiteCustomization", "String">;
    readonly secondaryColor: FieldRef<"SiteCustomization", "String">;
    readonly accentColor: FieldRef<"SiteCustomization", "String">;
    readonly backgroundColor: FieldRef<"SiteCustomization", "String">;
    readonly textColor: FieldRef<"SiteCustomization", "String">;
    readonly linkColor: FieldRef<"SiteCustomization", "String">;
    readonly primaryFont: FieldRef<"SiteCustomization", "String">;
    readonly secondaryFont: FieldRef<"SiteCustomization", "String">;
    readonly fontSize: FieldRef<"SiteCustomization", "String">;
    readonly headerStyle: FieldRef<"SiteCustomization", "String">;
    readonly footerStyle: FieldRef<"SiteCustomization", "String">;
    readonly borderRadius: FieldRef<"SiteCustomization", "String">;
    readonly showSearch: FieldRef<"SiteCustomization", "Boolean">;
    readonly showWishlist: FieldRef<"SiteCustomization", "Boolean">;
    readonly showCompare: FieldRef<"SiteCustomization", "Boolean">;
    readonly showReviews: FieldRef<"SiteCustomization", "Boolean">;
    readonly enableChat: FieldRef<"SiteCustomization", "Boolean">;
    readonly enableNewsletter: FieldRef<"SiteCustomization", "Boolean">;
    readonly contactEmail: FieldRef<"SiteCustomization", "String">;
    readonly contactPhone: FieldRef<"SiteCustomization", "String">;
    readonly contactAddress: FieldRef<"SiteCustomization", "Json">;
    readonly businessHours: FieldRef<"SiteCustomization", "Json">;
    readonly socialMedia: FieldRef<"SiteCustomization", "Json">;
    readonly metaTitle: FieldRef<"SiteCustomization", "String">;
    readonly metaDescription: FieldRef<"SiteCustomization", "String">;
    readonly metaKeywords: FieldRef<"SiteCustomization", "String">;
    readonly googleAnalytics: FieldRef<"SiteCustomization", "String">;
    readonly privacyPolicyUrl: FieldRef<"SiteCustomization", "String">;
    readonly termsOfServiceUrl: FieldRef<"SiteCustomization", "String">;
    readonly isActive: FieldRef<"SiteCustomization", "Boolean">;
    readonly updatedAt: FieldRef<"SiteCustomization", "DateTime">;
    readonly updatedBy: FieldRef<"SiteCustomization", "String">;
  }

  // Custom InputTypes
  /**
   * SiteCustomization findUnique
   */
  export type SiteCustomizationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * Filter, which SiteCustomization to fetch.
     */
    where: SiteCustomizationWhereUniqueInput;
  };

  /**
   * SiteCustomization findUniqueOrThrow
   */
  export type SiteCustomizationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * Filter, which SiteCustomization to fetch.
     */
    where: SiteCustomizationWhereUniqueInput;
  };

  /**
   * SiteCustomization findFirst
   */
  export type SiteCustomizationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * Filter, which SiteCustomization to fetch.
     */
    where?: SiteCustomizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SiteCustomizations to fetch.
     */
    orderBy?:
      | SiteCustomizationOrderByWithRelationInput
      | SiteCustomizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SiteCustomizations.
     */
    cursor?: SiteCustomizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SiteCustomizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SiteCustomizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SiteCustomizations.
     */
    distinct?:
      | SiteCustomizationScalarFieldEnum
      | SiteCustomizationScalarFieldEnum[];
  };

  /**
   * SiteCustomization findFirstOrThrow
   */
  export type SiteCustomizationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * Filter, which SiteCustomization to fetch.
     */
    where?: SiteCustomizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SiteCustomizations to fetch.
     */
    orderBy?:
      | SiteCustomizationOrderByWithRelationInput
      | SiteCustomizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SiteCustomizations.
     */
    cursor?: SiteCustomizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SiteCustomizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SiteCustomizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SiteCustomizations.
     */
    distinct?:
      | SiteCustomizationScalarFieldEnum
      | SiteCustomizationScalarFieldEnum[];
  };

  /**
   * SiteCustomization findMany
   */
  export type SiteCustomizationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * Filter, which SiteCustomizations to fetch.
     */
    where?: SiteCustomizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SiteCustomizations to fetch.
     */
    orderBy?:
      | SiteCustomizationOrderByWithRelationInput
      | SiteCustomizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SiteCustomizations.
     */
    cursor?: SiteCustomizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SiteCustomizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SiteCustomizations.
     */
    skip?: number;
    distinct?:
      | SiteCustomizationScalarFieldEnum
      | SiteCustomizationScalarFieldEnum[];
  };

  /**
   * SiteCustomization create
   */
  export type SiteCustomizationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * The data needed to create a SiteCustomization.
     */
    data: XOR<
      SiteCustomizationCreateInput,
      SiteCustomizationUncheckedCreateInput
    >;
  };

  /**
   * SiteCustomization createMany
   */
  export type SiteCustomizationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SiteCustomizations.
     */
    data: SiteCustomizationCreateManyInput | SiteCustomizationCreateManyInput[];
  };

  /**
   * SiteCustomization update
   */
  export type SiteCustomizationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * The data needed to update a SiteCustomization.
     */
    data: XOR<
      SiteCustomizationUpdateInput,
      SiteCustomizationUncheckedUpdateInput
    >;
    /**
     * Choose, which SiteCustomization to update.
     */
    where: SiteCustomizationWhereUniqueInput;
  };

  /**
   * SiteCustomization updateMany
   */
  export type SiteCustomizationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SiteCustomizations.
     */
    data: XOR<
      SiteCustomizationUpdateManyMutationInput,
      SiteCustomizationUncheckedUpdateManyInput
    >;
    /**
     * Filter which SiteCustomizations to update
     */
    where?: SiteCustomizationWhereInput;
  };

  /**
   * SiteCustomization upsert
   */
  export type SiteCustomizationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * The filter to search for the SiteCustomization to update in case it exists.
     */
    where: SiteCustomizationWhereUniqueInput;
    /**
     * In case the SiteCustomization found by the `where` argument doesn't exist, create a new SiteCustomization with this data.
     */
    create: XOR<
      SiteCustomizationCreateInput,
      SiteCustomizationUncheckedCreateInput
    >;
    /**
     * In case the SiteCustomization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      SiteCustomizationUpdateInput,
      SiteCustomizationUncheckedUpdateInput
    >;
  };

  /**
   * SiteCustomization delete
   */
  export type SiteCustomizationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
    /**
     * Filter which SiteCustomization to delete.
     */
    where: SiteCustomizationWhereUniqueInput;
  };

  /**
   * SiteCustomization deleteMany
   */
  export type SiteCustomizationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SiteCustomizations to delete
     */
    where?: SiteCustomizationWhereInput;
  };

  /**
   * SiteCustomization findRaw
   */
  export type SiteCustomizationFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * SiteCustomization aggregateRaw
   */
  export type SiteCustomizationAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * SiteCustomization without action
   */
  export type SiteCustomizationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SiteCustomization
     */
    select?: SiteCustomizationSelect<ExtArgs> | null;
  };

  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null;
    _min: ActivityLogMinAggregateOutputType | null;
    _max: ActivityLogMaxAggregateOutputType | null;
  };

  export type ActivityLogMinAggregateOutputType = {
    id: string | null;
    staffUserId: string | null;
    actionType: string | null;
    description: string | null;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    success: boolean | null;
    errorMessage: string | null;
    timestamp: Date | null;
  };

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null;
    staffUserId: string | null;
    actionType: string | null;
    description: string | null;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    success: boolean | null;
    errorMessage: string | null;
    timestamp: Date | null;
  };

  export type ActivityLogCountAggregateOutputType = {
    id: number;
    staffUserId: number;
    actionType: number;
    description: number;
    entityType: number;
    entityId: number;
    ipAddress: number;
    userAgent: number;
    metadata: number;
    success: number;
    errorMessage: number;
    timestamp: number;
    _all: number;
  };

  export type ActivityLogMinAggregateInputType = {
    id?: true;
    staffUserId?: true;
    actionType?: true;
    description?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    success?: true;
    errorMessage?: true;
    timestamp?: true;
  };

  export type ActivityLogMaxAggregateInputType = {
    id?: true;
    staffUserId?: true;
    actionType?: true;
    description?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    success?: true;
    errorMessage?: true;
    timestamp?: true;
  };

  export type ActivityLogCountAggregateInputType = {
    id?: true;
    staffUserId?: true;
    actionType?: true;
    description?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    metadata?: true;
    success?: true;
    errorMessage?: true;
    timestamp?: true;
    _all?: true;
  };

  export type ActivityLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?:
      | ActivityLogOrderByWithRelationInput
      | ActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ActivityLogs
     **/
    _count?: true | ActivityLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ActivityLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ActivityLogMaxAggregateInputType;
  };

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> =
    {
      [P in keyof T & keyof AggregateActivityLog]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateActivityLog[P]>
        : GetScalarType<T[P], AggregateActivityLog[P]>;
    };

  export type ActivityLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ActivityLogWhereInput;
    orderBy?:
      | ActivityLogOrderByWithAggregationInput
      | ActivityLogOrderByWithAggregationInput[];
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum;
    having?: ActivityLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ActivityLogCountAggregateInputType | true;
    _min?: ActivityLogMinAggregateInputType;
    _max?: ActivityLogMaxAggregateInputType;
  };

  export type ActivityLogGroupByOutputType = {
    id: string;
    staffUserId: string;
    actionType: string;
    description: string;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    metadata: JsonValue | null;
    success: boolean;
    errorMessage: string | null;
    timestamp: Date;
    _count: ActivityLogCountAggregateOutputType | null;
    _min: ActivityLogMinAggregateOutputType | null;
    _max: ActivityLogMaxAggregateOutputType | null;
  };

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ActivityLogGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ActivityLogGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>;
        }
      >
    >;

  export type ActivityLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      staffUserId?: boolean;
      actionType?: boolean;
      description?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      metadata?: boolean;
      success?: boolean;
      errorMessage?: boolean;
      timestamp?: boolean;
      staffUser?: boolean | StaffUserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["activityLog"]
  >;

  export type ActivityLogSelectScalar = {
    id?: boolean;
    staffUserId?: boolean;
    actionType?: boolean;
    description?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    metadata?: boolean;
    success?: boolean;
    errorMessage?: boolean;
    timestamp?: boolean;
  };

  export type ActivityLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    staffUser?: boolean | StaffUserDefaultArgs<ExtArgs>;
  };

  export type $ActivityLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ActivityLog";
    objects: {
      staffUser: Prisma.$StaffUserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        staffUserId: string;
        actionType: string;
        description: string;
        entityType: string | null;
        entityId: string | null;
        ipAddress: string | null;
        userAgent: string | null;
        metadata: Prisma.JsonValue | null;
        success: boolean;
        errorMessage: string | null;
        timestamp: Date;
      },
      ExtArgs["result"]["activityLog"]
    >;
    composites: {};
  };

  type ActivityLogGetPayload<
    S extends boolean | null | undefined | ActivityLogDefaultArgs,
  > = $Result.GetResult<Prisma.$ActivityLogPayload, S>;

  type ActivityLogCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ActivityLogFindManyArgs, "select" | "include" | "distinct"> & {
    select?: ActivityLogCountAggregateInputType | true;
  };

  export interface ActivityLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ActivityLog"];
      meta: { name: "ActivityLog" };
    };
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(
      args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>,
    ): Prisma__ActivityLogClient<
      $Result.GetResult<
        Prisma.$ActivityLogPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ActivityLogClient<
      $Result.GetResult<
        Prisma.$ActivityLogPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(
      args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>,
    ): Prisma__ActivityLogClient<
      $Result.GetResult<
        Prisma.$ActivityLogPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ActivityLogClient<
      $Result.GetResult<
        Prisma.$ActivityLogPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     *
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ActivityLogFindManyArgs>(
      args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     *
     */
    create<T extends ActivityLogCreateArgs>(
      args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>,
    ): Prisma__ActivityLogClient<
      $Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ActivityLogCreateManyArgs>(
      args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     *
     */
    delete<T extends ActivityLogDeleteArgs>(
      args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>,
    ): Prisma__ActivityLogClient<
      $Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ActivityLogUpdateArgs>(
      args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>,
    ): Prisma__ActivityLogClient<
      $Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(
      args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(
      args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(
      args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>,
    ): Prisma__ActivityLogClient<
      $Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * @param {ActivityLogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const activityLog = await prisma.activityLog.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ActivityLogFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a ActivityLog.
     * @param {ActivityLogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const activityLog = await prisma.activityLog.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ActivityLogAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
     **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ActivityLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ActivityLogAggregateArgs>(
      args: Subset<T, ActivityLogAggregateArgs>,
    ): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>;

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs["orderBy"] }
        : { orderBy?: ActivityLogGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetActivityLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ActivityLog model
     */
    readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    staffUser<T extends StaffUserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>,
    ): Prisma__StaffUserClient<
      | $Result.GetResult<
          Prisma.$StaffUserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", "String">;
    readonly staffUserId: FieldRef<"ActivityLog", "String">;
    readonly actionType: FieldRef<"ActivityLog", "String">;
    readonly description: FieldRef<"ActivityLog", "String">;
    readonly entityType: FieldRef<"ActivityLog", "String">;
    readonly entityId: FieldRef<"ActivityLog", "String">;
    readonly ipAddress: FieldRef<"ActivityLog", "String">;
    readonly userAgent: FieldRef<"ActivityLog", "String">;
    readonly metadata: FieldRef<"ActivityLog", "Json">;
    readonly success: FieldRef<"ActivityLog", "Boolean">;
    readonly errorMessage: FieldRef<"ActivityLog", "String">;
    readonly timestamp: FieldRef<"ActivityLog", "DateTime">;
  }

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput;
  };

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput;
  };

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?:
      | ActivityLogOrderByWithRelationInput
      | ActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[];
  };

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?:
      | ActivityLogOrderByWithRelationInput
      | ActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[];
  };

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?:
      | ActivityLogOrderByWithRelationInput
      | ActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ActivityLogs.
     */
    skip?: number;
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[];
  };

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>;
  };

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[];
  };

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>;
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput;
  };

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<
      ActivityLogUpdateManyMutationInput,
      ActivityLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput;
  };

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput;
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>;
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>;
  };

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput;
  };

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput;
  };

  /**
   * ActivityLog findRaw
   */
  export type ActivityLogFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ActivityLog aggregateRaw
   */
  export type ActivityLogAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null;
  };

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null;
    _avg: CustomerAvgAggregateOutputType | null;
    _sum: CustomerSumAggregateOutputType | null;
    _min: CustomerMinAggregateOutputType | null;
    _max: CustomerMaxAggregateOutputType | null;
  };

  export type CustomerAvgAggregateOutputType = {
    discountRate: number | null;
    totalOrders: number | null;
    totalSpent: number | null;
    lifetimeValue: number | null;
    averageOrderValue: number | null;
  };

  export type CustomerSumAggregateOutputType = {
    discountRate: number | null;
    totalOrders: number | null;
    totalSpent: number | null;
    lifetimeValue: number | null;
    averageOrderValue: number | null;
  };

  export type CustomerMinAggregateOutputType = {
    id: string | null;
    firstName: string | null;
    lastName: string | null;
    email: string | null;
    phone: string | null;
    passwordHash: string | null;
    emailVerified: boolean | null;
    isActive: boolean | null;
    professionalTier: $Enums.ProfessionalTier | null;
    discountRate: number | null;
    totalOrders: number | null;
    totalSpent: number | null;
    lifetimeValue: number | null;
    averageOrderValue: number | null;
    preferredPaymentMethod: string | null;
    timezone: string | null;
    customerType: $Enums.CustomerType | null;
    riskLevel: $Enums.RiskLevel | null;
    notes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastLogin: Date | null;
  };

  export type CustomerMaxAggregateOutputType = {
    id: string | null;
    firstName: string | null;
    lastName: string | null;
    email: string | null;
    phone: string | null;
    passwordHash: string | null;
    emailVerified: boolean | null;
    isActive: boolean | null;
    professionalTier: $Enums.ProfessionalTier | null;
    discountRate: number | null;
    totalOrders: number | null;
    totalSpent: number | null;
    lifetimeValue: number | null;
    averageOrderValue: number | null;
    preferredPaymentMethod: string | null;
    timezone: string | null;
    customerType: $Enums.CustomerType | null;
    riskLevel: $Enums.RiskLevel | null;
    notes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastLogin: Date | null;
  };

  export type CustomerCountAggregateOutputType = {
    id: number;
    firstName: number;
    lastName: number;
    email: number;
    phone: number;
    passwordHash: number;
    emailVerified: number;
    isActive: number;
    professionalTier: number;
    discountRate: number;
    totalOrders: number;
    totalSpent: number;
    lifetimeValue: number;
    averageOrderValue: number;
    preferredPaymentMethod: number;
    communicationPrefs: number;
    timezone: number;
    customerType: number;
    riskLevel: number;
    notes: number;
    createdAt: number;
    updatedAt: number;
    lastLogin: number;
    _all: number;
  };

  export type CustomerAvgAggregateInputType = {
    discountRate?: true;
    totalOrders?: true;
    totalSpent?: true;
    lifetimeValue?: true;
    averageOrderValue?: true;
  };

  export type CustomerSumAggregateInputType = {
    discountRate?: true;
    totalOrders?: true;
    totalSpent?: true;
    lifetimeValue?: true;
    averageOrderValue?: true;
  };

  export type CustomerMinAggregateInputType = {
    id?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    emailVerified?: true;
    isActive?: true;
    professionalTier?: true;
    discountRate?: true;
    totalOrders?: true;
    totalSpent?: true;
    lifetimeValue?: true;
    averageOrderValue?: true;
    preferredPaymentMethod?: true;
    timezone?: true;
    customerType?: true;
    riskLevel?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
  };

  export type CustomerMaxAggregateInputType = {
    id?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    emailVerified?: true;
    isActive?: true;
    professionalTier?: true;
    discountRate?: true;
    totalOrders?: true;
    totalSpent?: true;
    lifetimeValue?: true;
    averageOrderValue?: true;
    preferredPaymentMethod?: true;
    timezone?: true;
    customerType?: true;
    riskLevel?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
  };

  export type CustomerCountAggregateInputType = {
    id?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    emailVerified?: true;
    isActive?: true;
    professionalTier?: true;
    discountRate?: true;
    totalOrders?: true;
    totalSpent?: true;
    lifetimeValue?: true;
    averageOrderValue?: true;
    preferredPaymentMethod?: true;
    communicationPrefs?: true;
    timezone?: true;
    customerType?: true;
    riskLevel?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLogin?: true;
    _all?: true;
  };

  export type CustomerAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Customers to fetch.
     */
    orderBy?:
      | CustomerOrderByWithRelationInput
      | CustomerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Customers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Customers
     **/
    _count?: true | CustomerCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CustomerAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CustomerSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CustomerMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CustomerMaxAggregateInputType;
  };

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
    [P in keyof T & keyof AggregateCustomer]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>;
  };

  export type CustomerGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CustomerWhereInput;
    orderBy?:
      | CustomerOrderByWithAggregationInput
      | CustomerOrderByWithAggregationInput[];
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum;
    having?: CustomerScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CustomerCountAggregateInputType | true;
    _avg?: CustomerAvgAggregateInputType;
    _sum?: CustomerSumAggregateInputType;
    _min?: CustomerMinAggregateInputType;
    _max?: CustomerMaxAggregateInputType;
  };

  export type CustomerGroupByOutputType = {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string | null;
    passwordHash: string;
    emailVerified: boolean;
    isActive: boolean;
    professionalTier: $Enums.ProfessionalTier;
    discountRate: number;
    totalOrders: number;
    totalSpent: number;
    lifetimeValue: number;
    averageOrderValue: number;
    preferredPaymentMethod: string | null;
    communicationPrefs: JsonValue | null;
    timezone: string;
    customerType: $Enums.CustomerType;
    riskLevel: $Enums.RiskLevel;
    notes: string | null;
    createdAt: Date;
    updatedAt: Date;
    lastLogin: Date | null;
    _count: CustomerCountAggregateOutputType | null;
    _avg: CustomerAvgAggregateOutputType | null;
    _sum: CustomerSumAggregateOutputType | null;
    _min: CustomerMinAggregateOutputType | null;
    _max: CustomerMaxAggregateOutputType | null;
  };

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CustomerGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof CustomerGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>;
        }
      >
    >;

  export type CustomerSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      email?: boolean;
      phone?: boolean;
      passwordHash?: boolean;
      emailVerified?: boolean;
      isActive?: boolean;
      professionalTier?: boolean;
      discountRate?: boolean;
      businessInfo?: boolean | BusinessInfoDefaultArgs<ExtArgs>;
      totalOrders?: boolean;
      totalSpent?: boolean;
      lifetimeValue?: boolean;
      averageOrderValue?: boolean;
      preferredPaymentMethod?: boolean;
      communicationPrefs?: boolean;
      timezone?: boolean;
      customerType?: boolean;
      riskLevel?: boolean;
      notes?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      lastLogin?: boolean;
      addresses?: boolean | Customer$addressesArgs<ExtArgs>;
      orders?: boolean | Customer$ordersArgs<ExtArgs>;
      reviews?: boolean | Customer$reviewsArgs<ExtArgs>;
      _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["customer"]
  >;

  export type CustomerSelectScalar = {
    id?: boolean;
    firstName?: boolean;
    lastName?: boolean;
    email?: boolean;
    phone?: boolean;
    passwordHash?: boolean;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: boolean;
    discountRate?: boolean;
    totalOrders?: boolean;
    totalSpent?: boolean;
    lifetimeValue?: boolean;
    averageOrderValue?: boolean;
    preferredPaymentMethod?: boolean;
    communicationPrefs?: boolean;
    timezone?: boolean;
    customerType?: boolean;
    riskLevel?: boolean;
    notes?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    lastLogin?: boolean;
  };

  export type CustomerInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    addresses?: boolean | Customer$addressesArgs<ExtArgs>;
    orders?: boolean | Customer$ordersArgs<ExtArgs>;
    reviews?: boolean | Customer$reviewsArgs<ExtArgs>;
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CustomerPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Customer";
    objects: {
      addresses: Prisma.$AddressPayload<ExtArgs>[];
      orders: Prisma.$OrderPayload<ExtArgs>[];
      reviews: Prisma.$ProductReviewPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        firstName: string;
        lastName: string;
        email: string;
        phone: string | null;
        passwordHash: string;
        emailVerified: boolean;
        isActive: boolean;
        professionalTier: $Enums.ProfessionalTier;
        discountRate: number;
        totalOrders: number;
        totalSpent: number;
        lifetimeValue: number;
        averageOrderValue: number;
        preferredPaymentMethod: string | null;
        communicationPrefs: Prisma.JsonValue | null;
        timezone: string;
        customerType: $Enums.CustomerType;
        riskLevel: $Enums.RiskLevel;
        notes: string | null;
        createdAt: Date;
        updatedAt: Date;
        lastLogin: Date | null;
      },
      ExtArgs["result"]["customer"]
    >;
    composites: {
      businessInfo: Prisma.$BusinessInfoPayload | null;
    };
  };

  type CustomerGetPayload<
    S extends boolean | null | undefined | CustomerDefaultArgs,
  > = $Result.GetResult<Prisma.$CustomerPayload, S>;

  type CustomerCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CustomerFindManyArgs, "select" | "include" | "distinct"> & {
    select?: CustomerCountAggregateInputType | true;
  };

  export interface CustomerDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Customer"];
      meta: { name: "Customer" };
    };
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(
      args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      $Result.GetResult<
        Prisma.$CustomerPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      $Result.GetResult<
        Prisma.$CustomerPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(
      args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      $Result.GetResult<
        Prisma.$CustomerPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      $Result.GetResult<
        Prisma.$CustomerPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     *
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     *
     */
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      $Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     *
     */
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      $Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      $Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      $Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Customers that matches the filter.
     * @param {CustomerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customer = await prisma.customer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomerFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Customer.
     * @param {CustomerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customer = await prisma.customer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: CustomerAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
     **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CustomerCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CustomerAggregateArgs>(
      args: Subset<T, CustomerAggregateArgs>,
    ): Prisma.PrismaPromise<GetCustomerAggregateType<T>>;

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs["orderBy"] }
        : { orderBy?: CustomerGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetCustomerGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Customer model
     */
    readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    addresses<T extends Customer$addressesArgs<ExtArgs> = {}>(
      args?: Subset<T, Customer$addressesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany"> | Null
    >;
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(
      args?: Subset<T, Customer$ordersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null
    >;
    reviews<T extends Customer$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, Customer$reviewsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany">
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", "String">;
    readonly firstName: FieldRef<"Customer", "String">;
    readonly lastName: FieldRef<"Customer", "String">;
    readonly email: FieldRef<"Customer", "String">;
    readonly phone: FieldRef<"Customer", "String">;
    readonly passwordHash: FieldRef<"Customer", "String">;
    readonly emailVerified: FieldRef<"Customer", "Boolean">;
    readonly isActive: FieldRef<"Customer", "Boolean">;
    readonly professionalTier: FieldRef<"Customer", "ProfessionalTier">;
    readonly discountRate: FieldRef<"Customer", "Float">;
    readonly totalOrders: FieldRef<"Customer", "Int">;
    readonly totalSpent: FieldRef<"Customer", "Float">;
    readonly lifetimeValue: FieldRef<"Customer", "Float">;
    readonly averageOrderValue: FieldRef<"Customer", "Float">;
    readonly preferredPaymentMethod: FieldRef<"Customer", "String">;
    readonly communicationPrefs: FieldRef<"Customer", "Json">;
    readonly timezone: FieldRef<"Customer", "String">;
    readonly customerType: FieldRef<"Customer", "CustomerType">;
    readonly riskLevel: FieldRef<"Customer", "RiskLevel">;
    readonly notes: FieldRef<"Customer", "String">;
    readonly createdAt: FieldRef<"Customer", "DateTime">;
    readonly updatedAt: FieldRef<"Customer", "DateTime">;
    readonly lastLogin: FieldRef<"Customer", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput;
  };

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput;
  };

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Customers to fetch.
     */
    orderBy?:
      | CustomerOrderByWithRelationInput
      | CustomerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Customers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[];
  };

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Customers to fetch.
     */
    orderBy?:
      | CustomerOrderByWithRelationInput
      | CustomerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Customers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[];
  };

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Customers to fetch.
     */
    orderBy?:
      | CustomerOrderByWithRelationInput
      | CustomerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Customers.
     */
    skip?: number;
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[];
  };

  /**
   * Customer create
   */
  export type CustomerCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>;
  };

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[];
  };

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>;
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput;
  };

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Customers.
     */
    data: XOR<
      CustomerUpdateManyMutationInput,
      CustomerUncheckedUpdateManyInput
    >;
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput;
  };

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput;
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>;
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>;
  };

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput;
  };

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput;
  };

  /**
   * Customer findRaw
   */
  export type CustomerFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Customer aggregateRaw
   */
  export type CustomerAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Customer.addresses
   */
  export type Customer$addressesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    where?: AddressWhereInput;
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    cursor?: AddressWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Customer.reviews
   */
  export type Customer$reviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    where?: ProductReviewWhereInput;
    orderBy?:
      | ProductReviewOrderByWithRelationInput
      | ProductReviewOrderByWithRelationInput[];
    cursor?: ProductReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[];
  };

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null;
  };

  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null;
    _min: AddressMinAggregateOutputType | null;
    _max: AddressMaxAggregateOutputType | null;
  };

  export type AddressMinAggregateOutputType = {
    id: string | null;
    customerId: string | null;
    firstName: string | null;
    lastName: string | null;
    company: string | null;
    address1: string | null;
    address2: string | null;
    city: string | null;
    state: string | null;
    postalCode: string | null;
    country: string | null;
    phone: string | null;
    type: $Enums.AddressType | null;
    isDefault: boolean | null;
    isValidated: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AddressMaxAggregateOutputType = {
    id: string | null;
    customerId: string | null;
    firstName: string | null;
    lastName: string | null;
    company: string | null;
    address1: string | null;
    address2: string | null;
    city: string | null;
    state: string | null;
    postalCode: string | null;
    country: string | null;
    phone: string | null;
    type: $Enums.AddressType | null;
    isDefault: boolean | null;
    isValidated: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AddressCountAggregateOutputType = {
    id: number;
    customerId: number;
    firstName: number;
    lastName: number;
    company: number;
    address1: number;
    address2: number;
    city: number;
    state: number;
    postalCode: number;
    country: number;
    phone: number;
    type: number;
    isDefault: number;
    isValidated: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AddressMinAggregateInputType = {
    id?: true;
    customerId?: true;
    firstName?: true;
    lastName?: true;
    company?: true;
    address1?: true;
    address2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    type?: true;
    isDefault?: true;
    isValidated?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AddressMaxAggregateInputType = {
    id?: true;
    customerId?: true;
    firstName?: true;
    lastName?: true;
    company?: true;
    address1?: true;
    address2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    type?: true;
    isDefault?: true;
    isValidated?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AddressCountAggregateInputType = {
    id?: true;
    customerId?: true;
    firstName?: true;
    lastName?: true;
    company?: true;
    address1?: true;
    address2?: true;
    city?: true;
    state?: true;
    postalCode?: true;
    country?: true;
    phone?: true;
    type?: true;
    isDefault?: true;
    isValidated?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AddressAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Addresses
     **/
    _count?: true | AddressCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AddressMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AddressMaxAggregateInputType;
  };

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
    [P in keyof T & keyof AggregateAddress]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>;
  };

  export type AddressGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AddressWhereInput;
    orderBy?:
      | AddressOrderByWithAggregationInput
      | AddressOrderByWithAggregationInput[];
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum;
    having?: AddressScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AddressCountAggregateInputType | true;
    _min?: AddressMinAggregateInputType;
    _max?: AddressMaxAggregateInputType;
  };

  export type AddressGroupByOutputType = {
    id: string;
    customerId: string;
    firstName: string | null;
    lastName: string | null;
    company: string | null;
    address1: string;
    address2: string | null;
    city: string;
    state: string;
    postalCode: string;
    country: string;
    phone: string | null;
    type: $Enums.AddressType;
    isDefault: boolean;
    isValidated: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: AddressCountAggregateOutputType | null;
    _min: AddressMinAggregateOutputType | null;
    _max: AddressMaxAggregateOutputType | null;
  };

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AddressGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AddressGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>;
        }
      >
    >;

  export type AddressSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      customerId?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      company?: boolean;
      address1?: boolean;
      address2?: boolean;
      city?: boolean;
      state?: boolean;
      postalCode?: boolean;
      country?: boolean;
      phone?: boolean;
      type?: boolean;
      isDefault?: boolean;
      isValidated?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      customer?: boolean | CustomerDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["address"]
  >;

  export type AddressSelectScalar = {
    id?: boolean;
    customerId?: boolean;
    firstName?: boolean;
    lastName?: boolean;
    company?: boolean;
    address1?: boolean;
    address2?: boolean;
    city?: boolean;
    state?: boolean;
    postalCode?: boolean;
    country?: boolean;
    phone?: boolean;
    type?: boolean;
    isDefault?: boolean;
    isValidated?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AddressInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>;
  };

  export type $AddressPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Address";
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        customerId: string;
        firstName: string | null;
        lastName: string | null;
        company: string | null;
        address1: string;
        address2: string | null;
        city: string;
        state: string;
        postalCode: string;
        country: string;
        phone: string | null;
        type: $Enums.AddressType;
        isDefault: boolean;
        isValidated: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["address"]
    >;
    composites: {};
  };

  type AddressGetPayload<
    S extends boolean | null | undefined | AddressDefaultArgs,
  > = $Result.GetResult<Prisma.$AddressPayload, S>;

  type AddressCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AddressFindManyArgs, "select" | "include" | "distinct"> & {
    select?: AddressCountAggregateInputType | true;
  };

  export interface AddressDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Address"];
      meta: { name: "Address" };
    };
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(
      args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>,
    ): Prisma__AddressClient<
      $Result.GetResult<
        Prisma.$AddressPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AddressClient<
      $Result.GetResult<
        Prisma.$AddressPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(
      args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>,
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     *
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     *
     */
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs<ExtArgs>>,
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     *
     */
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>,
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>,
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>,
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Addresses that matches the filter.
     * @param {AddressFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const address = await prisma.address.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AddressFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Address.
     * @param {AddressAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const address = await prisma.address.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: AddressAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
     **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AddressCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AddressAggregateArgs>(
      args: Subset<T, AddressAggregateArgs>,
    ): Prisma.PrismaPromise<GetAddressAggregateType<T>>;

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs["orderBy"] }
        : { orderBy?: AddressGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetAddressGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Address model
     */
    readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CustomerDefaultArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      | $Result.GetResult<
          Prisma.$CustomerPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", "String">;
    readonly customerId: FieldRef<"Address", "String">;
    readonly firstName: FieldRef<"Address", "String">;
    readonly lastName: FieldRef<"Address", "String">;
    readonly company: FieldRef<"Address", "String">;
    readonly address1: FieldRef<"Address", "String">;
    readonly address2: FieldRef<"Address", "String">;
    readonly city: FieldRef<"Address", "String">;
    readonly state: FieldRef<"Address", "String">;
    readonly postalCode: FieldRef<"Address", "String">;
    readonly country: FieldRef<"Address", "String">;
    readonly phone: FieldRef<"Address", "String">;
    readonly type: FieldRef<"Address", "AddressType">;
    readonly isDefault: FieldRef<"Address", "Boolean">;
    readonly isValidated: FieldRef<"Address", "Boolean">;
    readonly createdAt: FieldRef<"Address", "DateTime">;
    readonly updatedAt: FieldRef<"Address", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address create
   */
  export type AddressCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>;
  };

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[];
  };

  /**
   * Address update
   */
  export type AddressUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>;
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>;
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput;
  };

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput;
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>;
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>;
  };

  /**
   * Address delete
   */
  export type AddressDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput;
  };

  /**
   * Address findRaw
   */
  export type AddressFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Address aggregateRaw
   */
  export type AddressAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Address without action
   */
  export type AddressDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
  };

  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null;
    _avg: CategoryAvgAggregateOutputType | null;
    _sum: CategorySumAggregateOutputType | null;
    _min: CategoryMinAggregateOutputType | null;
    _max: CategoryMaxAggregateOutputType | null;
  };

  export type CategoryAvgAggregateOutputType = {
    sortOrder: number | null;
    productCount: number | null;
  };

  export type CategorySumAggregateOutputType = {
    sortOrder: number | null;
    productCount: number | null;
  };

  export type CategoryMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    description: string | null;
    iconClass: string | null;
    parentId: string | null;
    image: string | null;
    sortOrder: number | null;
    isActive: boolean | null;
    isFeatured: boolean | null;
    metaTitle: string | null;
    metaDescription: string | null;
    productCount: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CategoryMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    description: string | null;
    iconClass: string | null;
    parentId: string | null;
    image: string | null;
    sortOrder: number | null;
    isActive: boolean | null;
    isFeatured: boolean | null;
    metaTitle: string | null;
    metaDescription: string | null;
    productCount: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CategoryCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    description: number;
    iconClass: number;
    parentId: number;
    image: number;
    sortOrder: number;
    isActive: number;
    isFeatured: number;
    metaTitle: number;
    metaDescription: number;
    productCount: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type CategoryAvgAggregateInputType = {
    sortOrder?: true;
    productCount?: true;
  };

  export type CategorySumAggregateInputType = {
    sortOrder?: true;
    productCount?: true;
  };

  export type CategoryMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    description?: true;
    iconClass?: true;
    parentId?: true;
    image?: true;
    sortOrder?: true;
    isActive?: true;
    isFeatured?: true;
    metaTitle?: true;
    metaDescription?: true;
    productCount?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CategoryMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    description?: true;
    iconClass?: true;
    parentId?: true;
    image?: true;
    sortOrder?: true;
    isActive?: true;
    isFeatured?: true;
    metaTitle?: true;
    metaDescription?: true;
    productCount?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CategoryCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    description?: true;
    iconClass?: true;
    parentId?: true;
    image?: true;
    sortOrder?: true;
    isActive?: true;
    isFeatured?: true;
    metaTitle?: true;
    metaDescription?: true;
    productCount?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type CategoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Categories
     **/
    _count?: true | CategoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CategoryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CategorySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CategoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CategoryMaxAggregateInputType;
  };

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
    [P in keyof T & keyof AggregateCategory]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>;
  };

  export type CategoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CategoryWhereInput;
    orderBy?:
      | CategoryOrderByWithAggregationInput
      | CategoryOrderByWithAggregationInput[];
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum;
    having?: CategoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CategoryCountAggregateInputType | true;
    _avg?: CategoryAvgAggregateInputType;
    _sum?: CategorySumAggregateInputType;
    _min?: CategoryMinAggregateInputType;
    _max?: CategoryMaxAggregateInputType;
  };

  export type CategoryGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    description: string | null;
    iconClass: string | null;
    parentId: string | null;
    image: string | null;
    sortOrder: number;
    isActive: boolean;
    isFeatured: boolean;
    metaTitle: string | null;
    metaDescription: string | null;
    productCount: number;
    createdAt: Date;
    updatedAt: Date;
    _count: CategoryCountAggregateOutputType | null;
    _avg: CategoryAvgAggregateOutputType | null;
    _sum: CategorySumAggregateOutputType | null;
    _min: CategoryMinAggregateOutputType | null;
    _max: CategoryMaxAggregateOutputType | null;
  };

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CategoryGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof CategoryGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>;
        }
      >
    >;

  export type CategorySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      description?: boolean;
      iconClass?: boolean;
      parentId?: boolean;
      image?: boolean;
      sortOrder?: boolean;
      isActive?: boolean;
      isFeatured?: boolean;
      metaTitle?: boolean;
      metaDescription?: boolean;
      productCount?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      parent?: boolean | Category$parentArgs<ExtArgs>;
      children?: boolean | Category$childrenArgs<ExtArgs>;
      products?: boolean | Category$productsArgs<ExtArgs>;
      _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["category"]
  >;

  export type CategorySelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
    description?: boolean;
    iconClass?: boolean;
    parentId?: boolean;
    image?: boolean;
    sortOrder?: boolean;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: boolean;
    metaDescription?: boolean;
    productCount?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type CategoryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    parent?: boolean | Category$parentArgs<ExtArgs>;
    children?: boolean | Category$childrenArgs<ExtArgs>;
    products?: boolean | Category$productsArgs<ExtArgs>;
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $CategoryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Category";
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null;
      children: Prisma.$CategoryPayload<ExtArgs>[];
      products: Prisma.$ProductPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        slug: string;
        description: string | null;
        iconClass: string | null;
        parentId: string | null;
        image: string | null;
        sortOrder: number;
        isActive: boolean;
        isFeatured: boolean;
        metaTitle: string | null;
        metaDescription: string | null;
        productCount: number;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["category"]
    >;
    composites: {};
  };

  type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryDefaultArgs,
  > = $Result.GetResult<Prisma.$CategoryPayload, S>;

  type CategoryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CategoryFindManyArgs, "select" | "include" | "distinct"> & {
    select?: CategoryCountAggregateInputType | true;
  };

  export interface CategoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Category"];
      meta: { name: "Category" };
    };
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     *
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     *
     */
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     *
     */
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CategoryFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: CategoryAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
     **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CategoryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CategoryAggregateArgs>(
      args: Subset<T, CategoryAggregateArgs>,
    ): Prisma.PrismaPromise<GetCategoryAggregateType<T>>;

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs["orderBy"] }
        : { orderBy?: CategoryGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetCategoryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Category model
     */
    readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    parent<T extends Category$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Category$parentArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      $Result.GetResult<
        Prisma.$CategoryPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      > | null,
      null,
      ExtArgs
    >;
    children<T extends Category$childrenArgs<ExtArgs> = {}>(
      args?: Subset<T, Category$childrenArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null
    >;
    products<T extends Category$productsArgs<ExtArgs> = {}>(
      args?: Subset<T, Category$productsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", "String">;
    readonly name: FieldRef<"Category", "String">;
    readonly slug: FieldRef<"Category", "String">;
    readonly description: FieldRef<"Category", "String">;
    readonly iconClass: FieldRef<"Category", "String">;
    readonly parentId: FieldRef<"Category", "String">;
    readonly image: FieldRef<"Category", "String">;
    readonly sortOrder: FieldRef<"Category", "Int">;
    readonly isActive: FieldRef<"Category", "Boolean">;
    readonly isFeatured: FieldRef<"Category", "Boolean">;
    readonly metaTitle: FieldRef<"Category", "String">;
    readonly metaDescription: FieldRef<"Category", "String">;
    readonly productCount: FieldRef<"Category", "Int">;
    readonly createdAt: FieldRef<"Category", "DateTime">;
    readonly updatedAt: FieldRef<"Category", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category create
   */
  export type CategoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>;
  };

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[];
  };

  /**
   * Category update
   */
  export type CategoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>;
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Categories.
     */
    data: XOR<
      CategoryUpdateManyMutationInput,
      CategoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput;
  };

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput;
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>;
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>;
  };

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput;
  };

  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Category.parent
   */
  export type Category$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    where?: CategoryWhereInput;
  };

  /**
   * Category.children
   */
  export type Category$childrenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    where?: CategoryWhereInput;
    orderBy?:
      | CategoryOrderByWithRelationInput
      | CategoryOrderByWithRelationInput[];
    cursor?: CategoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category.products
   */
  export type Category$productsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    where?: ProductWhereInput;
    orderBy?:
      | ProductOrderByWithRelationInput
      | ProductOrderByWithRelationInput[];
    cursor?: ProductWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[];
  };

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
  };

  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null;
    _avg: ProductAvgAggregateOutputType | null;
    _sum: ProductSumAggregateOutputType | null;
    _min: ProductMinAggregateOutputType | null;
    _max: ProductMaxAggregateOutputType | null;
  };

  export type ProductAvgAggregateOutputType = {
    regularPrice: number | null;
    salePrice: number | null;
    costPrice: number | null;
    stockQuantity: number | null;
    lowStockThreshold: number | null;
    minimumOrderQuantity: number | null;
    weight: number | null;
    version: number | null;
  };

  export type ProductSumAggregateOutputType = {
    regularPrice: number | null;
    salePrice: number | null;
    costPrice: number | null;
    stockQuantity: number | null;
    lowStockThreshold: number | null;
    minimumOrderQuantity: number | null;
    weight: number | null;
    version: number | null;
  };

  export type ProductMinAggregateOutputType = {
    id: string | null;
    categoryId: string | null;
    name: string | null;
    description: string | null;
    shortDescription: string | null;
    regularPrice: number | null;
    salePrice: number | null;
    costPrice: number | null;
    sku: string | null;
    partNumber: string | null;
    upc: string | null;
    stockQuantity: number | null;
    lowStockThreshold: number | null;
    trackInventory: boolean | null;
    allowBackorders: boolean | null;
    professionalOnly: boolean | null;
    minimumOrderQuantity: number | null;
    status: $Enums.ProductStatus | null;
    approvalStatus: $Enums.ApprovalStatus | null;
    featured: boolean | null;
    onSale: boolean | null;
    newProduct: boolean | null;
    metaTitle: string | null;
    metaDescription: string | null;
    weight: number | null;
    requiresShipping: boolean | null;
    shippingClass: string | null;
    version: number | null;
    createdBy: string | null;
    lastModifiedBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductMaxAggregateOutputType = {
    id: string | null;
    categoryId: string | null;
    name: string | null;
    description: string | null;
    shortDescription: string | null;
    regularPrice: number | null;
    salePrice: number | null;
    costPrice: number | null;
    sku: string | null;
    partNumber: string | null;
    upc: string | null;
    stockQuantity: number | null;
    lowStockThreshold: number | null;
    trackInventory: boolean | null;
    allowBackorders: boolean | null;
    professionalOnly: boolean | null;
    minimumOrderQuantity: number | null;
    status: $Enums.ProductStatus | null;
    approvalStatus: $Enums.ApprovalStatus | null;
    featured: boolean | null;
    onSale: boolean | null;
    newProduct: boolean | null;
    metaTitle: string | null;
    metaDescription: string | null;
    weight: number | null;
    requiresShipping: boolean | null;
    shippingClass: string | null;
    version: number | null;
    createdBy: string | null;
    lastModifiedBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductCountAggregateOutputType = {
    id: number;
    categoryId: number;
    name: number;
    description: number;
    shortDescription: number;
    regularPrice: number;
    salePrice: number;
    costPrice: number;
    sku: number;
    partNumber: number;
    upc: number;
    stockQuantity: number;
    lowStockThreshold: number;
    trackInventory: number;
    allowBackorders: number;
    professionalOnly: number;
    minimumOrderQuantity: number;
    status: number;
    approvalStatus: number;
    featured: number;
    onSale: number;
    newProduct: number;
    metaTitle: number;
    metaDescription: number;
    tags: number;
    weight: number;
    dimensions: number;
    requiresShipping: number;
    shippingClass: number;
    version: number;
    createdBy: number;
    lastModifiedBy: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ProductAvgAggregateInputType = {
    regularPrice?: true;
    salePrice?: true;
    costPrice?: true;
    stockQuantity?: true;
    lowStockThreshold?: true;
    minimumOrderQuantity?: true;
    weight?: true;
    version?: true;
  };

  export type ProductSumAggregateInputType = {
    regularPrice?: true;
    salePrice?: true;
    costPrice?: true;
    stockQuantity?: true;
    lowStockThreshold?: true;
    minimumOrderQuantity?: true;
    weight?: true;
    version?: true;
  };

  export type ProductMinAggregateInputType = {
    id?: true;
    categoryId?: true;
    name?: true;
    description?: true;
    shortDescription?: true;
    regularPrice?: true;
    salePrice?: true;
    costPrice?: true;
    sku?: true;
    partNumber?: true;
    upc?: true;
    stockQuantity?: true;
    lowStockThreshold?: true;
    trackInventory?: true;
    allowBackorders?: true;
    professionalOnly?: true;
    minimumOrderQuantity?: true;
    status?: true;
    approvalStatus?: true;
    featured?: true;
    onSale?: true;
    newProduct?: true;
    metaTitle?: true;
    metaDescription?: true;
    weight?: true;
    requiresShipping?: true;
    shippingClass?: true;
    version?: true;
    createdBy?: true;
    lastModifiedBy?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductMaxAggregateInputType = {
    id?: true;
    categoryId?: true;
    name?: true;
    description?: true;
    shortDescription?: true;
    regularPrice?: true;
    salePrice?: true;
    costPrice?: true;
    sku?: true;
    partNumber?: true;
    upc?: true;
    stockQuantity?: true;
    lowStockThreshold?: true;
    trackInventory?: true;
    allowBackorders?: true;
    professionalOnly?: true;
    minimumOrderQuantity?: true;
    status?: true;
    approvalStatus?: true;
    featured?: true;
    onSale?: true;
    newProduct?: true;
    metaTitle?: true;
    metaDescription?: true;
    weight?: true;
    requiresShipping?: true;
    shippingClass?: true;
    version?: true;
    createdBy?: true;
    lastModifiedBy?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductCountAggregateInputType = {
    id?: true;
    categoryId?: true;
    name?: true;
    description?: true;
    shortDescription?: true;
    regularPrice?: true;
    salePrice?: true;
    costPrice?: true;
    sku?: true;
    partNumber?: true;
    upc?: true;
    stockQuantity?: true;
    lowStockThreshold?: true;
    trackInventory?: true;
    allowBackorders?: true;
    professionalOnly?: true;
    minimumOrderQuantity?: true;
    status?: true;
    approvalStatus?: true;
    featured?: true;
    onSale?: true;
    newProduct?: true;
    metaTitle?: true;
    metaDescription?: true;
    tags?: true;
    weight?: true;
    dimensions?: true;
    requiresShipping?: true;
    shippingClass?: true;
    version?: true;
    createdBy?: true;
    lastModifiedBy?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ProductAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?:
      | ProductOrderByWithRelationInput
      | ProductOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Products
     **/
    _count?: true | ProductCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProductAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProductSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProductMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProductMaxAggregateInputType;
  };

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
    [P in keyof T & keyof AggregateProduct]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>;
  };

  export type ProductGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductWhereInput;
    orderBy?:
      | ProductOrderByWithAggregationInput
      | ProductOrderByWithAggregationInput[];
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum;
    having?: ProductScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProductCountAggregateInputType | true;
    _avg?: ProductAvgAggregateInputType;
    _sum?: ProductSumAggregateInputType;
    _min?: ProductMinAggregateInputType;
    _max?: ProductMaxAggregateInputType;
  };

  export type ProductGroupByOutputType = {
    id: string;
    categoryId: string;
    name: string;
    description: string;
    shortDescription: string | null;
    regularPrice: number;
    salePrice: number | null;
    costPrice: number | null;
    sku: string;
    partNumber: string | null;
    upc: string | null;
    stockQuantity: number;
    lowStockThreshold: number;
    trackInventory: boolean;
    allowBackorders: boolean;
    professionalOnly: boolean;
    minimumOrderQuantity: number;
    status: $Enums.ProductStatus;
    approvalStatus: $Enums.ApprovalStatus;
    featured: boolean;
    onSale: boolean;
    newProduct: boolean;
    metaTitle: string | null;
    metaDescription: string | null;
    tags: string[];
    weight: number | null;
    dimensions: JsonValue | null;
    requiresShipping: boolean;
    shippingClass: string | null;
    version: number;
    createdBy: string | null;
    lastModifiedBy: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ProductCountAggregateOutputType | null;
    _avg: ProductAvgAggregateOutputType | null;
    _sum: ProductSumAggregateOutputType | null;
    _min: ProductMinAggregateOutputType | null;
    _max: ProductMaxAggregateOutputType | null;
  };

  type GetProductGroupByPayload<T extends ProductGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ProductGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ProductGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>;
        }
      >
    >;

  export type ProductSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      categoryId?: boolean;
      name?: boolean;
      description?: boolean;
      shortDescription?: boolean;
      regularPrice?: boolean;
      salePrice?: boolean;
      costPrice?: boolean;
      sku?: boolean;
      partNumber?: boolean;
      upc?: boolean;
      stockQuantity?: boolean;
      lowStockThreshold?: boolean;
      trackInventory?: boolean;
      allowBackorders?: boolean;
      professionalOnly?: boolean;
      minimumOrderQuantity?: boolean;
      status?: boolean;
      approvalStatus?: boolean;
      featured?: boolean;
      onSale?: boolean;
      newProduct?: boolean;
      metaTitle?: boolean;
      metaDescription?: boolean;
      tags?: boolean;
      weight?: boolean;
      dimensions?: boolean;
      requiresShipping?: boolean;
      shippingClass?: boolean;
      vehicleCompatibility?: boolean | VehicleCompatibilityDefaultArgs<ExtArgs>;
      version?: boolean;
      createdBy?: boolean;
      lastModifiedBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      category?: boolean | CategoryDefaultArgs<ExtArgs>;
      reviews?: boolean | Product$reviewsArgs<ExtArgs>;
      orderItems?: boolean | Product$orderItemsArgs<ExtArgs>;
      _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["product"]
  >;

  export type ProductSelectScalar = {
    id?: boolean;
    categoryId?: boolean;
    name?: boolean;
    description?: boolean;
    shortDescription?: boolean;
    regularPrice?: boolean;
    salePrice?: boolean;
    costPrice?: boolean;
    sku?: boolean;
    partNumber?: boolean;
    upc?: boolean;
    stockQuantity?: boolean;
    lowStockThreshold?: boolean;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: boolean;
    status?: boolean;
    approvalStatus?: boolean;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: boolean;
    metaDescription?: boolean;
    tags?: boolean;
    weight?: boolean;
    dimensions?: boolean;
    requiresShipping?: boolean;
    shippingClass?: boolean;
    version?: boolean;
    createdBy?: boolean;
    lastModifiedBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ProductInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>;
    reviews?: boolean | Product$reviewsArgs<ExtArgs>;
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>;
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ProductPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Product";
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>;
      reviews: Prisma.$ProductReviewPayload<ExtArgs>[];
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        categoryId: string;
        name: string;
        description: string;
        shortDescription: string | null;
        regularPrice: number;
        salePrice: number | null;
        costPrice: number | null;
        sku: string;
        partNumber: string | null;
        upc: string | null;
        stockQuantity: number;
        lowStockThreshold: number;
        trackInventory: boolean;
        allowBackorders: boolean;
        professionalOnly: boolean;
        minimumOrderQuantity: number;
        status: $Enums.ProductStatus;
        approvalStatus: $Enums.ApprovalStatus;
        featured: boolean;
        onSale: boolean;
        newProduct: boolean;
        metaTitle: string | null;
        metaDescription: string | null;
        tags: string[];
        weight: number | null;
        dimensions: Prisma.JsonValue | null;
        requiresShipping: boolean;
        shippingClass: string | null;
        version: number;
        createdBy: string | null;
        lastModifiedBy: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["product"]
    >;
    composites: {
      vehicleCompatibility: Prisma.$VehicleCompatibilityPayload | null;
    };
  };

  type ProductGetPayload<
    S extends boolean | null | undefined | ProductDefaultArgs,
  > = $Result.GetResult<Prisma.$ProductPayload, S>;

  type ProductCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ProductFindManyArgs, "select" | "include" | "distinct"> & {
    select?: ProductCountAggregateInputType | true;
  };

  export interface ProductDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Product"];
      meta: { name: "Product" };
    };
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      $Result.GetResult<
        Prisma.$ProductPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      $Result.GetResult<
        Prisma.$ProductPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     *
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     *
     */
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     *
     */
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      $Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Products that matches the filter.
     * @param {ProductFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const product = await prisma.product.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProductFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Product.
     * @param {ProductAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const product = await prisma.product.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ProductAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
     **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ProductCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProductAggregateArgs>(
      args: Subset<T, ProductAggregateArgs>,
    ): Prisma.PrismaPromise<GetProductAggregateType<T>>;

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs["orderBy"] }
        : { orderBy?: ProductGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetProductGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Product model
     */
    readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CategoryDefaultArgs<ExtArgs>>,
    ): Prisma__CategoryClient<
      | $Result.GetResult<
          Prisma.$CategoryPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;
    reviews<T extends Product$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$reviewsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany">
      | Null
    >;
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Product$orderItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", "String">;
    readonly categoryId: FieldRef<"Product", "String">;
    readonly name: FieldRef<"Product", "String">;
    readonly description: FieldRef<"Product", "String">;
    readonly shortDescription: FieldRef<"Product", "String">;
    readonly regularPrice: FieldRef<"Product", "Float">;
    readonly salePrice: FieldRef<"Product", "Float">;
    readonly costPrice: FieldRef<"Product", "Float">;
    readonly sku: FieldRef<"Product", "String">;
    readonly partNumber: FieldRef<"Product", "String">;
    readonly upc: FieldRef<"Product", "String">;
    readonly stockQuantity: FieldRef<"Product", "Int">;
    readonly lowStockThreshold: FieldRef<"Product", "Int">;
    readonly trackInventory: FieldRef<"Product", "Boolean">;
    readonly allowBackorders: FieldRef<"Product", "Boolean">;
    readonly professionalOnly: FieldRef<"Product", "Boolean">;
    readonly minimumOrderQuantity: FieldRef<"Product", "Int">;
    readonly status: FieldRef<"Product", "ProductStatus">;
    readonly approvalStatus: FieldRef<"Product", "ApprovalStatus">;
    readonly featured: FieldRef<"Product", "Boolean">;
    readonly onSale: FieldRef<"Product", "Boolean">;
    readonly newProduct: FieldRef<"Product", "Boolean">;
    readonly metaTitle: FieldRef<"Product", "String">;
    readonly metaDescription: FieldRef<"Product", "String">;
    readonly tags: FieldRef<"Product", "String[]">;
    readonly weight: FieldRef<"Product", "Float">;
    readonly dimensions: FieldRef<"Product", "Json">;
    readonly requiresShipping: FieldRef<"Product", "Boolean">;
    readonly shippingClass: FieldRef<"Product", "String">;
    readonly version: FieldRef<"Product", "Int">;
    readonly createdBy: FieldRef<"Product", "String">;
    readonly lastModifiedBy: FieldRef<"Product", "String">;
    readonly createdAt: FieldRef<"Product", "DateTime">;
    readonly updatedAt: FieldRef<"Product", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput;
  };

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput;
  };

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?:
      | ProductOrderByWithRelationInput
      | ProductOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[];
  };

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?:
      | ProductOrderByWithRelationInput
      | ProductOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[];
  };

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Products to fetch.
     */
    orderBy?:
      | ProductOrderByWithRelationInput
      | ProductOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Products.
     */
    skip?: number;
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[];
  };

  /**
   * Product create
   */
  export type ProductCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>;
  };

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[];
  };

  /**
   * Product update
   */
  export type ProductUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>;
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput;
  };

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>;
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput;
  };

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput;
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>;
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>;
  };

  /**
   * Product delete
   */
  export type ProductDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput;
  };

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput;
  };

  /**
   * Product findRaw
   */
  export type ProductFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Product aggregateRaw
   */
  export type ProductAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Product.reviews
   */
  export type Product$reviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    where?: ProductReviewWhereInput;
    orderBy?:
      | ProductReviewOrderByWithRelationInput
      | ProductReviewOrderByWithRelationInput[];
    cursor?: ProductReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[];
  };

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    where?: OrderItemWhereInput;
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    cursor?: OrderItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * Product without action
   */
  export type ProductDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null;
  };

  /**
   * Model ProductReview
   */

  export type AggregateProductReview = {
    _count: ProductReviewCountAggregateOutputType | null;
    _avg: ProductReviewAvgAggregateOutputType | null;
    _sum: ProductReviewSumAggregateOutputType | null;
    _min: ProductReviewMinAggregateOutputType | null;
    _max: ProductReviewMaxAggregateOutputType | null;
  };

  export type ProductReviewAvgAggregateOutputType = {
    rating: number | null;
    helpful: number | null;
  };

  export type ProductReviewSumAggregateOutputType = {
    rating: number | null;
    helpful: number | null;
  };

  export type ProductReviewMinAggregateOutputType = {
    id: string | null;
    productId: string | null;
    customerId: string | null;
    rating: number | null;
    title: string | null;
    content: string | null;
    verified: boolean | null;
    helpful: number | null;
    status: $Enums.ReviewStatus | null;
    moderatedBy: string | null;
    moderatedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductReviewMaxAggregateOutputType = {
    id: string | null;
    productId: string | null;
    customerId: string | null;
    rating: number | null;
    title: string | null;
    content: string | null;
    verified: boolean | null;
    helpful: number | null;
    status: $Enums.ReviewStatus | null;
    moderatedBy: string | null;
    moderatedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ProductReviewCountAggregateOutputType = {
    id: number;
    productId: number;
    customerId: number;
    rating: number;
    title: number;
    content: number;
    verified: number;
    helpful: number;
    status: number;
    moderatedBy: number;
    moderatedAt: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ProductReviewAvgAggregateInputType = {
    rating?: true;
    helpful?: true;
  };

  export type ProductReviewSumAggregateInputType = {
    rating?: true;
    helpful?: true;
  };

  export type ProductReviewMinAggregateInputType = {
    id?: true;
    productId?: true;
    customerId?: true;
    rating?: true;
    title?: true;
    content?: true;
    verified?: true;
    helpful?: true;
    status?: true;
    moderatedBy?: true;
    moderatedAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductReviewMaxAggregateInputType = {
    id?: true;
    productId?: true;
    customerId?: true;
    rating?: true;
    title?: true;
    content?: true;
    verified?: true;
    helpful?: true;
    status?: true;
    moderatedBy?: true;
    moderatedAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ProductReviewCountAggregateInputType = {
    id?: true;
    productId?: true;
    customerId?: true;
    rating?: true;
    title?: true;
    content?: true;
    verified?: true;
    helpful?: true;
    status?: true;
    moderatedBy?: true;
    moderatedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ProductReviewAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProductReview to aggregate.
     */
    where?: ProductReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?:
      | ProductReviewOrderByWithRelationInput
      | ProductReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProductReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductReviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProductReviews
     **/
    _count?: true | ProductReviewCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProductReviewAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProductReviewSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProductReviewMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProductReviewMaxAggregateInputType;
  };

  export type GetProductReviewAggregateType<
    T extends ProductReviewAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateProductReview]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductReview[P]>
      : GetScalarType<T[P], AggregateProductReview[P]>;
  };

  export type ProductReviewGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProductReviewWhereInput;
    orderBy?:
      | ProductReviewOrderByWithAggregationInput
      | ProductReviewOrderByWithAggregationInput[];
    by: ProductReviewScalarFieldEnum[] | ProductReviewScalarFieldEnum;
    having?: ProductReviewScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProductReviewCountAggregateInputType | true;
    _avg?: ProductReviewAvgAggregateInputType;
    _sum?: ProductReviewSumAggregateInputType;
    _min?: ProductReviewMinAggregateInputType;
    _max?: ProductReviewMaxAggregateInputType;
  };

  export type ProductReviewGroupByOutputType = {
    id: string;
    productId: string;
    customerId: string;
    rating: number;
    title: string;
    content: string;
    verified: boolean;
    helpful: number;
    status: $Enums.ReviewStatus;
    moderatedBy: string | null;
    moderatedAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ProductReviewCountAggregateOutputType | null;
    _avg: ProductReviewAvgAggregateOutputType | null;
    _sum: ProductReviewSumAggregateOutputType | null;
    _min: ProductReviewMinAggregateOutputType | null;
    _max: ProductReviewMaxAggregateOutputType | null;
  };

  type GetProductReviewGroupByPayload<T extends ProductReviewGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ProductReviewGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ProductReviewGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>;
        }
      >
    >;

  export type ProductReviewSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      productId?: boolean;
      customerId?: boolean;
      rating?: boolean;
      title?: boolean;
      content?: boolean;
      verified?: boolean;
      helpful?: boolean;
      status?: boolean;
      moderatedBy?: boolean;
      moderatedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
      customer?: boolean | CustomerDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["productReview"]
  >;

  export type ProductReviewSelectScalar = {
    id?: boolean;
    productId?: boolean;
    customerId?: boolean;
    rating?: boolean;
    title?: boolean;
    content?: boolean;
    verified?: boolean;
    helpful?: boolean;
    status?: boolean;
    moderatedBy?: boolean;
    moderatedAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ProductReviewInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    product?: boolean | ProductDefaultArgs<ExtArgs>;
    customer?: boolean | CustomerDefaultArgs<ExtArgs>;
  };

  export type $ProductReviewPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ProductReview";
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>;
      customer: Prisma.$CustomerPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        productId: string;
        customerId: string;
        rating: number;
        title: string;
        content: string;
        verified: boolean;
        helpful: number;
        status: $Enums.ReviewStatus;
        moderatedBy: string | null;
        moderatedAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["productReview"]
    >;
    composites: {};
  };

  type ProductReviewGetPayload<
    S extends boolean | null | undefined | ProductReviewDefaultArgs,
  > = $Result.GetResult<Prisma.$ProductReviewPayload, S>;

  type ProductReviewCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ProductReviewFindManyArgs, "select" | "include" | "distinct"> & {
    select?: ProductReviewCountAggregateInputType | true;
  };

  export interface ProductReviewDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ProductReview"];
      meta: { name: "ProductReview" };
    };
    /**
     * Find zero or one ProductReview that matches the filter.
     * @param {ProductReviewFindUniqueArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductReviewFindUniqueArgs>(
      args: SelectSubset<T, ProductReviewFindUniqueArgs<ExtArgs>>,
    ): Prisma__ProductReviewClient<
      $Result.GetResult<
        Prisma.$ProductReviewPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one ProductReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductReviewFindUniqueOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductReviewFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProductReviewFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ProductReviewClient<
      $Result.GetResult<
        Prisma.$ProductReviewPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first ProductReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductReviewFindFirstArgs>(
      args?: SelectSubset<T, ProductReviewFindFirstArgs<ExtArgs>>,
    ): Prisma__ProductReviewClient<
      $Result.GetResult<
        Prisma.$ProductReviewPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first ProductReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductReviewFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ProductReviewClient<
      $Result.GetResult<
        Prisma.$ProductReviewPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ProductReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductReviews
     * const productReviews = await prisma.productReview.findMany()
     *
     * // Get first 10 ProductReviews
     * const productReviews = await prisma.productReview.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productReviewWithIdOnly = await prisma.productReview.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProductReviewFindManyArgs>(
      args?: SelectSubset<T, ProductReviewFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a ProductReview.
     * @param {ProductReviewCreateArgs} args - Arguments to create a ProductReview.
     * @example
     * // Create one ProductReview
     * const ProductReview = await prisma.productReview.create({
     *   data: {
     *     // ... data to create a ProductReview
     *   }
     * })
     *
     */
    create<T extends ProductReviewCreateArgs>(
      args: SelectSubset<T, ProductReviewCreateArgs<ExtArgs>>,
    ): Prisma__ProductReviewClient<
      $Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many ProductReviews.
     * @param {ProductReviewCreateManyArgs} args - Arguments to create many ProductReviews.
     * @example
     * // Create many ProductReviews
     * const productReview = await prisma.productReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProductReviewCreateManyArgs>(
      args?: SelectSubset<T, ProductReviewCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ProductReview.
     * @param {ProductReviewDeleteArgs} args - Arguments to delete one ProductReview.
     * @example
     * // Delete one ProductReview
     * const ProductReview = await prisma.productReview.delete({
     *   where: {
     *     // ... filter to delete one ProductReview
     *   }
     * })
     *
     */
    delete<T extends ProductReviewDeleteArgs>(
      args: SelectSubset<T, ProductReviewDeleteArgs<ExtArgs>>,
    ): Prisma__ProductReviewClient<
      $Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one ProductReview.
     * @param {ProductReviewUpdateArgs} args - Arguments to update one ProductReview.
     * @example
     * // Update one ProductReview
     * const productReview = await prisma.productReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProductReviewUpdateArgs>(
      args: SelectSubset<T, ProductReviewUpdateArgs<ExtArgs>>,
    ): Prisma__ProductReviewClient<
      $Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more ProductReviews.
     * @param {ProductReviewDeleteManyArgs} args - Arguments to filter ProductReviews to delete.
     * @example
     * // Delete a few ProductReviews
     * const { count } = await prisma.productReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProductReviewDeleteManyArgs>(
      args?: SelectSubset<T, ProductReviewDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductReviews
     * const productReview = await prisma.productReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProductReviewUpdateManyArgs>(
      args: SelectSubset<T, ProductReviewUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ProductReview.
     * @param {ProductReviewUpsertArgs} args - Arguments to update or create a ProductReview.
     * @example
     * // Update or create a ProductReview
     * const productReview = await prisma.productReview.upsert({
     *   create: {
     *     // ... data to create a ProductReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductReview we want to update
     *   }
     * })
     */
    upsert<T extends ProductReviewUpsertArgs>(
      args: SelectSubset<T, ProductReviewUpsertArgs<ExtArgs>>,
    ): Prisma__ProductReviewClient<
      $Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ProductReviews that matches the filter.
     * @param {ProductReviewFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const productReview = await prisma.productReview.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProductReviewFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a ProductReview.
     * @param {ProductReviewAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const productReview = await prisma.productReview.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ProductReviewAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewCountArgs} args - Arguments to filter ProductReviews to count.
     * @example
     * // Count the number of ProductReviews
     * const count = await prisma.productReview.count({
     *   where: {
     *     // ... the filter for the ProductReviews we want to count
     *   }
     * })
     **/
    count<T extends ProductReviewCountArgs>(
      args?: Subset<T, ProductReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ProductReviewCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProductReviewAggregateArgs>(
      args: Subset<T, ProductReviewAggregateArgs>,
    ): Prisma.PrismaPromise<GetProductReviewAggregateType<T>>;

    /**
     * Group by ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProductReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductReviewGroupByArgs["orderBy"] }
        : { orderBy?: ProductReviewGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProductReviewGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetProductReviewGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ProductReview model
     */
    readonly fields: ProductReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductReviewClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductDefaultArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      | $Result.GetResult<
          Prisma.$ProductPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CustomerDefaultArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      | $Result.GetResult<
          Prisma.$CustomerPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ProductReview model
   */
  interface ProductReviewFieldRefs {
    readonly id: FieldRef<"ProductReview", "String">;
    readonly productId: FieldRef<"ProductReview", "String">;
    readonly customerId: FieldRef<"ProductReview", "String">;
    readonly rating: FieldRef<"ProductReview", "Int">;
    readonly title: FieldRef<"ProductReview", "String">;
    readonly content: FieldRef<"ProductReview", "String">;
    readonly verified: FieldRef<"ProductReview", "Boolean">;
    readonly helpful: FieldRef<"ProductReview", "Int">;
    readonly status: FieldRef<"ProductReview", "ReviewStatus">;
    readonly moderatedBy: FieldRef<"ProductReview", "String">;
    readonly moderatedAt: FieldRef<"ProductReview", "DateTime">;
    readonly createdAt: FieldRef<"ProductReview", "DateTime">;
    readonly updatedAt: FieldRef<"ProductReview", "DateTime">;
  }

  // Custom InputTypes
  /**
   * ProductReview findUnique
   */
  export type ProductReviewFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput;
  };

  /**
   * ProductReview findUniqueOrThrow
   */
  export type ProductReviewFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput;
  };

  /**
   * ProductReview findFirst
   */
  export type ProductReviewFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?:
      | ProductReviewOrderByWithRelationInput
      | ProductReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductReviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[];
  };

  /**
   * ProductReview findFirstOrThrow
   */
  export type ProductReviewFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?:
      | ProductReviewOrderByWithRelationInput
      | ProductReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductReviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[];
  };

  /**
   * ProductReview findMany
   */
  export type ProductReviewFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * Filter, which ProductReviews to fetch.
     */
    where?: ProductReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?:
      | ProductReviewOrderByWithRelationInput
      | ProductReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProductReviews.
     */
    skip?: number;
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[];
  };

  /**
   * ProductReview create
   */
  export type ProductReviewCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * The data needed to create a ProductReview.
     */
    data: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>;
  };

  /**
   * ProductReview createMany
   */
  export type ProductReviewCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ProductReviews.
     */
    data: ProductReviewCreateManyInput | ProductReviewCreateManyInput[];
  };

  /**
   * ProductReview update
   */
  export type ProductReviewUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * The data needed to update a ProductReview.
     */
    data: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>;
    /**
     * Choose, which ProductReview to update.
     */
    where: ProductReviewWhereUniqueInput;
  };

  /**
   * ProductReview updateMany
   */
  export type ProductReviewUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ProductReviews.
     */
    data: XOR<
      ProductReviewUpdateManyMutationInput,
      ProductReviewUncheckedUpdateManyInput
    >;
    /**
     * Filter which ProductReviews to update
     */
    where?: ProductReviewWhereInput;
  };

  /**
   * ProductReview upsert
   */
  export type ProductReviewUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * The filter to search for the ProductReview to update in case it exists.
     */
    where: ProductReviewWhereUniqueInput;
    /**
     * In case the ProductReview found by the `where` argument doesn't exist, create a new ProductReview with this data.
     */
    create: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>;
    /**
     * In case the ProductReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>;
  };

  /**
   * ProductReview delete
   */
  export type ProductReviewDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
    /**
     * Filter which ProductReview to delete.
     */
    where: ProductReviewWhereUniqueInput;
  };

  /**
   * ProductReview deleteMany
   */
  export type ProductReviewDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProductReviews to delete
     */
    where?: ProductReviewWhereInput;
  };

  /**
   * ProductReview findRaw
   */
  export type ProductReviewFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ProductReview aggregateRaw
   */
  export type ProductReviewAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ProductReview without action
   */
  export type ProductReviewDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null;
  };

  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null;
    _avg: OrderAvgAggregateOutputType | null;
    _sum: OrderSumAggregateOutputType | null;
    _min: OrderMinAggregateOutputType | null;
    _max: OrderMaxAggregateOutputType | null;
  };

  export type OrderAvgAggregateOutputType = {
    subtotal: number | null;
    taxAmount: number | null;
    shippingAmount: number | null;
    discountAmount: number | null;
    totalAmount: number | null;
    refundAmount: number | null;
  };

  export type OrderSumAggregateOutputType = {
    subtotal: number | null;
    taxAmount: number | null;
    shippingAmount: number | null;
    discountAmount: number | null;
    totalAmount: number | null;
    refundAmount: number | null;
  };

  export type OrderMinAggregateOutputType = {
    id: string | null;
    customerId: string | null;
    orderNumber: string | null;
    status: $Enums.OrderStatus | null;
    paymentStatus: $Enums.PaymentStatus | null;
    fulfillmentStatus: $Enums.FulfillmentStatus | null;
    priorityLevel: $Enums.OrderPriority | null;
    subtotal: number | null;
    taxAmount: number | null;
    shippingAmount: number | null;
    discountAmount: number | null;
    totalAmount: number | null;
    paymentMethod: string | null;
    paymentReference: string | null;
    shippingCarrier: string | null;
    shippingMethod: string | null;
    trackingNumber: string | null;
    estimatedDelivery: Date | null;
    actualDelivery: Date | null;
    assignedToStaffId: string | null;
    internalNotes: string | null;
    customerNotes: string | null;
    cancellationReason: string | null;
    cancelledAt: Date | null;
    refundAmount: number | null;
    refundReason: string | null;
    refundedAt: Date | null;
    orderDate: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OrderMaxAggregateOutputType = {
    id: string | null;
    customerId: string | null;
    orderNumber: string | null;
    status: $Enums.OrderStatus | null;
    paymentStatus: $Enums.PaymentStatus | null;
    fulfillmentStatus: $Enums.FulfillmentStatus | null;
    priorityLevel: $Enums.OrderPriority | null;
    subtotal: number | null;
    taxAmount: number | null;
    shippingAmount: number | null;
    discountAmount: number | null;
    totalAmount: number | null;
    paymentMethod: string | null;
    paymentReference: string | null;
    shippingCarrier: string | null;
    shippingMethod: string | null;
    trackingNumber: string | null;
    estimatedDelivery: Date | null;
    actualDelivery: Date | null;
    assignedToStaffId: string | null;
    internalNotes: string | null;
    customerNotes: string | null;
    cancellationReason: string | null;
    cancelledAt: Date | null;
    refundAmount: number | null;
    refundReason: string | null;
    refundedAt: Date | null;
    orderDate: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OrderCountAggregateOutputType = {
    id: number;
    customerId: number;
    orderNumber: number;
    status: number;
    paymentStatus: number;
    fulfillmentStatus: number;
    priorityLevel: number;
    subtotal: number;
    taxAmount: number;
    shippingAmount: number;
    discountAmount: number;
    totalAmount: number;
    paymentMethod: number;
    paymentReference: number;
    shippingAddress: number;
    billingAddress: number;
    shippingCarrier: number;
    shippingMethod: number;
    trackingNumber: number;
    estimatedDelivery: number;
    actualDelivery: number;
    assignedToStaffId: number;
    internalNotes: number;
    customerNotes: number;
    cancellationReason: number;
    cancelledAt: number;
    refundAmount: number;
    refundReason: number;
    refundedAt: number;
    orderDate: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type OrderAvgAggregateInputType = {
    subtotal?: true;
    taxAmount?: true;
    shippingAmount?: true;
    discountAmount?: true;
    totalAmount?: true;
    refundAmount?: true;
  };

  export type OrderSumAggregateInputType = {
    subtotal?: true;
    taxAmount?: true;
    shippingAmount?: true;
    discountAmount?: true;
    totalAmount?: true;
    refundAmount?: true;
  };

  export type OrderMinAggregateInputType = {
    id?: true;
    customerId?: true;
    orderNumber?: true;
    status?: true;
    paymentStatus?: true;
    fulfillmentStatus?: true;
    priorityLevel?: true;
    subtotal?: true;
    taxAmount?: true;
    shippingAmount?: true;
    discountAmount?: true;
    totalAmount?: true;
    paymentMethod?: true;
    paymentReference?: true;
    shippingCarrier?: true;
    shippingMethod?: true;
    trackingNumber?: true;
    estimatedDelivery?: true;
    actualDelivery?: true;
    assignedToStaffId?: true;
    internalNotes?: true;
    customerNotes?: true;
    cancellationReason?: true;
    cancelledAt?: true;
    refundAmount?: true;
    refundReason?: true;
    refundedAt?: true;
    orderDate?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OrderMaxAggregateInputType = {
    id?: true;
    customerId?: true;
    orderNumber?: true;
    status?: true;
    paymentStatus?: true;
    fulfillmentStatus?: true;
    priorityLevel?: true;
    subtotal?: true;
    taxAmount?: true;
    shippingAmount?: true;
    discountAmount?: true;
    totalAmount?: true;
    paymentMethod?: true;
    paymentReference?: true;
    shippingCarrier?: true;
    shippingMethod?: true;
    trackingNumber?: true;
    estimatedDelivery?: true;
    actualDelivery?: true;
    assignedToStaffId?: true;
    internalNotes?: true;
    customerNotes?: true;
    cancellationReason?: true;
    cancelledAt?: true;
    refundAmount?: true;
    refundReason?: true;
    refundedAt?: true;
    orderDate?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OrderCountAggregateInputType = {
    id?: true;
    customerId?: true;
    orderNumber?: true;
    status?: true;
    paymentStatus?: true;
    fulfillmentStatus?: true;
    priorityLevel?: true;
    subtotal?: true;
    taxAmount?: true;
    shippingAmount?: true;
    discountAmount?: true;
    totalAmount?: true;
    paymentMethod?: true;
    paymentReference?: true;
    shippingAddress?: true;
    billingAddress?: true;
    shippingCarrier?: true;
    shippingMethod?: true;
    trackingNumber?: true;
    estimatedDelivery?: true;
    actualDelivery?: true;
    assignedToStaffId?: true;
    internalNotes?: true;
    customerNotes?: true;
    cancellationReason?: true;
    cancelledAt?: true;
    refundAmount?: true;
    refundReason?: true;
    refundedAt?: true;
    orderDate?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type OrderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Orders
     **/
    _count?: true | OrderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrderAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrderSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrderMaxAggregateInputType;
  };

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
    [P in keyof T & keyof AggregateOrder]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>;
  };

  export type OrderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
    orderBy?:
      | OrderOrderByWithAggregationInput
      | OrderOrderByWithAggregationInput[];
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum;
    having?: OrderScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrderCountAggregateInputType | true;
    _avg?: OrderAvgAggregateInputType;
    _sum?: OrderSumAggregateInputType;
    _min?: OrderMinAggregateInputType;
    _max?: OrderMaxAggregateInputType;
  };

  export type OrderGroupByOutputType = {
    id: string;
    customerId: string;
    orderNumber: string;
    status: $Enums.OrderStatus;
    paymentStatus: $Enums.PaymentStatus;
    fulfillmentStatus: $Enums.FulfillmentStatus;
    priorityLevel: $Enums.OrderPriority;
    subtotal: number;
    taxAmount: number;
    shippingAmount: number;
    discountAmount: number;
    totalAmount: number;
    paymentMethod: string | null;
    paymentReference: string | null;
    shippingAddress: JsonValue;
    billingAddress: JsonValue;
    shippingCarrier: string | null;
    shippingMethod: string | null;
    trackingNumber: string | null;
    estimatedDelivery: Date | null;
    actualDelivery: Date | null;
    assignedToStaffId: string | null;
    internalNotes: string | null;
    customerNotes: string | null;
    cancellationReason: string | null;
    cancelledAt: Date | null;
    refundAmount: number | null;
    refundReason: string | null;
    refundedAt: Date | null;
    orderDate: Date;
    createdAt: Date;
    updatedAt: Date;
    _count: OrderCountAggregateOutputType | null;
    _avg: OrderAvgAggregateOutputType | null;
    _sum: OrderSumAggregateOutputType | null;
    _min: OrderMinAggregateOutputType | null;
    _max: OrderMaxAggregateOutputType | null;
  };

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrderGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof OrderGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>;
        }
      >
    >;

  export type OrderSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      customerId?: boolean;
      orderNumber?: boolean;
      status?: boolean;
      paymentStatus?: boolean;
      fulfillmentStatus?: boolean;
      priorityLevel?: boolean;
      subtotal?: boolean;
      taxAmount?: boolean;
      shippingAmount?: boolean;
      discountAmount?: boolean;
      totalAmount?: boolean;
      paymentMethod?: boolean;
      paymentReference?: boolean;
      shippingAddress?: boolean;
      billingAddress?: boolean;
      shippingCarrier?: boolean;
      shippingMethod?: boolean;
      trackingNumber?: boolean;
      estimatedDelivery?: boolean;
      actualDelivery?: boolean;
      assignedToStaffId?: boolean;
      internalNotes?: boolean;
      customerNotes?: boolean;
      cancellationReason?: boolean;
      cancelledAt?: boolean;
      refundAmount?: boolean;
      refundReason?: boolean;
      refundedAt?: boolean;
      orderDate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      customer?: boolean | CustomerDefaultArgs<ExtArgs>;
      orderItems?: boolean | Order$orderItemsArgs<ExtArgs>;
      _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["order"]
  >;

  export type OrderSelectScalar = {
    id?: boolean;
    customerId?: boolean;
    orderNumber?: boolean;
    status?: boolean;
    paymentStatus?: boolean;
    fulfillmentStatus?: boolean;
    priorityLevel?: boolean;
    subtotal?: boolean;
    taxAmount?: boolean;
    shippingAmount?: boolean;
    discountAmount?: boolean;
    totalAmount?: boolean;
    paymentMethod?: boolean;
    paymentReference?: boolean;
    shippingAddress?: boolean;
    billingAddress?: boolean;
    shippingCarrier?: boolean;
    shippingMethod?: boolean;
    trackingNumber?: boolean;
    estimatedDelivery?: boolean;
    actualDelivery?: boolean;
    assignedToStaffId?: boolean;
    internalNotes?: boolean;
    customerNotes?: boolean;
    cancellationReason?: boolean;
    cancelledAt?: boolean;
    refundAmount?: boolean;
    refundReason?: boolean;
    refundedAt?: boolean;
    orderDate?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type OrderInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>;
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>;
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $OrderPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Order";
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>;
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        customerId: string;
        orderNumber: string;
        status: $Enums.OrderStatus;
        paymentStatus: $Enums.PaymentStatus;
        fulfillmentStatus: $Enums.FulfillmentStatus;
        priorityLevel: $Enums.OrderPriority;
        subtotal: number;
        taxAmount: number;
        shippingAmount: number;
        discountAmount: number;
        totalAmount: number;
        paymentMethod: string | null;
        paymentReference: string | null;
        shippingAddress: Prisma.JsonValue;
        billingAddress: Prisma.JsonValue;
        shippingCarrier: string | null;
        shippingMethod: string | null;
        trackingNumber: string | null;
        estimatedDelivery: Date | null;
        actualDelivery: Date | null;
        assignedToStaffId: string | null;
        internalNotes: string | null;
        customerNotes: string | null;
        cancellationReason: string | null;
        cancelledAt: Date | null;
        refundAmount: number | null;
        refundReason: string | null;
        refundedAt: Date | null;
        orderDate: Date;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["order"]
    >;
    composites: {};
  };

  type OrderGetPayload<
    S extends boolean | null | undefined | OrderDefaultArgs,
  > = $Result.GetResult<Prisma.$OrderPayload, S>;

  type OrderCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<OrderFindManyArgs, "select" | "include" | "distinct"> & {
    select?: OrderCountAggregateInputType | true;
  };

  export interface OrderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Order"];
      meta: { name: "Order" };
    };
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     *
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     *
     */
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     *
     */
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Orders that matches the filter.
     * @param {OrderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const order = await prisma.order.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OrderFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Order.
     * @param {OrderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const order = await prisma.order.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: OrderAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
     **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrderAggregateArgs>(
      args: Subset<T, OrderAggregateArgs>,
    ): Prisma.PrismaPromise<GetOrderAggregateType<T>>;

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs["orderBy"] }
        : { orderBy?: OrderGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetOrderGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Order model
     */
    readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CustomerDefaultArgs<ExtArgs>>,
    ): Prisma__CustomerClient<
      | $Result.GetResult<
          Prisma.$CustomerPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$orderItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", "String">;
    readonly customerId: FieldRef<"Order", "String">;
    readonly orderNumber: FieldRef<"Order", "String">;
    readonly status: FieldRef<"Order", "OrderStatus">;
    readonly paymentStatus: FieldRef<"Order", "PaymentStatus">;
    readonly fulfillmentStatus: FieldRef<"Order", "FulfillmentStatus">;
    readonly priorityLevel: FieldRef<"Order", "OrderPriority">;
    readonly subtotal: FieldRef<"Order", "Float">;
    readonly taxAmount: FieldRef<"Order", "Float">;
    readonly shippingAmount: FieldRef<"Order", "Float">;
    readonly discountAmount: FieldRef<"Order", "Float">;
    readonly totalAmount: FieldRef<"Order", "Float">;
    readonly paymentMethod: FieldRef<"Order", "String">;
    readonly paymentReference: FieldRef<"Order", "String">;
    readonly shippingAddress: FieldRef<"Order", "Json">;
    readonly billingAddress: FieldRef<"Order", "Json">;
    readonly shippingCarrier: FieldRef<"Order", "String">;
    readonly shippingMethod: FieldRef<"Order", "String">;
    readonly trackingNumber: FieldRef<"Order", "String">;
    readonly estimatedDelivery: FieldRef<"Order", "DateTime">;
    readonly actualDelivery: FieldRef<"Order", "DateTime">;
    readonly assignedToStaffId: FieldRef<"Order", "String">;
    readonly internalNotes: FieldRef<"Order", "String">;
    readonly customerNotes: FieldRef<"Order", "String">;
    readonly cancellationReason: FieldRef<"Order", "String">;
    readonly cancelledAt: FieldRef<"Order", "DateTime">;
    readonly refundAmount: FieldRef<"Order", "Float">;
    readonly refundReason: FieldRef<"Order", "String">;
    readonly refundedAt: FieldRef<"Order", "DateTime">;
    readonly orderDate: FieldRef<"Order", "DateTime">;
    readonly createdAt: FieldRef<"Order", "DateTime">;
    readonly updatedAt: FieldRef<"Order", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order create
   */
  export type OrderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>;
  };

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[];
  };

  /**
   * Order update
   */
  export type OrderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>;
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>;
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput;
  };

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput;
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>;
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>;
  };

  /**
   * Order delete
   */
  export type OrderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput;
  };

  /**
   * Order findRaw
   */
  export type OrderFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Order aggregateRaw
   */
  export type OrderAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    where?: OrderItemWhereInput;
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    cursor?: OrderItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * Order without action
   */
  export type OrderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
  };

  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null;
    _avg: OrderItemAvgAggregateOutputType | null;
    _sum: OrderItemSumAggregateOutputType | null;
    _min: OrderItemMinAggregateOutputType | null;
    _max: OrderItemMaxAggregateOutputType | null;
  };

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null;
    priceAtPurchase: number | null;
    quantityShipped: number | null;
    quantityRefunded: number | null;
  };

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null;
    priceAtPurchase: number | null;
    quantityShipped: number | null;
    quantityRefunded: number | null;
  };

  export type OrderItemMinAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    productId: string | null;
    quantity: number | null;
    priceAtPurchase: number | null;
    productNameAtPurchase: string | null;
    quantityShipped: number | null;
    quantityRefunded: number | null;
  };

  export type OrderItemMaxAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    productId: string | null;
    quantity: number | null;
    priceAtPurchase: number | null;
    productNameAtPurchase: string | null;
    quantityShipped: number | null;
    quantityRefunded: number | null;
  };

  export type OrderItemCountAggregateOutputType = {
    id: number;
    orderId: number;
    productId: number;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: number;
    quantityShipped: number;
    quantityRefunded: number;
    _all: number;
  };

  export type OrderItemAvgAggregateInputType = {
    quantity?: true;
    priceAtPurchase?: true;
    quantityShipped?: true;
    quantityRefunded?: true;
  };

  export type OrderItemSumAggregateInputType = {
    quantity?: true;
    priceAtPurchase?: true;
    quantityShipped?: true;
    quantityRefunded?: true;
  };

  export type OrderItemMinAggregateInputType = {
    id?: true;
    orderId?: true;
    productId?: true;
    quantity?: true;
    priceAtPurchase?: true;
    productNameAtPurchase?: true;
    quantityShipped?: true;
    quantityRefunded?: true;
  };

  export type OrderItemMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    productId?: true;
    quantity?: true;
    priceAtPurchase?: true;
    productNameAtPurchase?: true;
    quantityShipped?: true;
    quantityRefunded?: true;
  };

  export type OrderItemCountAggregateInputType = {
    id?: true;
    orderId?: true;
    productId?: true;
    quantity?: true;
    priceAtPurchase?: true;
    productNameAtPurchase?: true;
    quantityShipped?: true;
    quantityRefunded?: true;
    _all?: true;
  };

  export type OrderItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned OrderItems
     **/
    _count?: true | OrderItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrderItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrderItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrderItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrderItemMaxAggregateInputType;
  };

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
    [P in keyof T & keyof AggregateOrderItem]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>;
  };

  export type OrderItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderItemWhereInput;
    orderBy?:
      | OrderItemOrderByWithAggregationInput
      | OrderItemOrderByWithAggregationInput[];
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum;
    having?: OrderItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrderItemCountAggregateInputType | true;
    _avg?: OrderItemAvgAggregateInputType;
    _sum?: OrderItemSumAggregateInputType;
    _min?: OrderItemMinAggregateInputType;
    _max?: OrderItemMaxAggregateInputType;
  };

  export type OrderItemGroupByOutputType = {
    id: string;
    orderId: string;
    productId: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped: number;
    quantityRefunded: number;
    _count: OrderItemCountAggregateOutputType | null;
    _avg: OrderItemAvgAggregateOutputType | null;
    _sum: OrderItemSumAggregateOutputType | null;
    _min: OrderItemMinAggregateOutputType | null;
    _max: OrderItemMaxAggregateOutputType | null;
  };

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrderItemGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof OrderItemGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>;
        }
      >
    >;

  export type OrderItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      productId?: boolean;
      quantity?: boolean;
      priceAtPurchase?: boolean;
      productNameAtPurchase?: boolean;
      quantityShipped?: boolean;
      quantityRefunded?: boolean;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
      product?: boolean | ProductDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orderItem"]
  >;

  export type OrderItemSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    productId?: boolean;
    quantity?: boolean;
    priceAtPurchase?: boolean;
    productNameAtPurchase?: boolean;
    quantityShipped?: boolean;
    quantityRefunded?: boolean;
  };

  export type OrderItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
    product?: boolean | ProductDefaultArgs<ExtArgs>;
  };

  export type $OrderItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "OrderItem";
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>;
      product: Prisma.$ProductPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        orderId: string;
        productId: string;
        quantity: number;
        priceAtPurchase: number;
        productNameAtPurchase: string;
        quantityShipped: number;
        quantityRefunded: number;
      },
      ExtArgs["result"]["orderItem"]
    >;
    composites: {};
  };

  type OrderItemGetPayload<
    S extends boolean | null | undefined | OrderItemDefaultArgs,
  > = $Result.GetResult<Prisma.$OrderItemPayload, S>;

  type OrderItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<OrderItemFindManyArgs, "select" | "include" | "distinct"> & {
    select?: OrderItemCountAggregateInputType | true;
  };

  export interface OrderItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["OrderItem"];
      meta: { name: "OrderItem" };
    };
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(
      args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(
      args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>,
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     *
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrderItemFindManyArgs>(
      args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     *
     */
    create<T extends OrderItemCreateArgs>(
      args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>,
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrderItemCreateManyArgs>(
      args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     *
     */
    delete<T extends OrderItemDeleteArgs>(
      args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>,
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrderItemUpdateArgs>(
      args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>,
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(
      args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrderItemUpdateManyArgs>(
      args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(
      args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>,
    ): Prisma__OrderItemClient<
      $Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more OrderItems that matches the filter.
     * @param {OrderItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const orderItem = await prisma.orderItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OrderItemFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a OrderItem.
     * @param {OrderItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const orderItem = await prisma.orderItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: OrderItemAggregateRawArgs,
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
     **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrderItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrderItemAggregateArgs>(
      args: Subset<T, OrderItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>;

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs["orderBy"] }
        : { orderBy?: OrderItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetOrderItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the OrderItem model
     */
    readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>,
    ): Prisma__OrderClient<
      | $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ProductDefaultArgs<ExtArgs>>,
    ): Prisma__ProductClient<
      | $Result.GetResult<
          Prisma.$ProductPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", "String">;
    readonly orderId: FieldRef<"OrderItem", "String">;
    readonly productId: FieldRef<"OrderItem", "String">;
    readonly quantity: FieldRef<"OrderItem", "Int">;
    readonly priceAtPurchase: FieldRef<"OrderItem", "Float">;
    readonly productNameAtPurchase: FieldRef<"OrderItem", "String">;
    readonly quantityShipped: FieldRef<"OrderItem", "Int">;
    readonly quantityRefunded: FieldRef<"OrderItem", "Int">;
  }

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>;
  };

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[];
  };

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>;
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<
      OrderItemUpdateManyMutationInput,
      OrderItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput;
  };

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput;
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>;
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>;
  };

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput;
  };

  /**
   * OrderItem findRaw
   */
  export type OrderItemFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * OrderItem aggregateRaw
   */
  export type OrderItemAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const RoleScalarFieldEnum: {
    id: "id";
    roleName: "roleName";
    hierarchyLevel: "hierarchyLevel";
    permissions: "permissions";
    description: "description";
    isActive: "isActive";
    maxUsers: "maxUsers";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type RoleScalarFieldEnum =
    (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

  export const StaffUserScalarFieldEnum: {
    id: "id";
    roleId: "roleId";
    firstName: "firstName";
    lastName: "lastName";
    email: "email";
    phone: "phone";
    passwordHash: "passwordHash";
    isActive: "isActive";
    emailVerified: "emailVerified";
    twoFactorEnabled: "twoFactorEnabled";
    twoFactorSecret: "twoFactorSecret";
    lastLogin: "lastLogin";
    lastLoginIp: "lastLoginIp";
    loginAttempts: "loginAttempts";
    lockedUntil: "lockedUntil";
    passwordChangedAt: "passwordChangedAt";
    mustChangePassword: "mustChangePassword";
    avatar: "avatar";
    timezone: "timezone";
    language: "language";
    canAccessAdmin: "canAccessAdmin";
    departmentAccess: "departmentAccess";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    createdBy: "createdBy";
    lastModifiedBy: "lastModifiedBy";
  };

  export type StaffUserScalarFieldEnum =
    (typeof StaffUserScalarFieldEnum)[keyof typeof StaffUserScalarFieldEnum];

  export const SettingScalarFieldEnum: {
    id: "id";
    settingKey: "settingKey";
    settingValue: "settingValue";
    category: "category";
    subcategory: "subcategory";
    dataType: "dataType";
    isEncrypted: "isEncrypted";
    isPublic: "isPublic";
    displayName: "displayName";
    description: "description";
    defaultValue: "defaultValue";
    validation: "validation";
    sortOrder: "sortOrder";
    isVisible: "isVisible";
    isEditable: "isEditable";
    updatedBy: "updatedBy";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type SettingScalarFieldEnum =
    (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum];

  export const BannerScalarFieldEnum: {
    id: "id";
    title: "title";
    subtitle: "subtitle";
    description: "description";
    imageUrl: "imageUrl";
    videoUrl: "videoUrl";
    altText: "altText";
    buttonText: "buttonText";
    buttonUrl: "buttonUrl";
    linkTarget: "linkTarget";
    position: "position";
    displayType: "displayType";
    priority: "priority";
    showOnMobile: "showOnMobile";
    showOnTablet: "showOnTablet";
    showOnDesktop: "showOnDesktop";
    backgroundColor: "backgroundColor";
    textColor: "textColor";
    borderColor: "borderColor";
    startDate: "startDate";
    endDate: "endDate";
    isActive: "isActive";
    clickCount: "clickCount";
    viewCount: "viewCount";
    metaTitle: "metaTitle";
    metaDescription: "metaDescription";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    createdBy: "createdBy";
  };

  export type BannerScalarFieldEnum =
    (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum];

  export const HeroSlideScalarFieldEnum: {
    id: "id";
    title: "title";
    subtitle: "subtitle";
    description: "description";
    imageUrl: "imageUrl";
    mobileImageUrl: "mobileImageUrl";
    altText: "altText";
    primaryButtonText: "primaryButtonText";
    primaryButtonUrl: "primaryButtonUrl";
    secondaryButtonText: "secondaryButtonText";
    secondaryButtonUrl: "secondaryButtonUrl";
    textPosition: "textPosition";
    overlayOpacity: "overlayOpacity";
    textColor: "textColor";
    animationType: "animationType";
    displayDuration: "displayDuration";
    sortOrder: "sortOrder";
    isActive: "isActive";
    startDate: "startDate";
    endDate: "endDate";
    showOnMobile: "showOnMobile";
    showOnTablet: "showOnTablet";
    showOnDesktop: "showOnDesktop";
    clickCount: "clickCount";
    viewCount: "viewCount";
    metaTitle: "metaTitle";
    metaDescription: "metaDescription";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    createdBy: "createdBy";
  };

  export type HeroSlideScalarFieldEnum =
    (typeof HeroSlideScalarFieldEnum)[keyof typeof HeroSlideScalarFieldEnum];

  export const SiteCustomizationScalarFieldEnum: {
    id: "id";
    siteName: "siteName";
    siteDescription: "siteDescription";
    logoUrl: "logoUrl";
    faviconUrl: "faviconUrl";
    primaryColor: "primaryColor";
    secondaryColor: "secondaryColor";
    accentColor: "accentColor";
    backgroundColor: "backgroundColor";
    textColor: "textColor";
    linkColor: "linkColor";
    primaryFont: "primaryFont";
    secondaryFont: "secondaryFont";
    fontSize: "fontSize";
    headerStyle: "headerStyle";
    footerStyle: "footerStyle";
    borderRadius: "borderRadius";
    showSearch: "showSearch";
    showWishlist: "showWishlist";
    showCompare: "showCompare";
    showReviews: "showReviews";
    enableChat: "enableChat";
    enableNewsletter: "enableNewsletter";
    contactEmail: "contactEmail";
    contactPhone: "contactPhone";
    contactAddress: "contactAddress";
    businessHours: "businessHours";
    socialMedia: "socialMedia";
    metaTitle: "metaTitle";
    metaDescription: "metaDescription";
    metaKeywords: "metaKeywords";
    googleAnalytics: "googleAnalytics";
    privacyPolicyUrl: "privacyPolicyUrl";
    termsOfServiceUrl: "termsOfServiceUrl";
    isActive: "isActive";
    updatedAt: "updatedAt";
    updatedBy: "updatedBy";
  };

  export type SiteCustomizationScalarFieldEnum =
    (typeof SiteCustomizationScalarFieldEnum)[keyof typeof SiteCustomizationScalarFieldEnum];

  export const ActivityLogScalarFieldEnum: {
    id: "id";
    staffUserId: "staffUserId";
    actionType: "actionType";
    description: "description";
    entityType: "entityType";
    entityId: "entityId";
    ipAddress: "ipAddress";
    userAgent: "userAgent";
    metadata: "metadata";
    success: "success";
    errorMessage: "errorMessage";
    timestamp: "timestamp";
  };

  export type ActivityLogScalarFieldEnum =
    (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum];

  export const CustomerScalarFieldEnum: {
    id: "id";
    firstName: "firstName";
    lastName: "lastName";
    email: "email";
    phone: "phone";
    passwordHash: "passwordHash";
    emailVerified: "emailVerified";
    isActive: "isActive";
    professionalTier: "professionalTier";
    discountRate: "discountRate";
    totalOrders: "totalOrders";
    totalSpent: "totalSpent";
    lifetimeValue: "lifetimeValue";
    averageOrderValue: "averageOrderValue";
    preferredPaymentMethod: "preferredPaymentMethod";
    communicationPrefs: "communicationPrefs";
    timezone: "timezone";
    customerType: "customerType";
    riskLevel: "riskLevel";
    notes: "notes";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    lastLogin: "lastLogin";
  };

  export type CustomerScalarFieldEnum =
    (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum];

  export const AddressScalarFieldEnum: {
    id: "id";
    customerId: "customerId";
    firstName: "firstName";
    lastName: "lastName";
    company: "company";
    address1: "address1";
    address2: "address2";
    city: "city";
    state: "state";
    postalCode: "postalCode";
    country: "country";
    phone: "phone";
    type: "type";
    isDefault: "isDefault";
    isValidated: "isValidated";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type AddressScalarFieldEnum =
    (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum];

  export const CategoryScalarFieldEnum: {
    id: "id";
    name: "name";
    slug: "slug";
    description: "description";
    iconClass: "iconClass";
    parentId: "parentId";
    image: "image";
    sortOrder: "sortOrder";
    isActive: "isActive";
    isFeatured: "isFeatured";
    metaTitle: "metaTitle";
    metaDescription: "metaDescription";
    productCount: "productCount";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type CategoryScalarFieldEnum =
    (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum];

  export const ProductScalarFieldEnum: {
    id: "id";
    categoryId: "categoryId";
    name: "name";
    description: "description";
    shortDescription: "shortDescription";
    regularPrice: "regularPrice";
    salePrice: "salePrice";
    costPrice: "costPrice";
    sku: "sku";
    partNumber: "partNumber";
    upc: "upc";
    stockQuantity: "stockQuantity";
    lowStockThreshold: "lowStockThreshold";
    trackInventory: "trackInventory";
    allowBackorders: "allowBackorders";
    professionalOnly: "professionalOnly";
    minimumOrderQuantity: "minimumOrderQuantity";
    status: "status";
    approvalStatus: "approvalStatus";
    featured: "featured";
    onSale: "onSale";
    newProduct: "newProduct";
    metaTitle: "metaTitle";
    metaDescription: "metaDescription";
    tags: "tags";
    weight: "weight";
    dimensions: "dimensions";
    requiresShipping: "requiresShipping";
    shippingClass: "shippingClass";
    version: "version";
    createdBy: "createdBy";
    lastModifiedBy: "lastModifiedBy";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ProductScalarFieldEnum =
    (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum];

  export const ProductReviewScalarFieldEnum: {
    id: "id";
    productId: "productId";
    customerId: "customerId";
    rating: "rating";
    title: "title";
    content: "content";
    verified: "verified";
    helpful: "helpful";
    status: "status";
    moderatedBy: "moderatedBy";
    moderatedAt: "moderatedAt";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ProductReviewScalarFieldEnum =
    (typeof ProductReviewScalarFieldEnum)[keyof typeof ProductReviewScalarFieldEnum];

  export const OrderScalarFieldEnum: {
    id: "id";
    customerId: "customerId";
    orderNumber: "orderNumber";
    status: "status";
    paymentStatus: "paymentStatus";
    fulfillmentStatus: "fulfillmentStatus";
    priorityLevel: "priorityLevel";
    subtotal: "subtotal";
    taxAmount: "taxAmount";
    shippingAmount: "shippingAmount";
    discountAmount: "discountAmount";
    totalAmount: "totalAmount";
    paymentMethod: "paymentMethod";
    paymentReference: "paymentReference";
    shippingAddress: "shippingAddress";
    billingAddress: "billingAddress";
    shippingCarrier: "shippingCarrier";
    shippingMethod: "shippingMethod";
    trackingNumber: "trackingNumber";
    estimatedDelivery: "estimatedDelivery";
    actualDelivery: "actualDelivery";
    assignedToStaffId: "assignedToStaffId";
    internalNotes: "internalNotes";
    customerNotes: "customerNotes";
    cancellationReason: "cancellationReason";
    cancelledAt: "cancelledAt";
    refundAmount: "refundAmount";
    refundReason: "refundReason";
    refundedAt: "refundedAt";
    orderDate: "orderDate";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type OrderScalarFieldEnum =
    (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum];

  export const OrderItemScalarFieldEnum: {
    id: "id";
    orderId: "orderId";
    productId: "productId";
    quantity: "quantity";
    priceAtPurchase: "priceAtPurchase";
    productNameAtPurchase: "productNameAtPurchase";
    quantityShipped: "quantityShipped";
    quantityRefunded: "quantityRefunded";
  };

  export type OrderItemScalarFieldEnum =
    (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Json"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'SettingDataType'
   */
  export type EnumSettingDataTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "SettingDataType">;

  /**
   * Reference to a field of type 'SettingDataType[]'
   */
  export type ListEnumSettingDataTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "SettingDataType[]">;

  /**
   * Reference to a field of type 'BannerPosition'
   */
  export type EnumBannerPositionFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "BannerPosition"
  >;

  /**
   * Reference to a field of type 'BannerPosition[]'
   */
  export type ListEnumBannerPositionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "BannerPosition[]">;

  /**
   * Reference to a field of type 'BannerType'
   */
  export type EnumBannerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "BannerType"
  >;

  /**
   * Reference to a field of type 'BannerType[]'
   */
  export type ListEnumBannerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "BannerType[]"
  >;

  /**
   * Reference to a field of type 'SlideTextPosition'
   */
  export type EnumSlideTextPositionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "SlideTextPosition">;

  /**
   * Reference to a field of type 'SlideTextPosition[]'
   */
  export type ListEnumSlideTextPositionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "SlideTextPosition[]">;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Reference to a field of type 'SlideAnimation'
   */
  export type EnumSlideAnimationFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "SlideAnimation"
  >;

  /**
   * Reference to a field of type 'SlideAnimation[]'
   */
  export type ListEnumSlideAnimationFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "SlideAnimation[]">;

  /**
   * Reference to a field of type 'ProfessionalTier'
   */
  export type EnumProfessionalTierFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ProfessionalTier">;

  /**
   * Reference to a field of type 'ProfessionalTier[]'
   */
  export type ListEnumProfessionalTierFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ProfessionalTier[]">;

  /**
   * Reference to a field of type 'CustomerType'
   */
  export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "CustomerType"
  >;

  /**
   * Reference to a field of type 'CustomerType[]'
   */
  export type ListEnumCustomerTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "CustomerType[]">;

  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "RiskLevel"
  >;

  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "RiskLevel[]"
  >;

  /**
   * Reference to a field of type 'AddressType'
   */
  export type EnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "AddressType"
  >;

  /**
   * Reference to a field of type 'AddressType[]'
   */
  export type ListEnumAddressTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "AddressType[]">;

  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ProductStatus"
  >;

  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ProductStatus[]">;

  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ApprovalStatus"
  >;

  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ApprovalStatus[]">;

  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ReviewStatus"
  >;

  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ReviewStatus[]">;

  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "OrderStatus"
  >;

  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "OrderStatus[]">;

  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "PaymentStatus"
  >;

  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "PaymentStatus[]">;

  /**
   * Reference to a field of type 'FulfillmentStatus'
   */
  export type EnumFulfillmentStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "FulfillmentStatus">;

  /**
   * Reference to a field of type 'FulfillmentStatus[]'
   */
  export type ListEnumFulfillmentStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "FulfillmentStatus[]">;

  /**
   * Reference to a field of type 'OrderPriority'
   */
  export type EnumOrderPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "OrderPriority"
  >;

  /**
   * Reference to a field of type 'OrderPriority[]'
   */
  export type ListEnumOrderPriorityFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "OrderPriority[]">;

  /**
   * Deep Input Types
   */

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[];
    OR?: RoleWhereInput[];
    NOT?: RoleWhereInput | RoleWhereInput[];
    id?: StringFilter<"Role"> | string;
    roleName?: StringFilter<"Role"> | string;
    hierarchyLevel?: IntFilter<"Role"> | number;
    permissions?: JsonFilter<"Role">;
    description?: StringNullableFilter<"Role"> | string | null;
    isActive?: BoolFilter<"Role"> | boolean;
    maxUsers?: IntNullableFilter<"Role"> | number | null;
    createdAt?: DateTimeFilter<"Role"> | Date | string;
    updatedAt?: DateTimeFilter<"Role"> | Date | string;
    staffUsers?: StaffUserListRelationFilter;
  };

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    hierarchyLevel?: SortOrder;
    permissions?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    maxUsers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    staffUsers?: StaffUserOrderByRelationAggregateInput;
  };

  export type RoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      roleName?: string;
      hierarchyLevel?: number;
      AND?: RoleWhereInput | RoleWhereInput[];
      OR?: RoleWhereInput[];
      NOT?: RoleWhereInput | RoleWhereInput[];
      permissions?: JsonFilter<"Role">;
      description?: StringNullableFilter<"Role"> | string | null;
      isActive?: BoolFilter<"Role"> | boolean;
      maxUsers?: IntNullableFilter<"Role"> | number | null;
      createdAt?: DateTimeFilter<"Role"> | Date | string;
      updatedAt?: DateTimeFilter<"Role"> | Date | string;
      staffUsers?: StaffUserListRelationFilter;
    },
    "id" | "roleName" | "hierarchyLevel"
  >;

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    hierarchyLevel?: SortOrder;
    permissions?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    maxUsers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RoleCountOrderByAggregateInput;
    _avg?: RoleAvgOrderByAggregateInput;
    _max?: RoleMaxOrderByAggregateInput;
    _min?: RoleMinOrderByAggregateInput;
    _sum?: RoleSumOrderByAggregateInput;
  };

  export type RoleScalarWhereWithAggregatesInput = {
    AND?:
      | RoleScalarWhereWithAggregatesInput
      | RoleScalarWhereWithAggregatesInput[];
    OR?: RoleScalarWhereWithAggregatesInput[];
    NOT?:
      | RoleScalarWhereWithAggregatesInput
      | RoleScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Role"> | string;
    roleName?: StringWithAggregatesFilter<"Role"> | string;
    hierarchyLevel?: IntWithAggregatesFilter<"Role"> | number;
    permissions?: JsonWithAggregatesFilter<"Role">;
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null;
    isActive?: BoolWithAggregatesFilter<"Role"> | boolean;
    maxUsers?: IntNullableWithAggregatesFilter<"Role"> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string;
  };

  export type StaffUserWhereInput = {
    AND?: StaffUserWhereInput | StaffUserWhereInput[];
    OR?: StaffUserWhereInput[];
    NOT?: StaffUserWhereInput | StaffUserWhereInput[];
    id?: StringFilter<"StaffUser"> | string;
    roleId?: StringFilter<"StaffUser"> | string;
    firstName?: StringFilter<"StaffUser"> | string;
    lastName?: StringFilter<"StaffUser"> | string;
    email?: StringFilter<"StaffUser"> | string;
    phone?: StringNullableFilter<"StaffUser"> | string | null;
    passwordHash?: StringFilter<"StaffUser"> | string;
    isActive?: BoolFilter<"StaffUser"> | boolean;
    emailVerified?: BoolFilter<"StaffUser"> | boolean;
    twoFactorEnabled?: BoolFilter<"StaffUser"> | boolean;
    twoFactorSecret?: StringNullableFilter<"StaffUser"> | string | null;
    lastLogin?: DateTimeNullableFilter<"StaffUser"> | Date | string | null;
    lastLoginIp?: StringNullableFilter<"StaffUser"> | string | null;
    loginAttempts?: IntFilter<"StaffUser"> | number;
    lockedUntil?: DateTimeNullableFilter<"StaffUser"> | Date | string | null;
    passwordChangedAt?: DateTimeFilter<"StaffUser"> | Date | string;
    mustChangePassword?: BoolFilter<"StaffUser"> | boolean;
    avatar?: StringNullableFilter<"StaffUser"> | string | null;
    timezone?: StringFilter<"StaffUser"> | string;
    language?: StringFilter<"StaffUser"> | string;
    canAccessAdmin?: BoolFilter<"StaffUser"> | boolean;
    departmentAccess?: StringNullableListFilter<"StaffUser">;
    createdAt?: DateTimeFilter<"StaffUser"> | Date | string;
    updatedAt?: DateTimeFilter<"StaffUser"> | Date | string;
    createdBy?: StringNullableFilter<"StaffUser"> | string | null;
    lastModifiedBy?: StringNullableFilter<"StaffUser"> | string | null;
    role?: XOR<RoleRelationFilter, RoleWhereInput>;
    activityLogs?: ActivityLogListRelationFilter;
  };

  export type StaffUserOrderByWithRelationInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    lastLogin?: SortOrder;
    lastLoginIp?: SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrder;
    passwordChangedAt?: SortOrder;
    mustChangePassword?: SortOrder;
    avatar?: SortOrder;
    timezone?: SortOrder;
    language?: SortOrder;
    canAccessAdmin?: SortOrder;
    departmentAccess?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
    role?: RoleOrderByWithRelationInput;
    activityLogs?: ActivityLogOrderByRelationAggregateInput;
  };

  export type StaffUserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: StaffUserWhereInput | StaffUserWhereInput[];
      OR?: StaffUserWhereInput[];
      NOT?: StaffUserWhereInput | StaffUserWhereInput[];
      roleId?: StringFilter<"StaffUser"> | string;
      firstName?: StringFilter<"StaffUser"> | string;
      lastName?: StringFilter<"StaffUser"> | string;
      phone?: StringNullableFilter<"StaffUser"> | string | null;
      passwordHash?: StringFilter<"StaffUser"> | string;
      isActive?: BoolFilter<"StaffUser"> | boolean;
      emailVerified?: BoolFilter<"StaffUser"> | boolean;
      twoFactorEnabled?: BoolFilter<"StaffUser"> | boolean;
      twoFactorSecret?: StringNullableFilter<"StaffUser"> | string | null;
      lastLogin?: DateTimeNullableFilter<"StaffUser"> | Date | string | null;
      lastLoginIp?: StringNullableFilter<"StaffUser"> | string | null;
      loginAttempts?: IntFilter<"StaffUser"> | number;
      lockedUntil?: DateTimeNullableFilter<"StaffUser"> | Date | string | null;
      passwordChangedAt?: DateTimeFilter<"StaffUser"> | Date | string;
      mustChangePassword?: BoolFilter<"StaffUser"> | boolean;
      avatar?: StringNullableFilter<"StaffUser"> | string | null;
      timezone?: StringFilter<"StaffUser"> | string;
      language?: StringFilter<"StaffUser"> | string;
      canAccessAdmin?: BoolFilter<"StaffUser"> | boolean;
      departmentAccess?: StringNullableListFilter<"StaffUser">;
      createdAt?: DateTimeFilter<"StaffUser"> | Date | string;
      updatedAt?: DateTimeFilter<"StaffUser"> | Date | string;
      createdBy?: StringNullableFilter<"StaffUser"> | string | null;
      lastModifiedBy?: StringNullableFilter<"StaffUser"> | string | null;
      role?: XOR<RoleRelationFilter, RoleWhereInput>;
      activityLogs?: ActivityLogListRelationFilter;
    },
    "id" | "email"
  >;

  export type StaffUserOrderByWithAggregationInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    lastLogin?: SortOrder;
    lastLoginIp?: SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrder;
    passwordChangedAt?: SortOrder;
    mustChangePassword?: SortOrder;
    avatar?: SortOrder;
    timezone?: SortOrder;
    language?: SortOrder;
    canAccessAdmin?: SortOrder;
    departmentAccess?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
    _count?: StaffUserCountOrderByAggregateInput;
    _avg?: StaffUserAvgOrderByAggregateInput;
    _max?: StaffUserMaxOrderByAggregateInput;
    _min?: StaffUserMinOrderByAggregateInput;
    _sum?: StaffUserSumOrderByAggregateInput;
  };

  export type StaffUserScalarWhereWithAggregatesInput = {
    AND?:
      | StaffUserScalarWhereWithAggregatesInput
      | StaffUserScalarWhereWithAggregatesInput[];
    OR?: StaffUserScalarWhereWithAggregatesInput[];
    NOT?:
      | StaffUserScalarWhereWithAggregatesInput
      | StaffUserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"StaffUser"> | string;
    roleId?: StringWithAggregatesFilter<"StaffUser"> | string;
    firstName?: StringWithAggregatesFilter<"StaffUser"> | string;
    lastName?: StringWithAggregatesFilter<"StaffUser"> | string;
    email?: StringWithAggregatesFilter<"StaffUser"> | string;
    phone?: StringNullableWithAggregatesFilter<"StaffUser"> | string | null;
    passwordHash?: StringWithAggregatesFilter<"StaffUser"> | string;
    isActive?: BoolWithAggregatesFilter<"StaffUser"> | boolean;
    emailVerified?: BoolWithAggregatesFilter<"StaffUser"> | boolean;
    twoFactorEnabled?: BoolWithAggregatesFilter<"StaffUser"> | boolean;
    twoFactorSecret?:
      | StringNullableWithAggregatesFilter<"StaffUser">
      | string
      | null;
    lastLogin?:
      | DateTimeNullableWithAggregatesFilter<"StaffUser">
      | Date
      | string
      | null;
    lastLoginIp?:
      | StringNullableWithAggregatesFilter<"StaffUser">
      | string
      | null;
    loginAttempts?: IntWithAggregatesFilter<"StaffUser"> | number;
    lockedUntil?:
      | DateTimeNullableWithAggregatesFilter<"StaffUser">
      | Date
      | string
      | null;
    passwordChangedAt?:
      | DateTimeWithAggregatesFilter<"StaffUser">
      | Date
      | string;
    mustChangePassword?: BoolWithAggregatesFilter<"StaffUser"> | boolean;
    avatar?: StringNullableWithAggregatesFilter<"StaffUser"> | string | null;
    timezone?: StringWithAggregatesFilter<"StaffUser"> | string;
    language?: StringWithAggregatesFilter<"StaffUser"> | string;
    canAccessAdmin?: BoolWithAggregatesFilter<"StaffUser"> | boolean;
    departmentAccess?: StringNullableListFilter<"StaffUser">;
    createdAt?: DateTimeWithAggregatesFilter<"StaffUser"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"StaffUser"> | Date | string;
    createdBy?: StringNullableWithAggregatesFilter<"StaffUser"> | string | null;
    lastModifiedBy?:
      | StringNullableWithAggregatesFilter<"StaffUser">
      | string
      | null;
  };

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[];
    OR?: SettingWhereInput[];
    NOT?: SettingWhereInput | SettingWhereInput[];
    id?: StringFilter<"Setting"> | string;
    settingKey?: StringFilter<"Setting"> | string;
    settingValue?: JsonFilter<"Setting">;
    category?: StringFilter<"Setting"> | string;
    subcategory?: StringNullableFilter<"Setting"> | string | null;
    dataType?: EnumSettingDataTypeFilter<"Setting"> | $Enums.SettingDataType;
    isEncrypted?: BoolFilter<"Setting"> | boolean;
    isPublic?: BoolFilter<"Setting"> | boolean;
    displayName?: StringNullableFilter<"Setting"> | string | null;
    description?: StringNullableFilter<"Setting"> | string | null;
    defaultValue?: JsonNullableFilter<"Setting">;
    validation?: JsonNullableFilter<"Setting">;
    sortOrder?: IntFilter<"Setting"> | number;
    isVisible?: BoolFilter<"Setting"> | boolean;
    isEditable?: BoolFilter<"Setting"> | boolean;
    updatedBy?: StringNullableFilter<"Setting"> | string | null;
    createdAt?: DateTimeFilter<"Setting"> | Date | string;
    updatedAt?: DateTimeFilter<"Setting"> | Date | string;
  };

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder;
    settingKey?: SortOrder;
    settingValue?: SortOrder;
    category?: SortOrder;
    subcategory?: SortOrder;
    dataType?: SortOrder;
    isEncrypted?: SortOrder;
    isPublic?: SortOrder;
    displayName?: SortOrder;
    description?: SortOrder;
    defaultValue?: SortOrder;
    validation?: SortOrder;
    sortOrder?: SortOrder;
    isVisible?: SortOrder;
    isEditable?: SortOrder;
    updatedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SettingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      settingKey?: string;
      AND?: SettingWhereInput | SettingWhereInput[];
      OR?: SettingWhereInput[];
      NOT?: SettingWhereInput | SettingWhereInput[];
      settingValue?: JsonFilter<"Setting">;
      category?: StringFilter<"Setting"> | string;
      subcategory?: StringNullableFilter<"Setting"> | string | null;
      dataType?: EnumSettingDataTypeFilter<"Setting"> | $Enums.SettingDataType;
      isEncrypted?: BoolFilter<"Setting"> | boolean;
      isPublic?: BoolFilter<"Setting"> | boolean;
      displayName?: StringNullableFilter<"Setting"> | string | null;
      description?: StringNullableFilter<"Setting"> | string | null;
      defaultValue?: JsonNullableFilter<"Setting">;
      validation?: JsonNullableFilter<"Setting">;
      sortOrder?: IntFilter<"Setting"> | number;
      isVisible?: BoolFilter<"Setting"> | boolean;
      isEditable?: BoolFilter<"Setting"> | boolean;
      updatedBy?: StringNullableFilter<"Setting"> | string | null;
      createdAt?: DateTimeFilter<"Setting"> | Date | string;
      updatedAt?: DateTimeFilter<"Setting"> | Date | string;
    },
    "id" | "settingKey"
  >;

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder;
    settingKey?: SortOrder;
    settingValue?: SortOrder;
    category?: SortOrder;
    subcategory?: SortOrder;
    dataType?: SortOrder;
    isEncrypted?: SortOrder;
    isPublic?: SortOrder;
    displayName?: SortOrder;
    description?: SortOrder;
    defaultValue?: SortOrder;
    validation?: SortOrder;
    sortOrder?: SortOrder;
    isVisible?: SortOrder;
    isEditable?: SortOrder;
    updatedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SettingCountOrderByAggregateInput;
    _avg?: SettingAvgOrderByAggregateInput;
    _max?: SettingMaxOrderByAggregateInput;
    _min?: SettingMinOrderByAggregateInput;
    _sum?: SettingSumOrderByAggregateInput;
  };

  export type SettingScalarWhereWithAggregatesInput = {
    AND?:
      | SettingScalarWhereWithAggregatesInput
      | SettingScalarWhereWithAggregatesInput[];
    OR?: SettingScalarWhereWithAggregatesInput[];
    NOT?:
      | SettingScalarWhereWithAggregatesInput
      | SettingScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Setting"> | string;
    settingKey?: StringWithAggregatesFilter<"Setting"> | string;
    settingValue?: JsonWithAggregatesFilter<"Setting">;
    category?: StringWithAggregatesFilter<"Setting"> | string;
    subcategory?: StringNullableWithAggregatesFilter<"Setting"> | string | null;
    dataType?:
      | EnumSettingDataTypeWithAggregatesFilter<"Setting">
      | $Enums.SettingDataType;
    isEncrypted?: BoolWithAggregatesFilter<"Setting"> | boolean;
    isPublic?: BoolWithAggregatesFilter<"Setting"> | boolean;
    displayName?: StringNullableWithAggregatesFilter<"Setting"> | string | null;
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null;
    defaultValue?: JsonNullableWithAggregatesFilter<"Setting">;
    validation?: JsonNullableWithAggregatesFilter<"Setting">;
    sortOrder?: IntWithAggregatesFilter<"Setting"> | number;
    isVisible?: BoolWithAggregatesFilter<"Setting"> | boolean;
    isEditable?: BoolWithAggregatesFilter<"Setting"> | boolean;
    updatedBy?: StringNullableWithAggregatesFilter<"Setting"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string;
  };

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[];
    OR?: BannerWhereInput[];
    NOT?: BannerWhereInput | BannerWhereInput[];
    id?: StringFilter<"Banner"> | string;
    title?: StringFilter<"Banner"> | string;
    subtitle?: StringNullableFilter<"Banner"> | string | null;
    description?: StringNullableFilter<"Banner"> | string | null;
    imageUrl?: StringNullableFilter<"Banner"> | string | null;
    videoUrl?: StringNullableFilter<"Banner"> | string | null;
    altText?: StringNullableFilter<"Banner"> | string | null;
    buttonText?: StringNullableFilter<"Banner"> | string | null;
    buttonUrl?: StringNullableFilter<"Banner"> | string | null;
    linkTarget?: StringFilter<"Banner"> | string;
    position?: EnumBannerPositionFilter<"Banner"> | $Enums.BannerPosition;
    displayType?: EnumBannerTypeFilter<"Banner"> | $Enums.BannerType;
    priority?: IntFilter<"Banner"> | number;
    showOnMobile?: BoolFilter<"Banner"> | boolean;
    showOnTablet?: BoolFilter<"Banner"> | boolean;
    showOnDesktop?: BoolFilter<"Banner"> | boolean;
    backgroundColor?: StringNullableFilter<"Banner"> | string | null;
    textColor?: StringNullableFilter<"Banner"> | string | null;
    borderColor?: StringNullableFilter<"Banner"> | string | null;
    startDate?: DateTimeNullableFilter<"Banner"> | Date | string | null;
    endDate?: DateTimeNullableFilter<"Banner"> | Date | string | null;
    isActive?: BoolFilter<"Banner"> | boolean;
    clickCount?: IntFilter<"Banner"> | number;
    viewCount?: IntFilter<"Banner"> | number;
    metaTitle?: StringNullableFilter<"Banner"> | string | null;
    metaDescription?: StringNullableFilter<"Banner"> | string | null;
    createdAt?: DateTimeFilter<"Banner"> | Date | string;
    updatedAt?: DateTimeFilter<"Banner"> | Date | string;
    createdBy?: StringNullableFilter<"Banner"> | string | null;
  };

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    videoUrl?: SortOrder;
    altText?: SortOrder;
    buttonText?: SortOrder;
    buttonUrl?: SortOrder;
    linkTarget?: SortOrder;
    position?: SortOrder;
    displayType?: SortOrder;
    priority?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    borderColor?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    isActive?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type BannerWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: BannerWhereInput | BannerWhereInput[];
      OR?: BannerWhereInput[];
      NOT?: BannerWhereInput | BannerWhereInput[];
      title?: StringFilter<"Banner"> | string;
      subtitle?: StringNullableFilter<"Banner"> | string | null;
      description?: StringNullableFilter<"Banner"> | string | null;
      imageUrl?: StringNullableFilter<"Banner"> | string | null;
      videoUrl?: StringNullableFilter<"Banner"> | string | null;
      altText?: StringNullableFilter<"Banner"> | string | null;
      buttonText?: StringNullableFilter<"Banner"> | string | null;
      buttonUrl?: StringNullableFilter<"Banner"> | string | null;
      linkTarget?: StringFilter<"Banner"> | string;
      position?: EnumBannerPositionFilter<"Banner"> | $Enums.BannerPosition;
      displayType?: EnumBannerTypeFilter<"Banner"> | $Enums.BannerType;
      priority?: IntFilter<"Banner"> | number;
      showOnMobile?: BoolFilter<"Banner"> | boolean;
      showOnTablet?: BoolFilter<"Banner"> | boolean;
      showOnDesktop?: BoolFilter<"Banner"> | boolean;
      backgroundColor?: StringNullableFilter<"Banner"> | string | null;
      textColor?: StringNullableFilter<"Banner"> | string | null;
      borderColor?: StringNullableFilter<"Banner"> | string | null;
      startDate?: DateTimeNullableFilter<"Banner"> | Date | string | null;
      endDate?: DateTimeNullableFilter<"Banner"> | Date | string | null;
      isActive?: BoolFilter<"Banner"> | boolean;
      clickCount?: IntFilter<"Banner"> | number;
      viewCount?: IntFilter<"Banner"> | number;
      metaTitle?: StringNullableFilter<"Banner"> | string | null;
      metaDescription?: StringNullableFilter<"Banner"> | string | null;
      createdAt?: DateTimeFilter<"Banner"> | Date | string;
      updatedAt?: DateTimeFilter<"Banner"> | Date | string;
      createdBy?: StringNullableFilter<"Banner"> | string | null;
    },
    "id"
  >;

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    videoUrl?: SortOrder;
    altText?: SortOrder;
    buttonText?: SortOrder;
    buttonUrl?: SortOrder;
    linkTarget?: SortOrder;
    position?: SortOrder;
    displayType?: SortOrder;
    priority?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    borderColor?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    isActive?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
    _count?: BannerCountOrderByAggregateInput;
    _avg?: BannerAvgOrderByAggregateInput;
    _max?: BannerMaxOrderByAggregateInput;
    _min?: BannerMinOrderByAggregateInput;
    _sum?: BannerSumOrderByAggregateInput;
  };

  export type BannerScalarWhereWithAggregatesInput = {
    AND?:
      | BannerScalarWhereWithAggregatesInput
      | BannerScalarWhereWithAggregatesInput[];
    OR?: BannerScalarWhereWithAggregatesInput[];
    NOT?:
      | BannerScalarWhereWithAggregatesInput
      | BannerScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Banner"> | string;
    title?: StringWithAggregatesFilter<"Banner"> | string;
    subtitle?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    description?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    imageUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    videoUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    altText?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    buttonText?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    buttonUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    linkTarget?: StringWithAggregatesFilter<"Banner"> | string;
    position?:
      | EnumBannerPositionWithAggregatesFilter<"Banner">
      | $Enums.BannerPosition;
    displayType?:
      | EnumBannerTypeWithAggregatesFilter<"Banner">
      | $Enums.BannerType;
    priority?: IntWithAggregatesFilter<"Banner"> | number;
    showOnMobile?: BoolWithAggregatesFilter<"Banner"> | boolean;
    showOnTablet?: BoolWithAggregatesFilter<"Banner"> | boolean;
    showOnDesktop?: BoolWithAggregatesFilter<"Banner"> | boolean;
    backgroundColor?:
      | StringNullableWithAggregatesFilter<"Banner">
      | string
      | null;
    textColor?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    borderColor?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    startDate?:
      | DateTimeNullableWithAggregatesFilter<"Banner">
      | Date
      | string
      | null;
    endDate?:
      | DateTimeNullableWithAggregatesFilter<"Banner">
      | Date
      | string
      | null;
    isActive?: BoolWithAggregatesFilter<"Banner"> | boolean;
    clickCount?: IntWithAggregatesFilter<"Banner"> | number;
    viewCount?: IntWithAggregatesFilter<"Banner"> | number;
    metaTitle?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
    metaDescription?:
      | StringNullableWithAggregatesFilter<"Banner">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string;
    createdBy?: StringNullableWithAggregatesFilter<"Banner"> | string | null;
  };

  export type HeroSlideWhereInput = {
    AND?: HeroSlideWhereInput | HeroSlideWhereInput[];
    OR?: HeroSlideWhereInput[];
    NOT?: HeroSlideWhereInput | HeroSlideWhereInput[];
    id?: StringFilter<"HeroSlide"> | string;
    title?: StringFilter<"HeroSlide"> | string;
    subtitle?: StringNullableFilter<"HeroSlide"> | string | null;
    description?: StringNullableFilter<"HeroSlide"> | string | null;
    imageUrl?: StringFilter<"HeroSlide"> | string;
    mobileImageUrl?: StringNullableFilter<"HeroSlide"> | string | null;
    altText?: StringNullableFilter<"HeroSlide"> | string | null;
    primaryButtonText?: StringNullableFilter<"HeroSlide"> | string | null;
    primaryButtonUrl?: StringNullableFilter<"HeroSlide"> | string | null;
    secondaryButtonText?: StringNullableFilter<"HeroSlide"> | string | null;
    secondaryButtonUrl?: StringNullableFilter<"HeroSlide"> | string | null;
    textPosition?:
      | EnumSlideTextPositionFilter<"HeroSlide">
      | $Enums.SlideTextPosition;
    overlayOpacity?: FloatFilter<"HeroSlide"> | number;
    textColor?: StringFilter<"HeroSlide"> | string;
    animationType?:
      | EnumSlideAnimationFilter<"HeroSlide">
      | $Enums.SlideAnimation;
    displayDuration?: IntFilter<"HeroSlide"> | number;
    sortOrder?: IntFilter<"HeroSlide"> | number;
    isActive?: BoolFilter<"HeroSlide"> | boolean;
    startDate?: DateTimeNullableFilter<"HeroSlide"> | Date | string | null;
    endDate?: DateTimeNullableFilter<"HeroSlide"> | Date | string | null;
    showOnMobile?: BoolFilter<"HeroSlide"> | boolean;
    showOnTablet?: BoolFilter<"HeroSlide"> | boolean;
    showOnDesktop?: BoolFilter<"HeroSlide"> | boolean;
    clickCount?: IntFilter<"HeroSlide"> | number;
    viewCount?: IntFilter<"HeroSlide"> | number;
    metaTitle?: StringNullableFilter<"HeroSlide"> | string | null;
    metaDescription?: StringNullableFilter<"HeroSlide"> | string | null;
    createdAt?: DateTimeFilter<"HeroSlide"> | Date | string;
    updatedAt?: DateTimeFilter<"HeroSlide"> | Date | string;
    createdBy?: StringNullableFilter<"HeroSlide"> | string | null;
  };

  export type HeroSlideOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    mobileImageUrl?: SortOrder;
    altText?: SortOrder;
    primaryButtonText?: SortOrder;
    primaryButtonUrl?: SortOrder;
    secondaryButtonText?: SortOrder;
    secondaryButtonUrl?: SortOrder;
    textPosition?: SortOrder;
    overlayOpacity?: SortOrder;
    textColor?: SortOrder;
    animationType?: SortOrder;
    displayDuration?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type HeroSlideWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: HeroSlideWhereInput | HeroSlideWhereInput[];
      OR?: HeroSlideWhereInput[];
      NOT?: HeroSlideWhereInput | HeroSlideWhereInput[];
      title?: StringFilter<"HeroSlide"> | string;
      subtitle?: StringNullableFilter<"HeroSlide"> | string | null;
      description?: StringNullableFilter<"HeroSlide"> | string | null;
      imageUrl?: StringFilter<"HeroSlide"> | string;
      mobileImageUrl?: StringNullableFilter<"HeroSlide"> | string | null;
      altText?: StringNullableFilter<"HeroSlide"> | string | null;
      primaryButtonText?: StringNullableFilter<"HeroSlide"> | string | null;
      primaryButtonUrl?: StringNullableFilter<"HeroSlide"> | string | null;
      secondaryButtonText?: StringNullableFilter<"HeroSlide"> | string | null;
      secondaryButtonUrl?: StringNullableFilter<"HeroSlide"> | string | null;
      textPosition?:
        | EnumSlideTextPositionFilter<"HeroSlide">
        | $Enums.SlideTextPosition;
      overlayOpacity?: FloatFilter<"HeroSlide"> | number;
      textColor?: StringFilter<"HeroSlide"> | string;
      animationType?:
        | EnumSlideAnimationFilter<"HeroSlide">
        | $Enums.SlideAnimation;
      displayDuration?: IntFilter<"HeroSlide"> | number;
      sortOrder?: IntFilter<"HeroSlide"> | number;
      isActive?: BoolFilter<"HeroSlide"> | boolean;
      startDate?: DateTimeNullableFilter<"HeroSlide"> | Date | string | null;
      endDate?: DateTimeNullableFilter<"HeroSlide"> | Date | string | null;
      showOnMobile?: BoolFilter<"HeroSlide"> | boolean;
      showOnTablet?: BoolFilter<"HeroSlide"> | boolean;
      showOnDesktop?: BoolFilter<"HeroSlide"> | boolean;
      clickCount?: IntFilter<"HeroSlide"> | number;
      viewCount?: IntFilter<"HeroSlide"> | number;
      metaTitle?: StringNullableFilter<"HeroSlide"> | string | null;
      metaDescription?: StringNullableFilter<"HeroSlide"> | string | null;
      createdAt?: DateTimeFilter<"HeroSlide"> | Date | string;
      updatedAt?: DateTimeFilter<"HeroSlide"> | Date | string;
      createdBy?: StringNullableFilter<"HeroSlide"> | string | null;
    },
    "id"
  >;

  export type HeroSlideOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    mobileImageUrl?: SortOrder;
    altText?: SortOrder;
    primaryButtonText?: SortOrder;
    primaryButtonUrl?: SortOrder;
    secondaryButtonText?: SortOrder;
    secondaryButtonUrl?: SortOrder;
    textPosition?: SortOrder;
    overlayOpacity?: SortOrder;
    textColor?: SortOrder;
    animationType?: SortOrder;
    displayDuration?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
    _count?: HeroSlideCountOrderByAggregateInput;
    _avg?: HeroSlideAvgOrderByAggregateInput;
    _max?: HeroSlideMaxOrderByAggregateInput;
    _min?: HeroSlideMinOrderByAggregateInput;
    _sum?: HeroSlideSumOrderByAggregateInput;
  };

  export type HeroSlideScalarWhereWithAggregatesInput = {
    AND?:
      | HeroSlideScalarWhereWithAggregatesInput
      | HeroSlideScalarWhereWithAggregatesInput[];
    OR?: HeroSlideScalarWhereWithAggregatesInput[];
    NOT?:
      | HeroSlideScalarWhereWithAggregatesInput
      | HeroSlideScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"HeroSlide"> | string;
    title?: StringWithAggregatesFilter<"HeroSlide"> | string;
    subtitle?: StringNullableWithAggregatesFilter<"HeroSlide"> | string | null;
    description?:
      | StringNullableWithAggregatesFilter<"HeroSlide">
      | string
      | null;
    imageUrl?: StringWithAggregatesFilter<"HeroSlide"> | string;
    mobileImageUrl?:
      | StringNullableWithAggregatesFilter<"HeroSlide">
      | string
      | null;
    altText?: StringNullableWithAggregatesFilter<"HeroSlide"> | string | null;
    primaryButtonText?:
      | StringNullableWithAggregatesFilter<"HeroSlide">
      | string
      | null;
    primaryButtonUrl?:
      | StringNullableWithAggregatesFilter<"HeroSlide">
      | string
      | null;
    secondaryButtonText?:
      | StringNullableWithAggregatesFilter<"HeroSlide">
      | string
      | null;
    secondaryButtonUrl?:
      | StringNullableWithAggregatesFilter<"HeroSlide">
      | string
      | null;
    textPosition?:
      | EnumSlideTextPositionWithAggregatesFilter<"HeroSlide">
      | $Enums.SlideTextPosition;
    overlayOpacity?: FloatWithAggregatesFilter<"HeroSlide"> | number;
    textColor?: StringWithAggregatesFilter<"HeroSlide"> | string;
    animationType?:
      | EnumSlideAnimationWithAggregatesFilter<"HeroSlide">
      | $Enums.SlideAnimation;
    displayDuration?: IntWithAggregatesFilter<"HeroSlide"> | number;
    sortOrder?: IntWithAggregatesFilter<"HeroSlide"> | number;
    isActive?: BoolWithAggregatesFilter<"HeroSlide"> | boolean;
    startDate?:
      | DateTimeNullableWithAggregatesFilter<"HeroSlide">
      | Date
      | string
      | null;
    endDate?:
      | DateTimeNullableWithAggregatesFilter<"HeroSlide">
      | Date
      | string
      | null;
    showOnMobile?: BoolWithAggregatesFilter<"HeroSlide"> | boolean;
    showOnTablet?: BoolWithAggregatesFilter<"HeroSlide"> | boolean;
    showOnDesktop?: BoolWithAggregatesFilter<"HeroSlide"> | boolean;
    clickCount?: IntWithAggregatesFilter<"HeroSlide"> | number;
    viewCount?: IntWithAggregatesFilter<"HeroSlide"> | number;
    metaTitle?: StringNullableWithAggregatesFilter<"HeroSlide"> | string | null;
    metaDescription?:
      | StringNullableWithAggregatesFilter<"HeroSlide">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"HeroSlide"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"HeroSlide"> | Date | string;
    createdBy?: StringNullableWithAggregatesFilter<"HeroSlide"> | string | null;
  };

  export type SiteCustomizationWhereInput = {
    AND?: SiteCustomizationWhereInput | SiteCustomizationWhereInput[];
    OR?: SiteCustomizationWhereInput[];
    NOT?: SiteCustomizationWhereInput | SiteCustomizationWhereInput[];
    id?: StringFilter<"SiteCustomization"> | string;
    siteName?: StringFilter<"SiteCustomization"> | string;
    siteDescription?: StringNullableFilter<"SiteCustomization"> | string | null;
    logoUrl?: StringNullableFilter<"SiteCustomization"> | string | null;
    faviconUrl?: StringNullableFilter<"SiteCustomization"> | string | null;
    primaryColor?: StringFilter<"SiteCustomization"> | string;
    secondaryColor?: StringFilter<"SiteCustomization"> | string;
    accentColor?: StringFilter<"SiteCustomization"> | string;
    backgroundColor?: StringFilter<"SiteCustomization"> | string;
    textColor?: StringFilter<"SiteCustomization"> | string;
    linkColor?: StringFilter<"SiteCustomization"> | string;
    primaryFont?: StringFilter<"SiteCustomization"> | string;
    secondaryFont?: StringFilter<"SiteCustomization"> | string;
    fontSize?: StringFilter<"SiteCustomization"> | string;
    headerStyle?: StringFilter<"SiteCustomization"> | string;
    footerStyle?: StringFilter<"SiteCustomization"> | string;
    borderRadius?: StringFilter<"SiteCustomization"> | string;
    showSearch?: BoolFilter<"SiteCustomization"> | boolean;
    showWishlist?: BoolFilter<"SiteCustomization"> | boolean;
    showCompare?: BoolFilter<"SiteCustomization"> | boolean;
    showReviews?: BoolFilter<"SiteCustomization"> | boolean;
    enableChat?: BoolFilter<"SiteCustomization"> | boolean;
    enableNewsletter?: BoolFilter<"SiteCustomization"> | boolean;
    contactEmail?: StringNullableFilter<"SiteCustomization"> | string | null;
    contactPhone?: StringNullableFilter<"SiteCustomization"> | string | null;
    contactAddress?: JsonNullableFilter<"SiteCustomization">;
    businessHours?: JsonNullableFilter<"SiteCustomization">;
    socialMedia?: JsonNullableFilter<"SiteCustomization">;
    metaTitle?: StringNullableFilter<"SiteCustomization"> | string | null;
    metaDescription?: StringNullableFilter<"SiteCustomization"> | string | null;
    metaKeywords?: StringNullableFilter<"SiteCustomization"> | string | null;
    googleAnalytics?: StringNullableFilter<"SiteCustomization"> | string | null;
    privacyPolicyUrl?:
      | StringNullableFilter<"SiteCustomization">
      | string
      | null;
    termsOfServiceUrl?:
      | StringNullableFilter<"SiteCustomization">
      | string
      | null;
    isActive?: BoolFilter<"SiteCustomization"> | boolean;
    updatedAt?: DateTimeFilter<"SiteCustomization"> | Date | string;
    updatedBy?: StringNullableFilter<"SiteCustomization"> | string | null;
  };

  export type SiteCustomizationOrderByWithRelationInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrder;
    logoUrl?: SortOrder;
    faviconUrl?: SortOrder;
    primaryColor?: SortOrder;
    secondaryColor?: SortOrder;
    accentColor?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    linkColor?: SortOrder;
    primaryFont?: SortOrder;
    secondaryFont?: SortOrder;
    fontSize?: SortOrder;
    headerStyle?: SortOrder;
    footerStyle?: SortOrder;
    borderRadius?: SortOrder;
    showSearch?: SortOrder;
    showWishlist?: SortOrder;
    showCompare?: SortOrder;
    showReviews?: SortOrder;
    enableChat?: SortOrder;
    enableNewsletter?: SortOrder;
    contactEmail?: SortOrder;
    contactPhone?: SortOrder;
    contactAddress?: SortOrder;
    businessHours?: SortOrder;
    socialMedia?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    metaKeywords?: SortOrder;
    googleAnalytics?: SortOrder;
    privacyPolicyUrl?: SortOrder;
    termsOfServiceUrl?: SortOrder;
    isActive?: SortOrder;
    updatedAt?: SortOrder;
    updatedBy?: SortOrder;
  };

  export type SiteCustomizationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SiteCustomizationWhereInput | SiteCustomizationWhereInput[];
      OR?: SiteCustomizationWhereInput[];
      NOT?: SiteCustomizationWhereInput | SiteCustomizationWhereInput[];
      siteName?: StringFilter<"SiteCustomization"> | string;
      siteDescription?:
        | StringNullableFilter<"SiteCustomization">
        | string
        | null;
      logoUrl?: StringNullableFilter<"SiteCustomization"> | string | null;
      faviconUrl?: StringNullableFilter<"SiteCustomization"> | string | null;
      primaryColor?: StringFilter<"SiteCustomization"> | string;
      secondaryColor?: StringFilter<"SiteCustomization"> | string;
      accentColor?: StringFilter<"SiteCustomization"> | string;
      backgroundColor?: StringFilter<"SiteCustomization"> | string;
      textColor?: StringFilter<"SiteCustomization"> | string;
      linkColor?: StringFilter<"SiteCustomization"> | string;
      primaryFont?: StringFilter<"SiteCustomization"> | string;
      secondaryFont?: StringFilter<"SiteCustomization"> | string;
      fontSize?: StringFilter<"SiteCustomization"> | string;
      headerStyle?: StringFilter<"SiteCustomization"> | string;
      footerStyle?: StringFilter<"SiteCustomization"> | string;
      borderRadius?: StringFilter<"SiteCustomization"> | string;
      showSearch?: BoolFilter<"SiteCustomization"> | boolean;
      showWishlist?: BoolFilter<"SiteCustomization"> | boolean;
      showCompare?: BoolFilter<"SiteCustomization"> | boolean;
      showReviews?: BoolFilter<"SiteCustomization"> | boolean;
      enableChat?: BoolFilter<"SiteCustomization"> | boolean;
      enableNewsletter?: BoolFilter<"SiteCustomization"> | boolean;
      contactEmail?: StringNullableFilter<"SiteCustomization"> | string | null;
      contactPhone?: StringNullableFilter<"SiteCustomization"> | string | null;
      contactAddress?: JsonNullableFilter<"SiteCustomization">;
      businessHours?: JsonNullableFilter<"SiteCustomization">;
      socialMedia?: JsonNullableFilter<"SiteCustomization">;
      metaTitle?: StringNullableFilter<"SiteCustomization"> | string | null;
      metaDescription?:
        | StringNullableFilter<"SiteCustomization">
        | string
        | null;
      metaKeywords?: StringNullableFilter<"SiteCustomization"> | string | null;
      googleAnalytics?:
        | StringNullableFilter<"SiteCustomization">
        | string
        | null;
      privacyPolicyUrl?:
        | StringNullableFilter<"SiteCustomization">
        | string
        | null;
      termsOfServiceUrl?:
        | StringNullableFilter<"SiteCustomization">
        | string
        | null;
      isActive?: BoolFilter<"SiteCustomization"> | boolean;
      updatedAt?: DateTimeFilter<"SiteCustomization"> | Date | string;
      updatedBy?: StringNullableFilter<"SiteCustomization"> | string | null;
    },
    "id"
  >;

  export type SiteCustomizationOrderByWithAggregationInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrder;
    logoUrl?: SortOrder;
    faviconUrl?: SortOrder;
    primaryColor?: SortOrder;
    secondaryColor?: SortOrder;
    accentColor?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    linkColor?: SortOrder;
    primaryFont?: SortOrder;
    secondaryFont?: SortOrder;
    fontSize?: SortOrder;
    headerStyle?: SortOrder;
    footerStyle?: SortOrder;
    borderRadius?: SortOrder;
    showSearch?: SortOrder;
    showWishlist?: SortOrder;
    showCompare?: SortOrder;
    showReviews?: SortOrder;
    enableChat?: SortOrder;
    enableNewsletter?: SortOrder;
    contactEmail?: SortOrder;
    contactPhone?: SortOrder;
    contactAddress?: SortOrder;
    businessHours?: SortOrder;
    socialMedia?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    metaKeywords?: SortOrder;
    googleAnalytics?: SortOrder;
    privacyPolicyUrl?: SortOrder;
    termsOfServiceUrl?: SortOrder;
    isActive?: SortOrder;
    updatedAt?: SortOrder;
    updatedBy?: SortOrder;
    _count?: SiteCustomizationCountOrderByAggregateInput;
    _max?: SiteCustomizationMaxOrderByAggregateInput;
    _min?: SiteCustomizationMinOrderByAggregateInput;
  };

  export type SiteCustomizationScalarWhereWithAggregatesInput = {
    AND?:
      | SiteCustomizationScalarWhereWithAggregatesInput
      | SiteCustomizationScalarWhereWithAggregatesInput[];
    OR?: SiteCustomizationScalarWhereWithAggregatesInput[];
    NOT?:
      | SiteCustomizationScalarWhereWithAggregatesInput
      | SiteCustomizationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    siteName?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    siteDescription?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    logoUrl?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    faviconUrl?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    primaryColor?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    secondaryColor?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    accentColor?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    backgroundColor?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    textColor?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    linkColor?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    primaryFont?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    secondaryFont?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    fontSize?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    headerStyle?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    footerStyle?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    borderRadius?: StringWithAggregatesFilter<"SiteCustomization"> | string;
    showSearch?: BoolWithAggregatesFilter<"SiteCustomization"> | boolean;
    showWishlist?: BoolWithAggregatesFilter<"SiteCustomization"> | boolean;
    showCompare?: BoolWithAggregatesFilter<"SiteCustomization"> | boolean;
    showReviews?: BoolWithAggregatesFilter<"SiteCustomization"> | boolean;
    enableChat?: BoolWithAggregatesFilter<"SiteCustomization"> | boolean;
    enableNewsletter?: BoolWithAggregatesFilter<"SiteCustomization"> | boolean;
    contactEmail?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    contactPhone?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    contactAddress?: JsonNullableWithAggregatesFilter<"SiteCustomization">;
    businessHours?: JsonNullableWithAggregatesFilter<"SiteCustomization">;
    socialMedia?: JsonNullableWithAggregatesFilter<"SiteCustomization">;
    metaTitle?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    metaDescription?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    metaKeywords?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    googleAnalytics?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    privacyPolicyUrl?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    termsOfServiceUrl?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
    isActive?: BoolWithAggregatesFilter<"SiteCustomization"> | boolean;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"SiteCustomization">
      | Date
      | string;
    updatedBy?:
      | StringNullableWithAggregatesFilter<"SiteCustomization">
      | string
      | null;
  };

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[];
    OR?: ActivityLogWhereInput[];
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[];
    id?: StringFilter<"ActivityLog"> | string;
    staffUserId?: StringFilter<"ActivityLog"> | string;
    actionType?: StringFilter<"ActivityLog"> | string;
    description?: StringFilter<"ActivityLog"> | string;
    entityType?: StringNullableFilter<"ActivityLog"> | string | null;
    entityId?: StringNullableFilter<"ActivityLog"> | string | null;
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null;
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null;
    metadata?: JsonNullableFilter<"ActivityLog">;
    success?: BoolFilter<"ActivityLog"> | boolean;
    errorMessage?: StringNullableFilter<"ActivityLog"> | string | null;
    timestamp?: DateTimeFilter<"ActivityLog"> | Date | string;
    staffUser?: XOR<StaffUserRelationFilter, StaffUserWhereInput>;
  };

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder;
    staffUserId?: SortOrder;
    actionType?: SortOrder;
    description?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    metadata?: SortOrder;
    success?: SortOrder;
    errorMessage?: SortOrder;
    timestamp?: SortOrder;
    staffUser?: StaffUserOrderByWithRelationInput;
  };

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ActivityLogWhereInput | ActivityLogWhereInput[];
      OR?: ActivityLogWhereInput[];
      NOT?: ActivityLogWhereInput | ActivityLogWhereInput[];
      staffUserId?: StringFilter<"ActivityLog"> | string;
      actionType?: StringFilter<"ActivityLog"> | string;
      description?: StringFilter<"ActivityLog"> | string;
      entityType?: StringNullableFilter<"ActivityLog"> | string | null;
      entityId?: StringNullableFilter<"ActivityLog"> | string | null;
      ipAddress?: StringNullableFilter<"ActivityLog"> | string | null;
      userAgent?: StringNullableFilter<"ActivityLog"> | string | null;
      metadata?: JsonNullableFilter<"ActivityLog">;
      success?: BoolFilter<"ActivityLog"> | boolean;
      errorMessage?: StringNullableFilter<"ActivityLog"> | string | null;
      timestamp?: DateTimeFilter<"ActivityLog"> | Date | string;
      staffUser?: XOR<StaffUserRelationFilter, StaffUserWhereInput>;
    },
    "id"
  >;

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder;
    staffUserId?: SortOrder;
    actionType?: SortOrder;
    description?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    metadata?: SortOrder;
    success?: SortOrder;
    errorMessage?: SortOrder;
    timestamp?: SortOrder;
    _count?: ActivityLogCountOrderByAggregateInput;
    _max?: ActivityLogMaxOrderByAggregateInput;
    _min?: ActivityLogMinOrderByAggregateInput;
  };

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?:
      | ActivityLogScalarWhereWithAggregatesInput
      | ActivityLogScalarWhereWithAggregatesInput[];
    OR?: ActivityLogScalarWhereWithAggregatesInput[];
    NOT?:
      | ActivityLogScalarWhereWithAggregatesInput
      | ActivityLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ActivityLog"> | string;
    staffUserId?: StringWithAggregatesFilter<"ActivityLog"> | string;
    actionType?: StringWithAggregatesFilter<"ActivityLog"> | string;
    description?: StringWithAggregatesFilter<"ActivityLog"> | string;
    entityType?:
      | StringNullableWithAggregatesFilter<"ActivityLog">
      | string
      | null;
    entityId?:
      | StringNullableWithAggregatesFilter<"ActivityLog">
      | string
      | null;
    ipAddress?:
      | StringNullableWithAggregatesFilter<"ActivityLog">
      | string
      | null;
    userAgent?:
      | StringNullableWithAggregatesFilter<"ActivityLog">
      | string
      | null;
    metadata?: JsonNullableWithAggregatesFilter<"ActivityLog">;
    success?: BoolWithAggregatesFilter<"ActivityLog"> | boolean;
    errorMessage?:
      | StringNullableWithAggregatesFilter<"ActivityLog">
      | string
      | null;
    timestamp?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string;
  };

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[];
    OR?: CustomerWhereInput[];
    NOT?: CustomerWhereInput | CustomerWhereInput[];
    id?: StringFilter<"Customer"> | string;
    firstName?: StringFilter<"Customer"> | string;
    lastName?: StringFilter<"Customer"> | string;
    email?: StringFilter<"Customer"> | string;
    phone?: StringNullableFilter<"Customer"> | string | null;
    passwordHash?: StringFilter<"Customer"> | string;
    emailVerified?: BoolFilter<"Customer"> | boolean;
    isActive?: BoolFilter<"Customer"> | boolean;
    professionalTier?:
      | EnumProfessionalTierFilter<"Customer">
      | $Enums.ProfessionalTier;
    discountRate?: FloatFilter<"Customer"> | number;
    businessInfo?: XOR<
      BusinessInfoNullableCompositeFilter,
      BusinessInfoObjectEqualityInput
    > | null;
    totalOrders?: IntFilter<"Customer"> | number;
    totalSpent?: FloatFilter<"Customer"> | number;
    lifetimeValue?: FloatFilter<"Customer"> | number;
    averageOrderValue?: FloatFilter<"Customer"> | number;
    preferredPaymentMethod?: StringNullableFilter<"Customer"> | string | null;
    communicationPrefs?: JsonNullableFilter<"Customer">;
    timezone?: StringFilter<"Customer"> | string;
    customerType?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFilter<"Customer"> | $Enums.RiskLevel;
    notes?: StringNullableFilter<"Customer"> | string | null;
    createdAt?: DateTimeFilter<"Customer"> | Date | string;
    updatedAt?: DateTimeFilter<"Customer"> | Date | string;
    lastLogin?: DateTimeNullableFilter<"Customer"> | Date | string | null;
    addresses?: AddressListRelationFilter;
    orders?: OrderListRelationFilter;
    reviews?: ProductReviewListRelationFilter;
  };

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    emailVerified?: SortOrder;
    isActive?: SortOrder;
    professionalTier?: SortOrder;
    discountRate?: SortOrder;
    businessInfo?: BusinessInfoOrderByInput;
    totalOrders?: SortOrder;
    totalSpent?: SortOrder;
    lifetimeValue?: SortOrder;
    averageOrderValue?: SortOrder;
    preferredPaymentMethod?: SortOrder;
    communicationPrefs?: SortOrder;
    timezone?: SortOrder;
    customerType?: SortOrder;
    riskLevel?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
    addresses?: AddressOrderByRelationAggregateInput;
    orders?: OrderOrderByRelationAggregateInput;
    reviews?: ProductReviewOrderByRelationAggregateInput;
  };

  export type CustomerWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: CustomerWhereInput | CustomerWhereInput[];
      OR?: CustomerWhereInput[];
      NOT?: CustomerWhereInput | CustomerWhereInput[];
      firstName?: StringFilter<"Customer"> | string;
      lastName?: StringFilter<"Customer"> | string;
      phone?: StringNullableFilter<"Customer"> | string | null;
      passwordHash?: StringFilter<"Customer"> | string;
      emailVerified?: BoolFilter<"Customer"> | boolean;
      isActive?: BoolFilter<"Customer"> | boolean;
      professionalTier?:
        | EnumProfessionalTierFilter<"Customer">
        | $Enums.ProfessionalTier;
      discountRate?: FloatFilter<"Customer"> | number;
      businessInfo?: XOR<
        BusinessInfoNullableCompositeFilter,
        BusinessInfoObjectEqualityInput
      > | null;
      totalOrders?: IntFilter<"Customer"> | number;
      totalSpent?: FloatFilter<"Customer"> | number;
      lifetimeValue?: FloatFilter<"Customer"> | number;
      averageOrderValue?: FloatFilter<"Customer"> | number;
      preferredPaymentMethod?: StringNullableFilter<"Customer"> | string | null;
      communicationPrefs?: JsonNullableFilter<"Customer">;
      timezone?: StringFilter<"Customer"> | string;
      customerType?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType;
      riskLevel?: EnumRiskLevelFilter<"Customer"> | $Enums.RiskLevel;
      notes?: StringNullableFilter<"Customer"> | string | null;
      createdAt?: DateTimeFilter<"Customer"> | Date | string;
      updatedAt?: DateTimeFilter<"Customer"> | Date | string;
      lastLogin?: DateTimeNullableFilter<"Customer"> | Date | string | null;
      addresses?: AddressListRelationFilter;
      orders?: OrderListRelationFilter;
      reviews?: ProductReviewListRelationFilter;
    },
    "id" | "email"
  >;

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    emailVerified?: SortOrder;
    isActive?: SortOrder;
    professionalTier?: SortOrder;
    discountRate?: SortOrder;
    totalOrders?: SortOrder;
    totalSpent?: SortOrder;
    lifetimeValue?: SortOrder;
    averageOrderValue?: SortOrder;
    preferredPaymentMethod?: SortOrder;
    communicationPrefs?: SortOrder;
    timezone?: SortOrder;
    customerType?: SortOrder;
    riskLevel?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
    _count?: CustomerCountOrderByAggregateInput;
    _avg?: CustomerAvgOrderByAggregateInput;
    _max?: CustomerMaxOrderByAggregateInput;
    _min?: CustomerMinOrderByAggregateInput;
    _sum?: CustomerSumOrderByAggregateInput;
  };

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?:
      | CustomerScalarWhereWithAggregatesInput
      | CustomerScalarWhereWithAggregatesInput[];
    OR?: CustomerScalarWhereWithAggregatesInput[];
    NOT?:
      | CustomerScalarWhereWithAggregatesInput
      | CustomerScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Customer"> | string;
    firstName?: StringWithAggregatesFilter<"Customer"> | string;
    lastName?: StringWithAggregatesFilter<"Customer"> | string;
    email?: StringWithAggregatesFilter<"Customer"> | string;
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null;
    passwordHash?: StringWithAggregatesFilter<"Customer"> | string;
    emailVerified?: BoolWithAggregatesFilter<"Customer"> | boolean;
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean;
    professionalTier?:
      | EnumProfessionalTierWithAggregatesFilter<"Customer">
      | $Enums.ProfessionalTier;
    discountRate?: FloatWithAggregatesFilter<"Customer"> | number;
    totalOrders?: IntWithAggregatesFilter<"Customer"> | number;
    totalSpent?: FloatWithAggregatesFilter<"Customer"> | number;
    lifetimeValue?: FloatWithAggregatesFilter<"Customer"> | number;
    averageOrderValue?: FloatWithAggregatesFilter<"Customer"> | number;
    preferredPaymentMethod?:
      | StringNullableWithAggregatesFilter<"Customer">
      | string
      | null;
    communicationPrefs?: JsonNullableWithAggregatesFilter<"Customer">;
    timezone?: StringWithAggregatesFilter<"Customer"> | string;
    customerType?:
      | EnumCustomerTypeWithAggregatesFilter<"Customer">
      | $Enums.CustomerType;
    riskLevel?:
      | EnumRiskLevelWithAggregatesFilter<"Customer">
      | $Enums.RiskLevel;
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string;
    lastLogin?:
      | DateTimeNullableWithAggregatesFilter<"Customer">
      | Date
      | string
      | null;
  };

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[];
    OR?: AddressWhereInput[];
    NOT?: AddressWhereInput | AddressWhereInput[];
    id?: StringFilter<"Address"> | string;
    customerId?: StringFilter<"Address"> | string;
    firstName?: StringNullableFilter<"Address"> | string | null;
    lastName?: StringNullableFilter<"Address"> | string | null;
    company?: StringNullableFilter<"Address"> | string | null;
    address1?: StringFilter<"Address"> | string;
    address2?: StringNullableFilter<"Address"> | string | null;
    city?: StringFilter<"Address"> | string;
    state?: StringFilter<"Address"> | string;
    postalCode?: StringFilter<"Address"> | string;
    country?: StringFilter<"Address"> | string;
    phone?: StringNullableFilter<"Address"> | string | null;
    type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType;
    isDefault?: BoolFilter<"Address"> | boolean;
    isValidated?: BoolFilter<"Address"> | boolean;
    createdAt?: DateTimeFilter<"Address"> | Date | string;
    updatedAt?: DateTimeFilter<"Address"> | Date | string;
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>;
  };

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    company?: SortOrder;
    address1?: SortOrder;
    address2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    type?: SortOrder;
    isDefault?: SortOrder;
    isValidated?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    customer?: CustomerOrderByWithRelationInput;
  };

  export type AddressWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AddressWhereInput | AddressWhereInput[];
      OR?: AddressWhereInput[];
      NOT?: AddressWhereInput | AddressWhereInput[];
      customerId?: StringFilter<"Address"> | string;
      firstName?: StringNullableFilter<"Address"> | string | null;
      lastName?: StringNullableFilter<"Address"> | string | null;
      company?: StringNullableFilter<"Address"> | string | null;
      address1?: StringFilter<"Address"> | string;
      address2?: StringNullableFilter<"Address"> | string | null;
      city?: StringFilter<"Address"> | string;
      state?: StringFilter<"Address"> | string;
      postalCode?: StringFilter<"Address"> | string;
      country?: StringFilter<"Address"> | string;
      phone?: StringNullableFilter<"Address"> | string | null;
      type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType;
      isDefault?: BoolFilter<"Address"> | boolean;
      isValidated?: BoolFilter<"Address"> | boolean;
      createdAt?: DateTimeFilter<"Address"> | Date | string;
      updatedAt?: DateTimeFilter<"Address"> | Date | string;
      customer?: XOR<CustomerRelationFilter, CustomerWhereInput>;
    },
    "id"
  >;

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    company?: SortOrder;
    address1?: SortOrder;
    address2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    type?: SortOrder;
    isDefault?: SortOrder;
    isValidated?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AddressCountOrderByAggregateInput;
    _max?: AddressMaxOrderByAggregateInput;
    _min?: AddressMinOrderByAggregateInput;
  };

  export type AddressScalarWhereWithAggregatesInput = {
    AND?:
      | AddressScalarWhereWithAggregatesInput
      | AddressScalarWhereWithAggregatesInput[];
    OR?: AddressScalarWhereWithAggregatesInput[];
    NOT?:
      | AddressScalarWhereWithAggregatesInput
      | AddressScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Address"> | string;
    customerId?: StringWithAggregatesFilter<"Address"> | string;
    firstName?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    lastName?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    company?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    address1?: StringWithAggregatesFilter<"Address"> | string;
    address2?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    city?: StringWithAggregatesFilter<"Address"> | string;
    state?: StringWithAggregatesFilter<"Address"> | string;
    postalCode?: StringWithAggregatesFilter<"Address"> | string;
    country?: StringWithAggregatesFilter<"Address"> | string;
    phone?: StringNullableWithAggregatesFilter<"Address"> | string | null;
    type?: EnumAddressTypeWithAggregatesFilter<"Address"> | $Enums.AddressType;
    isDefault?: BoolWithAggregatesFilter<"Address"> | boolean;
    isValidated?: BoolWithAggregatesFilter<"Address"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string;
  };

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[];
    OR?: CategoryWhereInput[];
    NOT?: CategoryWhereInput | CategoryWhereInput[];
    id?: StringFilter<"Category"> | string;
    name?: StringFilter<"Category"> | string;
    slug?: StringFilter<"Category"> | string;
    description?: StringNullableFilter<"Category"> | string | null;
    iconClass?: StringNullableFilter<"Category"> | string | null;
    parentId?: StringNullableFilter<"Category"> | string | null;
    image?: StringNullableFilter<"Category"> | string | null;
    sortOrder?: IntFilter<"Category"> | number;
    isActive?: BoolFilter<"Category"> | boolean;
    isFeatured?: BoolFilter<"Category"> | boolean;
    metaTitle?: StringNullableFilter<"Category"> | string | null;
    metaDescription?: StringNullableFilter<"Category"> | string | null;
    productCount?: IntFilter<"Category"> | number;
    createdAt?: DateTimeFilter<"Category"> | Date | string;
    updatedAt?: DateTimeFilter<"Category"> | Date | string;
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null;
    children?: CategoryListRelationFilter;
    products?: ProductListRelationFilter;
  };

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrder;
    iconClass?: SortOrder;
    parentId?: SortOrder;
    image?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    isFeatured?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    productCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    parent?: CategoryOrderByWithRelationInput;
    children?: CategoryOrderByRelationAggregateInput;
    products?: ProductOrderByRelationAggregateInput;
  };

  export type CategoryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      slug?: string;
      AND?: CategoryWhereInput | CategoryWhereInput[];
      OR?: CategoryWhereInput[];
      NOT?: CategoryWhereInput | CategoryWhereInput[];
      description?: StringNullableFilter<"Category"> | string | null;
      iconClass?: StringNullableFilter<"Category"> | string | null;
      parentId?: StringNullableFilter<"Category"> | string | null;
      image?: StringNullableFilter<"Category"> | string | null;
      sortOrder?: IntFilter<"Category"> | number;
      isActive?: BoolFilter<"Category"> | boolean;
      isFeatured?: BoolFilter<"Category"> | boolean;
      metaTitle?: StringNullableFilter<"Category"> | string | null;
      metaDescription?: StringNullableFilter<"Category"> | string | null;
      productCount?: IntFilter<"Category"> | number;
      createdAt?: DateTimeFilter<"Category"> | Date | string;
      updatedAt?: DateTimeFilter<"Category"> | Date | string;
      parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null;
      children?: CategoryListRelationFilter;
      products?: ProductListRelationFilter;
    },
    "id" | "name" | "slug"
  >;

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrder;
    iconClass?: SortOrder;
    parentId?: SortOrder;
    image?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    isFeatured?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    productCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: CategoryCountOrderByAggregateInput;
    _avg?: CategoryAvgOrderByAggregateInput;
    _max?: CategoryMaxOrderByAggregateInput;
    _min?: CategoryMinOrderByAggregateInput;
    _sum?: CategorySumOrderByAggregateInput;
  };

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?:
      | CategoryScalarWhereWithAggregatesInput
      | CategoryScalarWhereWithAggregatesInput[];
    OR?: CategoryScalarWhereWithAggregatesInput[];
    NOT?:
      | CategoryScalarWhereWithAggregatesInput
      | CategoryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Category"> | string;
    name?: StringWithAggregatesFilter<"Category"> | string;
    slug?: StringWithAggregatesFilter<"Category"> | string;
    description?:
      | StringNullableWithAggregatesFilter<"Category">
      | string
      | null;
    iconClass?: StringNullableWithAggregatesFilter<"Category"> | string | null;
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null;
    image?: StringNullableWithAggregatesFilter<"Category"> | string | null;
    sortOrder?: IntWithAggregatesFilter<"Category"> | number;
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean;
    isFeatured?: BoolWithAggregatesFilter<"Category"> | boolean;
    metaTitle?: StringNullableWithAggregatesFilter<"Category"> | string | null;
    metaDescription?:
      | StringNullableWithAggregatesFilter<"Category">
      | string
      | null;
    productCount?: IntWithAggregatesFilter<"Category"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string;
  };

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[];
    OR?: ProductWhereInput[];
    NOT?: ProductWhereInput | ProductWhereInput[];
    id?: StringFilter<"Product"> | string;
    categoryId?: StringFilter<"Product"> | string;
    name?: StringFilter<"Product"> | string;
    description?: StringFilter<"Product"> | string;
    shortDescription?: StringNullableFilter<"Product"> | string | null;
    regularPrice?: FloatFilter<"Product"> | number;
    salePrice?: FloatNullableFilter<"Product"> | number | null;
    costPrice?: FloatNullableFilter<"Product"> | number | null;
    sku?: StringFilter<"Product"> | string;
    partNumber?: StringNullableFilter<"Product"> | string | null;
    upc?: StringNullableFilter<"Product"> | string | null;
    stockQuantity?: IntFilter<"Product"> | number;
    lowStockThreshold?: IntFilter<"Product"> | number;
    trackInventory?: BoolFilter<"Product"> | boolean;
    allowBackorders?: BoolFilter<"Product"> | boolean;
    professionalOnly?: BoolFilter<"Product"> | boolean;
    minimumOrderQuantity?: IntFilter<"Product"> | number;
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFilter<"Product">
      | $Enums.ApprovalStatus;
    featured?: BoolFilter<"Product"> | boolean;
    onSale?: BoolFilter<"Product"> | boolean;
    newProduct?: BoolFilter<"Product"> | boolean;
    metaTitle?: StringNullableFilter<"Product"> | string | null;
    metaDescription?: StringNullableFilter<"Product"> | string | null;
    tags?: StringNullableListFilter<"Product">;
    weight?: FloatNullableFilter<"Product"> | number | null;
    dimensions?: JsonNullableFilter<"Product">;
    requiresShipping?: BoolFilter<"Product"> | boolean;
    shippingClass?: StringNullableFilter<"Product"> | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCompositeFilter,
      VehicleCompatibilityObjectEqualityInput
    > | null;
    version?: IntFilter<"Product"> | number;
    createdBy?: StringNullableFilter<"Product"> | string | null;
    lastModifiedBy?: StringNullableFilter<"Product"> | string | null;
    createdAt?: DateTimeFilter<"Product"> | Date | string;
    updatedAt?: DateTimeFilter<"Product"> | Date | string;
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>;
    reviews?: ProductReviewListRelationFilter;
    orderItems?: OrderItemListRelationFilter;
  };

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder;
    categoryId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    shortDescription?: SortOrder;
    regularPrice?: SortOrder;
    salePrice?: SortOrder;
    costPrice?: SortOrder;
    sku?: SortOrder;
    partNumber?: SortOrder;
    upc?: SortOrder;
    stockQuantity?: SortOrder;
    lowStockThreshold?: SortOrder;
    trackInventory?: SortOrder;
    allowBackorders?: SortOrder;
    professionalOnly?: SortOrder;
    minimumOrderQuantity?: SortOrder;
    status?: SortOrder;
    approvalStatus?: SortOrder;
    featured?: SortOrder;
    onSale?: SortOrder;
    newProduct?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    tags?: SortOrder;
    weight?: SortOrder;
    dimensions?: SortOrder;
    requiresShipping?: SortOrder;
    shippingClass?: SortOrder;
    vehicleCompatibility?: VehicleCompatibilityOrderByInput;
    version?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    category?: CategoryOrderByWithRelationInput;
    reviews?: ProductReviewOrderByRelationAggregateInput;
    orderItems?: OrderItemOrderByRelationAggregateInput;
  };

  export type ProductWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      sku?: string;
      AND?: ProductWhereInput | ProductWhereInput[];
      OR?: ProductWhereInput[];
      NOT?: ProductWhereInput | ProductWhereInput[];
      categoryId?: StringFilter<"Product"> | string;
      name?: StringFilter<"Product"> | string;
      description?: StringFilter<"Product"> | string;
      shortDescription?: StringNullableFilter<"Product"> | string | null;
      regularPrice?: FloatFilter<"Product"> | number;
      salePrice?: FloatNullableFilter<"Product"> | number | null;
      costPrice?: FloatNullableFilter<"Product"> | number | null;
      partNumber?: StringNullableFilter<"Product"> | string | null;
      upc?: StringNullableFilter<"Product"> | string | null;
      stockQuantity?: IntFilter<"Product"> | number;
      lowStockThreshold?: IntFilter<"Product"> | number;
      trackInventory?: BoolFilter<"Product"> | boolean;
      allowBackorders?: BoolFilter<"Product"> | boolean;
      professionalOnly?: BoolFilter<"Product"> | boolean;
      minimumOrderQuantity?: IntFilter<"Product"> | number;
      status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus;
      approvalStatus?:
        | EnumApprovalStatusFilter<"Product">
        | $Enums.ApprovalStatus;
      featured?: BoolFilter<"Product"> | boolean;
      onSale?: BoolFilter<"Product"> | boolean;
      newProduct?: BoolFilter<"Product"> | boolean;
      metaTitle?: StringNullableFilter<"Product"> | string | null;
      metaDescription?: StringNullableFilter<"Product"> | string | null;
      tags?: StringNullableListFilter<"Product">;
      weight?: FloatNullableFilter<"Product"> | number | null;
      dimensions?: JsonNullableFilter<"Product">;
      requiresShipping?: BoolFilter<"Product"> | boolean;
      shippingClass?: StringNullableFilter<"Product"> | string | null;
      vehicleCompatibility?: XOR<
        VehicleCompatibilityNullableCompositeFilter,
        VehicleCompatibilityObjectEqualityInput
      > | null;
      version?: IntFilter<"Product"> | number;
      createdBy?: StringNullableFilter<"Product"> | string | null;
      lastModifiedBy?: StringNullableFilter<"Product"> | string | null;
      createdAt?: DateTimeFilter<"Product"> | Date | string;
      updatedAt?: DateTimeFilter<"Product"> | Date | string;
      category?: XOR<CategoryRelationFilter, CategoryWhereInput>;
      reviews?: ProductReviewListRelationFilter;
      orderItems?: OrderItemListRelationFilter;
    },
    "id" | "sku"
  >;

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder;
    categoryId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    shortDescription?: SortOrder;
    regularPrice?: SortOrder;
    salePrice?: SortOrder;
    costPrice?: SortOrder;
    sku?: SortOrder;
    partNumber?: SortOrder;
    upc?: SortOrder;
    stockQuantity?: SortOrder;
    lowStockThreshold?: SortOrder;
    trackInventory?: SortOrder;
    allowBackorders?: SortOrder;
    professionalOnly?: SortOrder;
    minimumOrderQuantity?: SortOrder;
    status?: SortOrder;
    approvalStatus?: SortOrder;
    featured?: SortOrder;
    onSale?: SortOrder;
    newProduct?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    tags?: SortOrder;
    weight?: SortOrder;
    dimensions?: SortOrder;
    requiresShipping?: SortOrder;
    shippingClass?: SortOrder;
    version?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ProductCountOrderByAggregateInput;
    _avg?: ProductAvgOrderByAggregateInput;
    _max?: ProductMaxOrderByAggregateInput;
    _min?: ProductMinOrderByAggregateInput;
    _sum?: ProductSumOrderByAggregateInput;
  };

  export type ProductScalarWhereWithAggregatesInput = {
    AND?:
      | ProductScalarWhereWithAggregatesInput
      | ProductScalarWhereWithAggregatesInput[];
    OR?: ProductScalarWhereWithAggregatesInput[];
    NOT?:
      | ProductScalarWhereWithAggregatesInput
      | ProductScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Product"> | string;
    categoryId?: StringWithAggregatesFilter<"Product"> | string;
    name?: StringWithAggregatesFilter<"Product"> | string;
    description?: StringWithAggregatesFilter<"Product"> | string;
    shortDescription?:
      | StringNullableWithAggregatesFilter<"Product">
      | string
      | null;
    regularPrice?: FloatWithAggregatesFilter<"Product"> | number;
    salePrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null;
    costPrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null;
    sku?: StringWithAggregatesFilter<"Product"> | string;
    partNumber?: StringNullableWithAggregatesFilter<"Product"> | string | null;
    upc?: StringNullableWithAggregatesFilter<"Product"> | string | null;
    stockQuantity?: IntWithAggregatesFilter<"Product"> | number;
    lowStockThreshold?: IntWithAggregatesFilter<"Product"> | number;
    trackInventory?: BoolWithAggregatesFilter<"Product"> | boolean;
    allowBackorders?: BoolWithAggregatesFilter<"Product"> | boolean;
    professionalOnly?: BoolWithAggregatesFilter<"Product"> | boolean;
    minimumOrderQuantity?: IntWithAggregatesFilter<"Product"> | number;
    status?:
      | EnumProductStatusWithAggregatesFilter<"Product">
      | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusWithAggregatesFilter<"Product">
      | $Enums.ApprovalStatus;
    featured?: BoolWithAggregatesFilter<"Product"> | boolean;
    onSale?: BoolWithAggregatesFilter<"Product"> | boolean;
    newProduct?: BoolWithAggregatesFilter<"Product"> | boolean;
    metaTitle?: StringNullableWithAggregatesFilter<"Product"> | string | null;
    metaDescription?:
      | StringNullableWithAggregatesFilter<"Product">
      | string
      | null;
    tags?: StringNullableListFilter<"Product">;
    weight?: FloatNullableWithAggregatesFilter<"Product"> | number | null;
    dimensions?: JsonNullableWithAggregatesFilter<"Product">;
    requiresShipping?: BoolWithAggregatesFilter<"Product"> | boolean;
    shippingClass?:
      | StringNullableWithAggregatesFilter<"Product">
      | string
      | null;
    version?: IntWithAggregatesFilter<"Product"> | number;
    createdBy?: StringNullableWithAggregatesFilter<"Product"> | string | null;
    lastModifiedBy?:
      | StringNullableWithAggregatesFilter<"Product">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string;
  };

  export type ProductReviewWhereInput = {
    AND?: ProductReviewWhereInput | ProductReviewWhereInput[];
    OR?: ProductReviewWhereInput[];
    NOT?: ProductReviewWhereInput | ProductReviewWhereInput[];
    id?: StringFilter<"ProductReview"> | string;
    productId?: StringFilter<"ProductReview"> | string;
    customerId?: StringFilter<"ProductReview"> | string;
    rating?: IntFilter<"ProductReview"> | number;
    title?: StringFilter<"ProductReview"> | string;
    content?: StringFilter<"ProductReview"> | string;
    verified?: BoolFilter<"ProductReview"> | boolean;
    helpful?: IntFilter<"ProductReview"> | number;
    status?: EnumReviewStatusFilter<"ProductReview"> | $Enums.ReviewStatus;
    moderatedBy?: StringNullableFilter<"ProductReview"> | string | null;
    moderatedAt?:
      | DateTimeNullableFilter<"ProductReview">
      | Date
      | string
      | null;
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string;
    updatedAt?: DateTimeFilter<"ProductReview"> | Date | string;
    product?: XOR<ProductRelationFilter, ProductWhereInput>;
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>;
  };

  export type ProductReviewOrderByWithRelationInput = {
    id?: SortOrder;
    productId?: SortOrder;
    customerId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    verified?: SortOrder;
    helpful?: SortOrder;
    status?: SortOrder;
    moderatedBy?: SortOrder;
    moderatedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    product?: ProductOrderByWithRelationInput;
    customer?: CustomerOrderByWithRelationInput;
  };

  export type ProductReviewWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ProductReviewWhereInput | ProductReviewWhereInput[];
      OR?: ProductReviewWhereInput[];
      NOT?: ProductReviewWhereInput | ProductReviewWhereInput[];
      productId?: StringFilter<"ProductReview"> | string;
      customerId?: StringFilter<"ProductReview"> | string;
      rating?: IntFilter<"ProductReview"> | number;
      title?: StringFilter<"ProductReview"> | string;
      content?: StringFilter<"ProductReview"> | string;
      verified?: BoolFilter<"ProductReview"> | boolean;
      helpful?: IntFilter<"ProductReview"> | number;
      status?: EnumReviewStatusFilter<"ProductReview"> | $Enums.ReviewStatus;
      moderatedBy?: StringNullableFilter<"ProductReview"> | string | null;
      moderatedAt?:
        | DateTimeNullableFilter<"ProductReview">
        | Date
        | string
        | null;
      createdAt?: DateTimeFilter<"ProductReview"> | Date | string;
      updatedAt?: DateTimeFilter<"ProductReview"> | Date | string;
      product?: XOR<ProductRelationFilter, ProductWhereInput>;
      customer?: XOR<CustomerRelationFilter, CustomerWhereInput>;
    },
    "id"
  >;

  export type ProductReviewOrderByWithAggregationInput = {
    id?: SortOrder;
    productId?: SortOrder;
    customerId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    verified?: SortOrder;
    helpful?: SortOrder;
    status?: SortOrder;
    moderatedBy?: SortOrder;
    moderatedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ProductReviewCountOrderByAggregateInput;
    _avg?: ProductReviewAvgOrderByAggregateInput;
    _max?: ProductReviewMaxOrderByAggregateInput;
    _min?: ProductReviewMinOrderByAggregateInput;
    _sum?: ProductReviewSumOrderByAggregateInput;
  };

  export type ProductReviewScalarWhereWithAggregatesInput = {
    AND?:
      | ProductReviewScalarWhereWithAggregatesInput
      | ProductReviewScalarWhereWithAggregatesInput[];
    OR?: ProductReviewScalarWhereWithAggregatesInput[];
    NOT?:
      | ProductReviewScalarWhereWithAggregatesInput
      | ProductReviewScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ProductReview"> | string;
    productId?: StringWithAggregatesFilter<"ProductReview"> | string;
    customerId?: StringWithAggregatesFilter<"ProductReview"> | string;
    rating?: IntWithAggregatesFilter<"ProductReview"> | number;
    title?: StringWithAggregatesFilter<"ProductReview"> | string;
    content?: StringWithAggregatesFilter<"ProductReview"> | string;
    verified?: BoolWithAggregatesFilter<"ProductReview"> | boolean;
    helpful?: IntWithAggregatesFilter<"ProductReview"> | number;
    status?:
      | EnumReviewStatusWithAggregatesFilter<"ProductReview">
      | $Enums.ReviewStatus;
    moderatedBy?:
      | StringNullableWithAggregatesFilter<"ProductReview">
      | string
      | null;
    moderatedAt?:
      | DateTimeNullableWithAggregatesFilter<"ProductReview">
      | Date
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"ProductReview"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"ProductReview"> | Date | string;
  };

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[];
    OR?: OrderWhereInput[];
    NOT?: OrderWhereInput | OrderWhereInput[];
    id?: StringFilter<"Order"> | string;
    customerId?: StringFilter<"Order"> | string;
    orderNumber?: StringFilter<"Order"> | string;
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus;
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFilter<"Order">
      | $Enums.FulfillmentStatus;
    priorityLevel?: EnumOrderPriorityFilter<"Order"> | $Enums.OrderPriority;
    subtotal?: FloatFilter<"Order"> | number;
    taxAmount?: FloatFilter<"Order"> | number;
    shippingAmount?: FloatFilter<"Order"> | number;
    discountAmount?: FloatFilter<"Order"> | number;
    totalAmount?: FloatFilter<"Order"> | number;
    paymentMethod?: StringNullableFilter<"Order"> | string | null;
    paymentReference?: StringNullableFilter<"Order"> | string | null;
    shippingAddress?: JsonFilter<"Order">;
    billingAddress?: JsonFilter<"Order">;
    shippingCarrier?: StringNullableFilter<"Order"> | string | null;
    shippingMethod?: StringNullableFilter<"Order"> | string | null;
    trackingNumber?: StringNullableFilter<"Order"> | string | null;
    estimatedDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null;
    actualDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null;
    assignedToStaffId?: StringNullableFilter<"Order"> | string | null;
    internalNotes?: StringNullableFilter<"Order"> | string | null;
    customerNotes?: StringNullableFilter<"Order"> | string | null;
    cancellationReason?: StringNullableFilter<"Order"> | string | null;
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null;
    refundAmount?: FloatNullableFilter<"Order"> | number | null;
    refundReason?: StringNullableFilter<"Order"> | string | null;
    refundedAt?: DateTimeNullableFilter<"Order"> | Date | string | null;
    orderDate?: DateTimeFilter<"Order"> | Date | string;
    createdAt?: DateTimeFilter<"Order"> | Date | string;
    updatedAt?: DateTimeFilter<"Order"> | Date | string;
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>;
    orderItems?: OrderItemListRelationFilter;
  };

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    orderNumber?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    fulfillmentStatus?: SortOrder;
    priorityLevel?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    shippingAmount?: SortOrder;
    discountAmount?: SortOrder;
    totalAmount?: SortOrder;
    paymentMethod?: SortOrder;
    paymentReference?: SortOrder;
    shippingAddress?: SortOrder;
    billingAddress?: SortOrder;
    shippingCarrier?: SortOrder;
    shippingMethod?: SortOrder;
    trackingNumber?: SortOrder;
    estimatedDelivery?: SortOrder;
    actualDelivery?: SortOrder;
    assignedToStaffId?: SortOrder;
    internalNotes?: SortOrder;
    customerNotes?: SortOrder;
    cancellationReason?: SortOrder;
    cancelledAt?: SortOrder;
    refundAmount?: SortOrder;
    refundReason?: SortOrder;
    refundedAt?: SortOrder;
    orderDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    customer?: CustomerOrderByWithRelationInput;
    orderItems?: OrderItemOrderByRelationAggregateInput;
  };

  export type OrderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      orderNumber?: string;
      AND?: OrderWhereInput | OrderWhereInput[];
      OR?: OrderWhereInput[];
      NOT?: OrderWhereInput | OrderWhereInput[];
      customerId?: StringFilter<"Order"> | string;
      status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus;
      paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus;
      fulfillmentStatus?:
        | EnumFulfillmentStatusFilter<"Order">
        | $Enums.FulfillmentStatus;
      priorityLevel?: EnumOrderPriorityFilter<"Order"> | $Enums.OrderPriority;
      subtotal?: FloatFilter<"Order"> | number;
      taxAmount?: FloatFilter<"Order"> | number;
      shippingAmount?: FloatFilter<"Order"> | number;
      discountAmount?: FloatFilter<"Order"> | number;
      totalAmount?: FloatFilter<"Order"> | number;
      paymentMethod?: StringNullableFilter<"Order"> | string | null;
      paymentReference?: StringNullableFilter<"Order"> | string | null;
      shippingAddress?: JsonFilter<"Order">;
      billingAddress?: JsonFilter<"Order">;
      shippingCarrier?: StringNullableFilter<"Order"> | string | null;
      shippingMethod?: StringNullableFilter<"Order"> | string | null;
      trackingNumber?: StringNullableFilter<"Order"> | string | null;
      estimatedDelivery?:
        | DateTimeNullableFilter<"Order">
        | Date
        | string
        | null;
      actualDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null;
      assignedToStaffId?: StringNullableFilter<"Order"> | string | null;
      internalNotes?: StringNullableFilter<"Order"> | string | null;
      customerNotes?: StringNullableFilter<"Order"> | string | null;
      cancellationReason?: StringNullableFilter<"Order"> | string | null;
      cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null;
      refundAmount?: FloatNullableFilter<"Order"> | number | null;
      refundReason?: StringNullableFilter<"Order"> | string | null;
      refundedAt?: DateTimeNullableFilter<"Order"> | Date | string | null;
      orderDate?: DateTimeFilter<"Order"> | Date | string;
      createdAt?: DateTimeFilter<"Order"> | Date | string;
      updatedAt?: DateTimeFilter<"Order"> | Date | string;
      customer?: XOR<CustomerRelationFilter, CustomerWhereInput>;
      orderItems?: OrderItemListRelationFilter;
    },
    "id" | "orderNumber"
  >;

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    orderNumber?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    fulfillmentStatus?: SortOrder;
    priorityLevel?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    shippingAmount?: SortOrder;
    discountAmount?: SortOrder;
    totalAmount?: SortOrder;
    paymentMethod?: SortOrder;
    paymentReference?: SortOrder;
    shippingAddress?: SortOrder;
    billingAddress?: SortOrder;
    shippingCarrier?: SortOrder;
    shippingMethod?: SortOrder;
    trackingNumber?: SortOrder;
    estimatedDelivery?: SortOrder;
    actualDelivery?: SortOrder;
    assignedToStaffId?: SortOrder;
    internalNotes?: SortOrder;
    customerNotes?: SortOrder;
    cancellationReason?: SortOrder;
    cancelledAt?: SortOrder;
    refundAmount?: SortOrder;
    refundReason?: SortOrder;
    refundedAt?: SortOrder;
    orderDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: OrderCountOrderByAggregateInput;
    _avg?: OrderAvgOrderByAggregateInput;
    _max?: OrderMaxOrderByAggregateInput;
    _min?: OrderMinOrderByAggregateInput;
    _sum?: OrderSumOrderByAggregateInput;
  };

  export type OrderScalarWhereWithAggregatesInput = {
    AND?:
      | OrderScalarWhereWithAggregatesInput
      | OrderScalarWhereWithAggregatesInput[];
    OR?: OrderScalarWhereWithAggregatesInput[];
    NOT?:
      | OrderScalarWhereWithAggregatesInput
      | OrderScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Order"> | string;
    customerId?: StringWithAggregatesFilter<"Order"> | string;
    orderNumber?: StringWithAggregatesFilter<"Order"> | string;
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusWithAggregatesFilter<"Order">
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusWithAggregatesFilter<"Order">
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityWithAggregatesFilter<"Order">
      | $Enums.OrderPriority;
    subtotal?: FloatWithAggregatesFilter<"Order"> | number;
    taxAmount?: FloatWithAggregatesFilter<"Order"> | number;
    shippingAmount?: FloatWithAggregatesFilter<"Order"> | number;
    discountAmount?: FloatWithAggregatesFilter<"Order"> | number;
    totalAmount?: FloatWithAggregatesFilter<"Order"> | number;
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null;
    paymentReference?:
      | StringNullableWithAggregatesFilter<"Order">
      | string
      | null;
    shippingAddress?: JsonWithAggregatesFilter<"Order">;
    billingAddress?: JsonWithAggregatesFilter<"Order">;
    shippingCarrier?:
      | StringNullableWithAggregatesFilter<"Order">
      | string
      | null;
    shippingMethod?:
      | StringNullableWithAggregatesFilter<"Order">
      | string
      | null;
    trackingNumber?:
      | StringNullableWithAggregatesFilter<"Order">
      | string
      | null;
    estimatedDelivery?:
      | DateTimeNullableWithAggregatesFilter<"Order">
      | Date
      | string
      | null;
    actualDelivery?:
      | DateTimeNullableWithAggregatesFilter<"Order">
      | Date
      | string
      | null;
    assignedToStaffId?:
      | StringNullableWithAggregatesFilter<"Order">
      | string
      | null;
    internalNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null;
    customerNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null;
    cancellationReason?:
      | StringNullableWithAggregatesFilter<"Order">
      | string
      | null;
    cancelledAt?:
      | DateTimeNullableWithAggregatesFilter<"Order">
      | Date
      | string
      | null;
    refundAmount?: FloatNullableWithAggregatesFilter<"Order"> | number | null;
    refundReason?: StringNullableWithAggregatesFilter<"Order"> | string | null;
    refundedAt?:
      | DateTimeNullableWithAggregatesFilter<"Order">
      | Date
      | string
      | null;
    orderDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string;
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string;
  };

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[];
    OR?: OrderItemWhereInput[];
    NOT?: OrderItemWhereInput | OrderItemWhereInput[];
    id?: StringFilter<"OrderItem"> | string;
    orderId?: StringFilter<"OrderItem"> | string;
    productId?: StringFilter<"OrderItem"> | string;
    quantity?: IntFilter<"OrderItem"> | number;
    priceAtPurchase?: FloatFilter<"OrderItem"> | number;
    productNameAtPurchase?: StringFilter<"OrderItem"> | string;
    quantityShipped?: IntFilter<"OrderItem"> | number;
    quantityRefunded?: IntFilter<"OrderItem"> | number;
    order?: XOR<OrderRelationFilter, OrderWhereInput>;
    product?: XOR<ProductRelationFilter, ProductWhereInput>;
  };

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    quantity?: SortOrder;
    priceAtPurchase?: SortOrder;
    productNameAtPurchase?: SortOrder;
    quantityShipped?: SortOrder;
    quantityRefunded?: SortOrder;
    order?: OrderOrderByWithRelationInput;
    product?: ProductOrderByWithRelationInput;
  };

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: OrderItemWhereInput | OrderItemWhereInput[];
      OR?: OrderItemWhereInput[];
      NOT?: OrderItemWhereInput | OrderItemWhereInput[];
      orderId?: StringFilter<"OrderItem"> | string;
      productId?: StringFilter<"OrderItem"> | string;
      quantity?: IntFilter<"OrderItem"> | number;
      priceAtPurchase?: FloatFilter<"OrderItem"> | number;
      productNameAtPurchase?: StringFilter<"OrderItem"> | string;
      quantityShipped?: IntFilter<"OrderItem"> | number;
      quantityRefunded?: IntFilter<"OrderItem"> | number;
      order?: XOR<OrderRelationFilter, OrderWhereInput>;
      product?: XOR<ProductRelationFilter, ProductWhereInput>;
    },
    "id"
  >;

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    quantity?: SortOrder;
    priceAtPurchase?: SortOrder;
    productNameAtPurchase?: SortOrder;
    quantityShipped?: SortOrder;
    quantityRefunded?: SortOrder;
    _count?: OrderItemCountOrderByAggregateInput;
    _avg?: OrderItemAvgOrderByAggregateInput;
    _max?: OrderItemMaxOrderByAggregateInput;
    _min?: OrderItemMinOrderByAggregateInput;
    _sum?: OrderItemSumOrderByAggregateInput;
  };

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?:
      | OrderItemScalarWhereWithAggregatesInput
      | OrderItemScalarWhereWithAggregatesInput[];
    OR?: OrderItemScalarWhereWithAggregatesInput[];
    NOT?:
      | OrderItemScalarWhereWithAggregatesInput
      | OrderItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"OrderItem"> | string;
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string;
    productId?: StringWithAggregatesFilter<"OrderItem"> | string;
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number;
    priceAtPurchase?: FloatWithAggregatesFilter<"OrderItem"> | number;
    productNameAtPurchase?: StringWithAggregatesFilter<"OrderItem"> | string;
    quantityShipped?: IntWithAggregatesFilter<"OrderItem"> | number;
    quantityRefunded?: IntWithAggregatesFilter<"OrderItem"> | number;
  };

  export type RoleCreateInput = {
    id?: string;
    roleName: string;
    hierarchyLevel: number;
    permissions: InputJsonValue;
    description?: string | null;
    isActive?: boolean;
    maxUsers?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    staffUsers?: StaffUserCreateNestedManyWithoutRoleInput;
  };

  export type RoleUncheckedCreateInput = {
    id?: string;
    roleName: string;
    hierarchyLevel: number;
    permissions: InputJsonValue;
    description?: string | null;
    isActive?: boolean;
    maxUsers?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    staffUsers?: StaffUserUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleUpdateInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    hierarchyLevel?: IntFieldUpdateOperationsInput | number;
    permissions?: InputJsonValue | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    maxUsers?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    staffUsers?: StaffUserUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    hierarchyLevel?: IntFieldUpdateOperationsInput | number;
    permissions?: InputJsonValue | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    maxUsers?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    staffUsers?: StaffUserUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleCreateManyInput = {
    id?: string;
    roleName: string;
    hierarchyLevel: number;
    permissions: InputJsonValue;
    description?: string | null;
    isActive?: boolean;
    maxUsers?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleUpdateManyMutationInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    hierarchyLevel?: IntFieldUpdateOperationsInput | number;
    permissions?: InputJsonValue | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    maxUsers?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateManyInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    hierarchyLevel?: IntFieldUpdateOperationsInput | number;
    permissions?: InputJsonValue | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    maxUsers?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StaffUserCreateInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLogin?: Date | string | null;
    lastLoginIp?: string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordChangedAt?: Date | string;
    mustChangePassword?: boolean;
    avatar?: string | null;
    timezone?: string;
    language?: string;
    canAccessAdmin?: boolean;
    departmentAccess?: StaffUserCreatedepartmentAccessInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    role: RoleCreateNestedOneWithoutStaffUsersInput;
    activityLogs?: ActivityLogCreateNestedManyWithoutStaffUserInput;
  };

  export type StaffUserUncheckedCreateInput = {
    id?: string;
    roleId: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLogin?: Date | string | null;
    lastLoginIp?: string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordChangedAt?: Date | string;
    mustChangePassword?: boolean;
    avatar?: string | null;
    timezone?: string;
    language?: string;
    canAccessAdmin?: boolean;
    departmentAccess?: StaffUserCreatedepartmentAccessInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffUserInput;
  };

  export type StaffUserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: RoleUpdateOneRequiredWithoutStaffUsersNestedInput;
    activityLogs?: ActivityLogUpdateManyWithoutStaffUserNestedInput;
  };

  export type StaffUserUncheckedUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffUserNestedInput;
  };

  export type StaffUserCreateManyInput = {
    id?: string;
    roleId: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLogin?: Date | string | null;
    lastLoginIp?: string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordChangedAt?: Date | string;
    mustChangePassword?: boolean;
    avatar?: string | null;
    timezone?: string;
    language?: string;
    canAccessAdmin?: boolean;
    departmentAccess?: StaffUserCreatedepartmentAccessInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
  };

  export type StaffUserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StaffUserUncheckedUpdateManyInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SettingCreateInput = {
    id?: string;
    settingKey: string;
    settingValue: InputJsonValue;
    category: string;
    subcategory?: string | null;
    dataType?: $Enums.SettingDataType;
    isEncrypted?: boolean;
    isPublic?: boolean;
    displayName?: string | null;
    description?: string | null;
    defaultValue?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    sortOrder?: number;
    isVisible?: boolean;
    isEditable?: boolean;
    updatedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SettingUncheckedCreateInput = {
    id?: string;
    settingKey: string;
    settingValue: InputJsonValue;
    category: string;
    subcategory?: string | null;
    dataType?: $Enums.SettingDataType;
    isEncrypted?: boolean;
    isPublic?: boolean;
    displayName?: string | null;
    description?: string | null;
    defaultValue?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    sortOrder?: number;
    isVisible?: boolean;
    isEditable?: boolean;
    updatedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SettingUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string;
    settingValue?: InputJsonValue | InputJsonValue;
    category?: StringFieldUpdateOperationsInput | string;
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null;
    dataType?:
      | EnumSettingDataTypeFieldUpdateOperationsInput
      | $Enums.SettingDataType;
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    defaultValue?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isVisible?: BoolFieldUpdateOperationsInput | boolean;
    isEditable?: BoolFieldUpdateOperationsInput | boolean;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SettingUncheckedUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string;
    settingValue?: InputJsonValue | InputJsonValue;
    category?: StringFieldUpdateOperationsInput | string;
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null;
    dataType?:
      | EnumSettingDataTypeFieldUpdateOperationsInput
      | $Enums.SettingDataType;
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    defaultValue?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isVisible?: BoolFieldUpdateOperationsInput | boolean;
    isEditable?: BoolFieldUpdateOperationsInput | boolean;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SettingCreateManyInput = {
    id?: string;
    settingKey: string;
    settingValue: InputJsonValue;
    category: string;
    subcategory?: string | null;
    dataType?: $Enums.SettingDataType;
    isEncrypted?: boolean;
    isPublic?: boolean;
    displayName?: string | null;
    description?: string | null;
    defaultValue?: InputJsonValue | null;
    validation?: InputJsonValue | null;
    sortOrder?: number;
    isVisible?: boolean;
    isEditable?: boolean;
    updatedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SettingUpdateManyMutationInput = {
    settingKey?: StringFieldUpdateOperationsInput | string;
    settingValue?: InputJsonValue | InputJsonValue;
    category?: StringFieldUpdateOperationsInput | string;
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null;
    dataType?:
      | EnumSettingDataTypeFieldUpdateOperationsInput
      | $Enums.SettingDataType;
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    defaultValue?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isVisible?: BoolFieldUpdateOperationsInput | boolean;
    isEditable?: BoolFieldUpdateOperationsInput | boolean;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SettingUncheckedUpdateManyInput = {
    settingKey?: StringFieldUpdateOperationsInput | string;
    settingValue?: InputJsonValue | InputJsonValue;
    category?: StringFieldUpdateOperationsInput | string;
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null;
    dataType?:
      | EnumSettingDataTypeFieldUpdateOperationsInput
      | $Enums.SettingDataType;
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    defaultValue?: InputJsonValue | InputJsonValue | null;
    validation?: InputJsonValue | InputJsonValue | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isVisible?: BoolFieldUpdateOperationsInput | boolean;
    isEditable?: BoolFieldUpdateOperationsInput | boolean;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BannerCreateInput = {
    id?: string;
    title: string;
    subtitle?: string | null;
    description?: string | null;
    imageUrl?: string | null;
    videoUrl?: string | null;
    altText?: string | null;
    buttonText?: string | null;
    buttonUrl?: string | null;
    linkTarget?: string;
    position?: $Enums.BannerPosition;
    displayType?: $Enums.BannerType;
    priority?: number;
    showOnMobile?: boolean;
    showOnTablet?: boolean;
    showOnDesktop?: boolean;
    backgroundColor?: string | null;
    textColor?: string | null;
    borderColor?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    isActive?: boolean;
    clickCount?: number;
    viewCount?: number;
    metaTitle?: string | null;
    metaDescription?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type BannerUncheckedCreateInput = {
    id?: string;
    title: string;
    subtitle?: string | null;
    description?: string | null;
    imageUrl?: string | null;
    videoUrl?: string | null;
    altText?: string | null;
    buttonText?: string | null;
    buttonUrl?: string | null;
    linkTarget?: string;
    position?: $Enums.BannerPosition;
    displayType?: $Enums.BannerType;
    priority?: number;
    showOnMobile?: boolean;
    showOnTablet?: boolean;
    showOnDesktop?: boolean;
    backgroundColor?: string | null;
    textColor?: string | null;
    borderColor?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    isActive?: boolean;
    clickCount?: number;
    viewCount?: number;
    metaTitle?: string | null;
    metaDescription?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type BannerUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    altText?: NullableStringFieldUpdateOperationsInput | string | null;
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null;
    buttonUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    linkTarget?: StringFieldUpdateOperationsInput | string;
    position?:
      | EnumBannerPositionFieldUpdateOperationsInput
      | $Enums.BannerPosition;
    displayType?: EnumBannerTypeFieldUpdateOperationsInput | $Enums.BannerType;
    priority?: IntFieldUpdateOperationsInput | number;
    showOnMobile?: BoolFieldUpdateOperationsInput | boolean;
    showOnTablet?: BoolFieldUpdateOperationsInput | boolean;
    showOnDesktop?: BoolFieldUpdateOperationsInput | boolean;
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null;
    textColor?: NullableStringFieldUpdateOperationsInput | string | null;
    borderColor?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    clickCount?: IntFieldUpdateOperationsInput | number;
    viewCount?: IntFieldUpdateOperationsInput | number;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BannerUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    altText?: NullableStringFieldUpdateOperationsInput | string | null;
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null;
    buttonUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    linkTarget?: StringFieldUpdateOperationsInput | string;
    position?:
      | EnumBannerPositionFieldUpdateOperationsInput
      | $Enums.BannerPosition;
    displayType?: EnumBannerTypeFieldUpdateOperationsInput | $Enums.BannerType;
    priority?: IntFieldUpdateOperationsInput | number;
    showOnMobile?: BoolFieldUpdateOperationsInput | boolean;
    showOnTablet?: BoolFieldUpdateOperationsInput | boolean;
    showOnDesktop?: BoolFieldUpdateOperationsInput | boolean;
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null;
    textColor?: NullableStringFieldUpdateOperationsInput | string | null;
    borderColor?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    clickCount?: IntFieldUpdateOperationsInput | number;
    viewCount?: IntFieldUpdateOperationsInput | number;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BannerCreateManyInput = {
    id?: string;
    title: string;
    subtitle?: string | null;
    description?: string | null;
    imageUrl?: string | null;
    videoUrl?: string | null;
    altText?: string | null;
    buttonText?: string | null;
    buttonUrl?: string | null;
    linkTarget?: string;
    position?: $Enums.BannerPosition;
    displayType?: $Enums.BannerType;
    priority?: number;
    showOnMobile?: boolean;
    showOnTablet?: boolean;
    showOnDesktop?: boolean;
    backgroundColor?: string | null;
    textColor?: string | null;
    borderColor?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    isActive?: boolean;
    clickCount?: number;
    viewCount?: number;
    metaTitle?: string | null;
    metaDescription?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type BannerUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string;
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    altText?: NullableStringFieldUpdateOperationsInput | string | null;
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null;
    buttonUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    linkTarget?: StringFieldUpdateOperationsInput | string;
    position?:
      | EnumBannerPositionFieldUpdateOperationsInput
      | $Enums.BannerPosition;
    displayType?: EnumBannerTypeFieldUpdateOperationsInput | $Enums.BannerType;
    priority?: IntFieldUpdateOperationsInput | number;
    showOnMobile?: BoolFieldUpdateOperationsInput | boolean;
    showOnTablet?: BoolFieldUpdateOperationsInput | boolean;
    showOnDesktop?: BoolFieldUpdateOperationsInput | boolean;
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null;
    textColor?: NullableStringFieldUpdateOperationsInput | string | null;
    borderColor?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    clickCount?: IntFieldUpdateOperationsInput | number;
    viewCount?: IntFieldUpdateOperationsInput | number;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BannerUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string;
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    altText?: NullableStringFieldUpdateOperationsInput | string | null;
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null;
    buttonUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    linkTarget?: StringFieldUpdateOperationsInput | string;
    position?:
      | EnumBannerPositionFieldUpdateOperationsInput
      | $Enums.BannerPosition;
    displayType?: EnumBannerTypeFieldUpdateOperationsInput | $Enums.BannerType;
    priority?: IntFieldUpdateOperationsInput | number;
    showOnMobile?: BoolFieldUpdateOperationsInput | boolean;
    showOnTablet?: BoolFieldUpdateOperationsInput | boolean;
    showOnDesktop?: BoolFieldUpdateOperationsInput | boolean;
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null;
    textColor?: NullableStringFieldUpdateOperationsInput | string | null;
    borderColor?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    clickCount?: IntFieldUpdateOperationsInput | number;
    viewCount?: IntFieldUpdateOperationsInput | number;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type HeroSlideCreateInput = {
    id?: string;
    title: string;
    subtitle?: string | null;
    description?: string | null;
    imageUrl: string;
    mobileImageUrl?: string | null;
    altText?: string | null;
    primaryButtonText?: string | null;
    primaryButtonUrl?: string | null;
    secondaryButtonText?: string | null;
    secondaryButtonUrl?: string | null;
    textPosition?: $Enums.SlideTextPosition;
    overlayOpacity?: number;
    textColor?: string;
    animationType?: $Enums.SlideAnimation;
    displayDuration?: number;
    sortOrder?: number;
    isActive?: boolean;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    showOnMobile?: boolean;
    showOnTablet?: boolean;
    showOnDesktop?: boolean;
    clickCount?: number;
    viewCount?: number;
    metaTitle?: string | null;
    metaDescription?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type HeroSlideUncheckedCreateInput = {
    id?: string;
    title: string;
    subtitle?: string | null;
    description?: string | null;
    imageUrl: string;
    mobileImageUrl?: string | null;
    altText?: string | null;
    primaryButtonText?: string | null;
    primaryButtonUrl?: string | null;
    secondaryButtonText?: string | null;
    secondaryButtonUrl?: string | null;
    textPosition?: $Enums.SlideTextPosition;
    overlayOpacity?: number;
    textColor?: string;
    animationType?: $Enums.SlideAnimation;
    displayDuration?: number;
    sortOrder?: number;
    isActive?: boolean;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    showOnMobile?: boolean;
    showOnTablet?: boolean;
    showOnDesktop?: boolean;
    clickCount?: number;
    viewCount?: number;
    metaTitle?: string | null;
    metaDescription?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type HeroSlideUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    mobileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    altText?: NullableStringFieldUpdateOperationsInput | string | null;
    primaryButtonText?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    primaryButtonUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    secondaryButtonText?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondaryButtonUrl?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    textPosition?:
      | EnumSlideTextPositionFieldUpdateOperationsInput
      | $Enums.SlideTextPosition;
    overlayOpacity?: FloatFieldUpdateOperationsInput | number;
    textColor?: StringFieldUpdateOperationsInput | string;
    animationType?:
      | EnumSlideAnimationFieldUpdateOperationsInput
      | $Enums.SlideAnimation;
    displayDuration?: IntFieldUpdateOperationsInput | number;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    showOnMobile?: BoolFieldUpdateOperationsInput | boolean;
    showOnTablet?: BoolFieldUpdateOperationsInput | boolean;
    showOnDesktop?: BoolFieldUpdateOperationsInput | boolean;
    clickCount?: IntFieldUpdateOperationsInput | number;
    viewCount?: IntFieldUpdateOperationsInput | number;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type HeroSlideUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    mobileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    altText?: NullableStringFieldUpdateOperationsInput | string | null;
    primaryButtonText?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    primaryButtonUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    secondaryButtonText?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondaryButtonUrl?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    textPosition?:
      | EnumSlideTextPositionFieldUpdateOperationsInput
      | $Enums.SlideTextPosition;
    overlayOpacity?: FloatFieldUpdateOperationsInput | number;
    textColor?: StringFieldUpdateOperationsInput | string;
    animationType?:
      | EnumSlideAnimationFieldUpdateOperationsInput
      | $Enums.SlideAnimation;
    displayDuration?: IntFieldUpdateOperationsInput | number;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    showOnMobile?: BoolFieldUpdateOperationsInput | boolean;
    showOnTablet?: BoolFieldUpdateOperationsInput | boolean;
    showOnDesktop?: BoolFieldUpdateOperationsInput | boolean;
    clickCount?: IntFieldUpdateOperationsInput | number;
    viewCount?: IntFieldUpdateOperationsInput | number;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type HeroSlideCreateManyInput = {
    id?: string;
    title: string;
    subtitle?: string | null;
    description?: string | null;
    imageUrl: string;
    mobileImageUrl?: string | null;
    altText?: string | null;
    primaryButtonText?: string | null;
    primaryButtonUrl?: string | null;
    secondaryButtonText?: string | null;
    secondaryButtonUrl?: string | null;
    textPosition?: $Enums.SlideTextPosition;
    overlayOpacity?: number;
    textColor?: string;
    animationType?: $Enums.SlideAnimation;
    displayDuration?: number;
    sortOrder?: number;
    isActive?: boolean;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    showOnMobile?: boolean;
    showOnTablet?: boolean;
    showOnDesktop?: boolean;
    clickCount?: number;
    viewCount?: number;
    metaTitle?: string | null;
    metaDescription?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type HeroSlideUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string;
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    mobileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    altText?: NullableStringFieldUpdateOperationsInput | string | null;
    primaryButtonText?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    primaryButtonUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    secondaryButtonText?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondaryButtonUrl?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    textPosition?:
      | EnumSlideTextPositionFieldUpdateOperationsInput
      | $Enums.SlideTextPosition;
    overlayOpacity?: FloatFieldUpdateOperationsInput | number;
    textColor?: StringFieldUpdateOperationsInput | string;
    animationType?:
      | EnumSlideAnimationFieldUpdateOperationsInput
      | $Enums.SlideAnimation;
    displayDuration?: IntFieldUpdateOperationsInput | number;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    showOnMobile?: BoolFieldUpdateOperationsInput | boolean;
    showOnTablet?: BoolFieldUpdateOperationsInput | boolean;
    showOnDesktop?: BoolFieldUpdateOperationsInput | boolean;
    clickCount?: IntFieldUpdateOperationsInput | number;
    viewCount?: IntFieldUpdateOperationsInput | number;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type HeroSlideUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string;
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    mobileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    altText?: NullableStringFieldUpdateOperationsInput | string | null;
    primaryButtonText?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    primaryButtonUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    secondaryButtonText?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondaryButtonUrl?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    textPosition?:
      | EnumSlideTextPositionFieldUpdateOperationsInput
      | $Enums.SlideTextPosition;
    overlayOpacity?: FloatFieldUpdateOperationsInput | number;
    textColor?: StringFieldUpdateOperationsInput | string;
    animationType?:
      | EnumSlideAnimationFieldUpdateOperationsInput
      | $Enums.SlideAnimation;
    displayDuration?: IntFieldUpdateOperationsInput | number;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    showOnMobile?: BoolFieldUpdateOperationsInput | boolean;
    showOnTablet?: BoolFieldUpdateOperationsInput | boolean;
    showOnDesktop?: BoolFieldUpdateOperationsInput | boolean;
    clickCount?: IntFieldUpdateOperationsInput | number;
    viewCount?: IntFieldUpdateOperationsInput | number;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SiteCustomizationCreateInput = {
    id?: string;
    siteName?: string;
    siteDescription?: string | null;
    logoUrl?: string | null;
    faviconUrl?: string | null;
    primaryColor?: string;
    secondaryColor?: string;
    accentColor?: string;
    backgroundColor?: string;
    textColor?: string;
    linkColor?: string;
    primaryFont?: string;
    secondaryFont?: string;
    fontSize?: string;
    headerStyle?: string;
    footerStyle?: string;
    borderRadius?: string;
    showSearch?: boolean;
    showWishlist?: boolean;
    showCompare?: boolean;
    showReviews?: boolean;
    enableChat?: boolean;
    enableNewsletter?: boolean;
    contactEmail?: string | null;
    contactPhone?: string | null;
    contactAddress?: InputJsonValue | null;
    businessHours?: InputJsonValue | null;
    socialMedia?: InputJsonValue | null;
    metaTitle?: string | null;
    metaDescription?: string | null;
    metaKeywords?: string | null;
    googleAnalytics?: string | null;
    privacyPolicyUrl?: string | null;
    termsOfServiceUrl?: string | null;
    isActive?: boolean;
    updatedAt?: Date | string;
    updatedBy?: string | null;
  };

  export type SiteCustomizationUncheckedCreateInput = {
    id?: string;
    siteName?: string;
    siteDescription?: string | null;
    logoUrl?: string | null;
    faviconUrl?: string | null;
    primaryColor?: string;
    secondaryColor?: string;
    accentColor?: string;
    backgroundColor?: string;
    textColor?: string;
    linkColor?: string;
    primaryFont?: string;
    secondaryFont?: string;
    fontSize?: string;
    headerStyle?: string;
    footerStyle?: string;
    borderRadius?: string;
    showSearch?: boolean;
    showWishlist?: boolean;
    showCompare?: boolean;
    showReviews?: boolean;
    enableChat?: boolean;
    enableNewsletter?: boolean;
    contactEmail?: string | null;
    contactPhone?: string | null;
    contactAddress?: InputJsonValue | null;
    businessHours?: InputJsonValue | null;
    socialMedia?: InputJsonValue | null;
    metaTitle?: string | null;
    metaDescription?: string | null;
    metaKeywords?: string | null;
    googleAnalytics?: string | null;
    privacyPolicyUrl?: string | null;
    termsOfServiceUrl?: string | null;
    isActive?: boolean;
    updatedAt?: Date | string;
    updatedBy?: string | null;
  };

  export type SiteCustomizationUpdateInput = {
    siteName?: StringFieldUpdateOperationsInput | string;
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    primaryColor?: StringFieldUpdateOperationsInput | string;
    secondaryColor?: StringFieldUpdateOperationsInput | string;
    accentColor?: StringFieldUpdateOperationsInput | string;
    backgroundColor?: StringFieldUpdateOperationsInput | string;
    textColor?: StringFieldUpdateOperationsInput | string;
    linkColor?: StringFieldUpdateOperationsInput | string;
    primaryFont?: StringFieldUpdateOperationsInput | string;
    secondaryFont?: StringFieldUpdateOperationsInput | string;
    fontSize?: StringFieldUpdateOperationsInput | string;
    headerStyle?: StringFieldUpdateOperationsInput | string;
    footerStyle?: StringFieldUpdateOperationsInput | string;
    borderRadius?: StringFieldUpdateOperationsInput | string;
    showSearch?: BoolFieldUpdateOperationsInput | boolean;
    showWishlist?: BoolFieldUpdateOperationsInput | boolean;
    showCompare?: BoolFieldUpdateOperationsInput | boolean;
    showReviews?: BoolFieldUpdateOperationsInput | boolean;
    enableChat?: BoolFieldUpdateOperationsInput | boolean;
    enableNewsletter?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactAddress?: InputJsonValue | InputJsonValue | null;
    businessHours?: InputJsonValue | InputJsonValue | null;
    socialMedia?: InputJsonValue | InputJsonValue | null;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null;
    googleAnalytics?: NullableStringFieldUpdateOperationsInput | string | null;
    privacyPolicyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    termsOfServiceUrl?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SiteCustomizationUncheckedUpdateInput = {
    siteName?: StringFieldUpdateOperationsInput | string;
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    primaryColor?: StringFieldUpdateOperationsInput | string;
    secondaryColor?: StringFieldUpdateOperationsInput | string;
    accentColor?: StringFieldUpdateOperationsInput | string;
    backgroundColor?: StringFieldUpdateOperationsInput | string;
    textColor?: StringFieldUpdateOperationsInput | string;
    linkColor?: StringFieldUpdateOperationsInput | string;
    primaryFont?: StringFieldUpdateOperationsInput | string;
    secondaryFont?: StringFieldUpdateOperationsInput | string;
    fontSize?: StringFieldUpdateOperationsInput | string;
    headerStyle?: StringFieldUpdateOperationsInput | string;
    footerStyle?: StringFieldUpdateOperationsInput | string;
    borderRadius?: StringFieldUpdateOperationsInput | string;
    showSearch?: BoolFieldUpdateOperationsInput | boolean;
    showWishlist?: BoolFieldUpdateOperationsInput | boolean;
    showCompare?: BoolFieldUpdateOperationsInput | boolean;
    showReviews?: BoolFieldUpdateOperationsInput | boolean;
    enableChat?: BoolFieldUpdateOperationsInput | boolean;
    enableNewsletter?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactAddress?: InputJsonValue | InputJsonValue | null;
    businessHours?: InputJsonValue | InputJsonValue | null;
    socialMedia?: InputJsonValue | InputJsonValue | null;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null;
    googleAnalytics?: NullableStringFieldUpdateOperationsInput | string | null;
    privacyPolicyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    termsOfServiceUrl?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SiteCustomizationCreateManyInput = {
    id?: string;
    siteName?: string;
    siteDescription?: string | null;
    logoUrl?: string | null;
    faviconUrl?: string | null;
    primaryColor?: string;
    secondaryColor?: string;
    accentColor?: string;
    backgroundColor?: string;
    textColor?: string;
    linkColor?: string;
    primaryFont?: string;
    secondaryFont?: string;
    fontSize?: string;
    headerStyle?: string;
    footerStyle?: string;
    borderRadius?: string;
    showSearch?: boolean;
    showWishlist?: boolean;
    showCompare?: boolean;
    showReviews?: boolean;
    enableChat?: boolean;
    enableNewsletter?: boolean;
    contactEmail?: string | null;
    contactPhone?: string | null;
    contactAddress?: InputJsonValue | null;
    businessHours?: InputJsonValue | null;
    socialMedia?: InputJsonValue | null;
    metaTitle?: string | null;
    metaDescription?: string | null;
    metaKeywords?: string | null;
    googleAnalytics?: string | null;
    privacyPolicyUrl?: string | null;
    termsOfServiceUrl?: string | null;
    isActive?: boolean;
    updatedAt?: Date | string;
    updatedBy?: string | null;
  };

  export type SiteCustomizationUpdateManyMutationInput = {
    siteName?: StringFieldUpdateOperationsInput | string;
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    primaryColor?: StringFieldUpdateOperationsInput | string;
    secondaryColor?: StringFieldUpdateOperationsInput | string;
    accentColor?: StringFieldUpdateOperationsInput | string;
    backgroundColor?: StringFieldUpdateOperationsInput | string;
    textColor?: StringFieldUpdateOperationsInput | string;
    linkColor?: StringFieldUpdateOperationsInput | string;
    primaryFont?: StringFieldUpdateOperationsInput | string;
    secondaryFont?: StringFieldUpdateOperationsInput | string;
    fontSize?: StringFieldUpdateOperationsInput | string;
    headerStyle?: StringFieldUpdateOperationsInput | string;
    footerStyle?: StringFieldUpdateOperationsInput | string;
    borderRadius?: StringFieldUpdateOperationsInput | string;
    showSearch?: BoolFieldUpdateOperationsInput | boolean;
    showWishlist?: BoolFieldUpdateOperationsInput | boolean;
    showCompare?: BoolFieldUpdateOperationsInput | boolean;
    showReviews?: BoolFieldUpdateOperationsInput | boolean;
    enableChat?: BoolFieldUpdateOperationsInput | boolean;
    enableNewsletter?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactAddress?: InputJsonValue | InputJsonValue | null;
    businessHours?: InputJsonValue | InputJsonValue | null;
    socialMedia?: InputJsonValue | InputJsonValue | null;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null;
    googleAnalytics?: NullableStringFieldUpdateOperationsInput | string | null;
    privacyPolicyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    termsOfServiceUrl?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SiteCustomizationUncheckedUpdateManyInput = {
    siteName?: StringFieldUpdateOperationsInput | string;
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    primaryColor?: StringFieldUpdateOperationsInput | string;
    secondaryColor?: StringFieldUpdateOperationsInput | string;
    accentColor?: StringFieldUpdateOperationsInput | string;
    backgroundColor?: StringFieldUpdateOperationsInput | string;
    textColor?: StringFieldUpdateOperationsInput | string;
    linkColor?: StringFieldUpdateOperationsInput | string;
    primaryFont?: StringFieldUpdateOperationsInput | string;
    secondaryFont?: StringFieldUpdateOperationsInput | string;
    fontSize?: StringFieldUpdateOperationsInput | string;
    headerStyle?: StringFieldUpdateOperationsInput | string;
    footerStyle?: StringFieldUpdateOperationsInput | string;
    borderRadius?: StringFieldUpdateOperationsInput | string;
    showSearch?: BoolFieldUpdateOperationsInput | boolean;
    showWishlist?: BoolFieldUpdateOperationsInput | boolean;
    showCompare?: BoolFieldUpdateOperationsInput | boolean;
    showReviews?: BoolFieldUpdateOperationsInput | boolean;
    enableChat?: BoolFieldUpdateOperationsInput | boolean;
    enableNewsletter?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    contactAddress?: InputJsonValue | InputJsonValue | null;
    businessHours?: InputJsonValue | InputJsonValue | null;
    socialMedia?: InputJsonValue | InputJsonValue | null;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null;
    googleAnalytics?: NullableStringFieldUpdateOperationsInput | string | null;
    privacyPolicyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    termsOfServiceUrl?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ActivityLogCreateInput = {
    id?: string;
    actionType: string;
    description: string;
    entityType?: string | null;
    entityId?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    metadata?: InputJsonValue | null;
    success?: boolean;
    errorMessage?: string | null;
    timestamp?: Date | string;
    staffUser: StaffUserCreateNestedOneWithoutActivityLogsInput;
  };

  export type ActivityLogUncheckedCreateInput = {
    id?: string;
    staffUserId: string;
    actionType: string;
    description: string;
    entityType?: string | null;
    entityId?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    metadata?: InputJsonValue | null;
    success?: boolean;
    errorMessage?: string | null;
    timestamp?: Date | string;
  };

  export type ActivityLogUpdateInput = {
    actionType?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: InputJsonValue | InputJsonValue | null;
    success?: BoolFieldUpdateOperationsInput | boolean;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    staffUser?: StaffUserUpdateOneRequiredWithoutActivityLogsNestedInput;
  };

  export type ActivityLogUncheckedUpdateInput = {
    staffUserId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: InputJsonValue | InputJsonValue | null;
    success?: BoolFieldUpdateOperationsInput | boolean;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityLogCreateManyInput = {
    id?: string;
    staffUserId: string;
    actionType: string;
    description: string;
    entityType?: string | null;
    entityId?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    metadata?: InputJsonValue | null;
    success?: boolean;
    errorMessage?: string | null;
    timestamp?: Date | string;
  };

  export type ActivityLogUpdateManyMutationInput = {
    actionType?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: InputJsonValue | InputJsonValue | null;
    success?: BoolFieldUpdateOperationsInput | boolean;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityLogUncheckedUpdateManyInput = {
    staffUserId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: InputJsonValue | InputJsonValue | null;
    success?: BoolFieldUpdateOperationsInput | boolean;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CustomerCreateInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    addresses?: AddressCreateNestedManyWithoutCustomerInput;
    orders?: OrderCreateNestedManyWithoutCustomerInput;
    reviews?: ProductReviewCreateNestedManyWithoutCustomerInput;
  };

  export type CustomerUncheckedCreateInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerInput;
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput;
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput;
  };

  export type CustomerUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    addresses?: AddressUpdateManyWithoutCustomerNestedInput;
    orders?: OrderUpdateManyWithoutCustomerNestedInput;
    reviews?: ProductReviewUpdateManyWithoutCustomerNestedInput;
  };

  export type CustomerUncheckedUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    addresses?: AddressUncheckedUpdateManyWithoutCustomerNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput;
    reviews?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput;
  };

  export type CustomerCreateManyInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
  };

  export type CustomerUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type CustomerUncheckedUpdateManyInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type AddressCreateInput = {
    id?: string;
    firstName?: string | null;
    lastName?: string | null;
    company?: string | null;
    address1: string;
    address2?: string | null;
    city: string;
    state: string;
    postalCode: string;
    country?: string;
    phone?: string | null;
    type?: $Enums.AddressType;
    isDefault?: boolean;
    isValidated?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    customer: CustomerCreateNestedOneWithoutAddressesInput;
  };

  export type AddressUncheckedCreateInput = {
    id?: string;
    customerId: string;
    firstName?: string | null;
    lastName?: string | null;
    company?: string | null;
    address1: string;
    address2?: string | null;
    city: string;
    state: string;
    postalCode: string;
    country?: string;
    phone?: string | null;
    type?: $Enums.AddressType;
    isDefault?: boolean;
    isValidated?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressUpdateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null;
    lastName?: NullableStringFieldUpdateOperationsInput | string | null;
    company?: NullableStringFieldUpdateOperationsInput | string | null;
    address1?: StringFieldUpdateOperationsInput | string;
    address2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isValidated?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput;
  };

  export type AddressUncheckedUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string;
    firstName?: NullableStringFieldUpdateOperationsInput | string | null;
    lastName?: NullableStringFieldUpdateOperationsInput | string | null;
    company?: NullableStringFieldUpdateOperationsInput | string | null;
    address1?: StringFieldUpdateOperationsInput | string;
    address2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isValidated?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressCreateManyInput = {
    id?: string;
    customerId: string;
    firstName?: string | null;
    lastName?: string | null;
    company?: string | null;
    address1: string;
    address2?: string | null;
    city: string;
    state: string;
    postalCode: string;
    country?: string;
    phone?: string | null;
    type?: $Enums.AddressType;
    isDefault?: boolean;
    isValidated?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressUpdateManyMutationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null;
    lastName?: NullableStringFieldUpdateOperationsInput | string | null;
    company?: NullableStringFieldUpdateOperationsInput | string | null;
    address1?: StringFieldUpdateOperationsInput | string;
    address2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isValidated?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressUncheckedUpdateManyInput = {
    customerId?: StringFieldUpdateOperationsInput | string;
    firstName?: NullableStringFieldUpdateOperationsInput | string | null;
    lastName?: NullableStringFieldUpdateOperationsInput | string | null;
    company?: NullableStringFieldUpdateOperationsInput | string | null;
    address1?: StringFieldUpdateOperationsInput | string;
    address2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isValidated?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CategoryCreateInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: CategoryCreateNestedOneWithoutChildrenInput;
    children?: CategoryCreateNestedManyWithoutParentInput;
    products?: ProductCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    parentId?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput;
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: CategoryUpdateOneWithoutChildrenNestedInput;
    children?: CategoryUpdateManyWithoutParentNestedInput;
    products?: ProductUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput;
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    parentId?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductCreateInput = {
    id?: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    category: CategoryCreateNestedOneWithoutProductsInput;
    reviews?: ProductReviewCreateNestedManyWithoutProductInput;
    orderItems?: OrderItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateInput = {
    id?: string;
    categoryId: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput;
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput;
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateInput = {
    categoryId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type ProductCreateManyInput = {
    id?: string;
    categoryId: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductUncheckedUpdateManyInput = {
    categoryId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductReviewCreateInput = {
    id?: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    product: ProductCreateNestedOneWithoutReviewsInput;
    customer: CustomerCreateNestedOneWithoutReviewsInput;
  };

  export type ProductReviewUncheckedCreateInput = {
    id?: string;
    productId: string;
    customerId: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput;
    customer?: CustomerUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ProductReviewUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductReviewCreateManyInput = {
    id?: string;
    productId: string;
    customerId: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductReviewUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateInput = {
    id?: string;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    paymentStatus?: $Enums.PaymentStatus;
    fulfillmentStatus?: $Enums.FulfillmentStatus;
    priorityLevel?: $Enums.OrderPriority;
    subtotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    shippingAddress: InputJsonValue;
    billingAddress: InputJsonValue;
    shippingCarrier?: string | null;
    shippingMethod?: string | null;
    trackingNumber?: string | null;
    estimatedDelivery?: Date | string | null;
    actualDelivery?: Date | string | null;
    assignedToStaffId?: string | null;
    internalNotes?: string | null;
    customerNotes?: string | null;
    cancellationReason?: string | null;
    cancelledAt?: Date | string | null;
    refundAmount?: number | null;
    refundReason?: string | null;
    refundedAt?: Date | string | null;
    orderDate?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    customer: CustomerCreateNestedOneWithoutOrdersInput;
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateInput = {
    id?: string;
    customerId: string;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    paymentStatus?: $Enums.PaymentStatus;
    fulfillmentStatus?: $Enums.FulfillmentStatus;
    priorityLevel?: $Enums.OrderPriority;
    subtotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    shippingAddress: InputJsonValue;
    billingAddress: InputJsonValue;
    shippingCarrier?: string | null;
    shippingMethod?: string | null;
    trackingNumber?: string | null;
    estimatedDelivery?: Date | string | null;
    actualDelivery?: Date | string | null;
    assignedToStaffId?: string | null;
    internalNotes?: string | null;
    customerNotes?: string | null;
    cancellationReason?: string | null;
    cancelledAt?: Date | string | null;
    refundAmount?: number | null;
    refundReason?: string | null;
    refundedAt?: Date | string | null;
    orderDate?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput;
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderCreateManyInput = {
    id?: string;
    customerId: string;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    paymentStatus?: $Enums.PaymentStatus;
    fulfillmentStatus?: $Enums.FulfillmentStatus;
    priorityLevel?: $Enums.OrderPriority;
    subtotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    shippingAddress: InputJsonValue;
    billingAddress: InputJsonValue;
    shippingCarrier?: string | null;
    shippingMethod?: string | null;
    trackingNumber?: string | null;
    estimatedDelivery?: Date | string | null;
    actualDelivery?: Date | string | null;
    assignedToStaffId?: string | null;
    internalNotes?: string | null;
    customerNotes?: string | null;
    cancellationReason?: string | null;
    cancelledAt?: Date | string | null;
    refundAmount?: number | null;
    refundReason?: string | null;
    refundedAt?: Date | string | null;
    orderDate?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderUpdateManyMutationInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderUncheckedUpdateManyInput = {
    customerId?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemCreateInput = {
    id?: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
    order: OrderCreateNestedOneWithoutOrderItemsInput;
    product: ProductCreateNestedOneWithoutOrderItemsInput;
  };

  export type OrderItemUncheckedCreateInput = {
    id?: string;
    orderId: string;
    productId: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
  };

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput;
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput;
  };

  export type OrderItemUncheckedUpdateInput = {
    orderId?: StringFieldUpdateOperationsInput | string;
    productId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemCreateManyInput = {
    id?: string;
    orderId: string;
    productId: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
  };

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemUncheckedUpdateManyInput = {
    orderId?: StringFieldUpdateOperationsInput | string;
    productId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, "path">>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
    isSet?: boolean;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type StaffUserListRelationFilter = {
    every?: StaffUserWhereInput;
    some?: StaffUserWhereInput;
    none?: StaffUserWhereInput;
  };

  export type StaffUserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    hierarchyLevel?: SortOrder;
    permissions?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    maxUsers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleAvgOrderByAggregateInput = {
    hierarchyLevel?: SortOrder;
    maxUsers?: SortOrder;
  };

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    hierarchyLevel?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    maxUsers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    hierarchyLevel?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    maxUsers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleSumOrderByAggregateInput = {
    hierarchyLevel?: SortOrder;
    maxUsers?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
    isSet?: boolean;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type RoleRelationFilter = {
    is?: RoleWhereInput;
    isNot?: RoleWhereInput;
  };

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput;
    some?: ActivityLogWhereInput;
    none?: ActivityLogWhereInput;
  };

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type StaffUserCountOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    lastLogin?: SortOrder;
    lastLoginIp?: SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrder;
    passwordChangedAt?: SortOrder;
    mustChangePassword?: SortOrder;
    avatar?: SortOrder;
    timezone?: SortOrder;
    language?: SortOrder;
    canAccessAdmin?: SortOrder;
    departmentAccess?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
  };

  export type StaffUserAvgOrderByAggregateInput = {
    loginAttempts?: SortOrder;
  };

  export type StaffUserMaxOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    lastLogin?: SortOrder;
    lastLoginIp?: SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrder;
    passwordChangedAt?: SortOrder;
    mustChangePassword?: SortOrder;
    avatar?: SortOrder;
    timezone?: SortOrder;
    language?: SortOrder;
    canAccessAdmin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
  };

  export type StaffUserMinOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    lastLogin?: SortOrder;
    lastLoginIp?: SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrder;
    passwordChangedAt?: SortOrder;
    mustChangePassword?: SortOrder;
    avatar?: SortOrder;
    timezone?: SortOrder;
    language?: SortOrder;
    canAccessAdmin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
  };

  export type StaffUserSumOrderByAggregateInput = {
    loginAttempts?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type EnumSettingDataTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SettingDataType
      | EnumSettingDataTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SettingDataType[]
      | ListEnumSettingDataTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SettingDataType[]
      | ListEnumSettingDataTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSettingDataTypeFilter<$PrismaModel>
      | $Enums.SettingDataType;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    isSet?: boolean;
  };

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder;
    settingKey?: SortOrder;
    settingValue?: SortOrder;
    category?: SortOrder;
    subcategory?: SortOrder;
    dataType?: SortOrder;
    isEncrypted?: SortOrder;
    isPublic?: SortOrder;
    displayName?: SortOrder;
    description?: SortOrder;
    defaultValue?: SortOrder;
    validation?: SortOrder;
    sortOrder?: SortOrder;
    isVisible?: SortOrder;
    isEditable?: SortOrder;
    updatedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SettingAvgOrderByAggregateInput = {
    sortOrder?: SortOrder;
  };

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder;
    settingKey?: SortOrder;
    category?: SortOrder;
    subcategory?: SortOrder;
    dataType?: SortOrder;
    isEncrypted?: SortOrder;
    isPublic?: SortOrder;
    displayName?: SortOrder;
    description?: SortOrder;
    sortOrder?: SortOrder;
    isVisible?: SortOrder;
    isEditable?: SortOrder;
    updatedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder;
    settingKey?: SortOrder;
    category?: SortOrder;
    subcategory?: SortOrder;
    dataType?: SortOrder;
    isEncrypted?: SortOrder;
    isPublic?: SortOrder;
    displayName?: SortOrder;
    description?: SortOrder;
    sortOrder?: SortOrder;
    isVisible?: SortOrder;
    isEditable?: SortOrder;
    updatedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SettingSumOrderByAggregateInput = {
    sortOrder?: SortOrder;
  };

  export type EnumSettingDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SettingDataType
      | EnumSettingDataTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SettingDataType[]
      | ListEnumSettingDataTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SettingDataType[]
      | ListEnumSettingDataTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSettingDataTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.SettingDataType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSettingDataTypeFilter<$PrismaModel>;
    _max?: NestedEnumSettingDataTypeFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          "path"
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type EnumBannerPositionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.BannerPosition
      | EnumBannerPositionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BannerPosition[]
      | ListEnumBannerPositionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BannerPosition[]
      | ListEnumBannerPositionFieldRefInput<$PrismaModel>;
    not?: NestedEnumBannerPositionFilter<$PrismaModel> | $Enums.BannerPosition;
  };

  export type EnumBannerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BannerType | EnumBannerTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.BannerType[] | ListEnumBannerTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.BannerType[] | ListEnumBannerTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumBannerTypeFilter<$PrismaModel> | $Enums.BannerType;
  };

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    videoUrl?: SortOrder;
    altText?: SortOrder;
    buttonText?: SortOrder;
    buttonUrl?: SortOrder;
    linkTarget?: SortOrder;
    position?: SortOrder;
    displayType?: SortOrder;
    priority?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    borderColor?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    isActive?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type BannerAvgOrderByAggregateInput = {
    priority?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
  };

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    videoUrl?: SortOrder;
    altText?: SortOrder;
    buttonText?: SortOrder;
    buttonUrl?: SortOrder;
    linkTarget?: SortOrder;
    position?: SortOrder;
    displayType?: SortOrder;
    priority?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    borderColor?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    isActive?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    videoUrl?: SortOrder;
    altText?: SortOrder;
    buttonText?: SortOrder;
    buttonUrl?: SortOrder;
    linkTarget?: SortOrder;
    position?: SortOrder;
    displayType?: SortOrder;
    priority?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    borderColor?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    isActive?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type BannerSumOrderByAggregateInput = {
    priority?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
  };

  export type EnumBannerPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.BannerPosition
      | EnumBannerPositionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BannerPosition[]
      | ListEnumBannerPositionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BannerPosition[]
      | ListEnumBannerPositionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBannerPositionWithAggregatesFilter<$PrismaModel>
      | $Enums.BannerPosition;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBannerPositionFilter<$PrismaModel>;
    _max?: NestedEnumBannerPositionFilter<$PrismaModel>;
  };

  export type EnumBannerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BannerType | EnumBannerTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.BannerType[] | ListEnumBannerTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.BannerType[] | ListEnumBannerTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBannerTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.BannerType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBannerTypeFilter<$PrismaModel>;
    _max?: NestedEnumBannerTypeFilter<$PrismaModel>;
  };

  export type EnumSlideTextPositionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SlideTextPosition
      | EnumSlideTextPositionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SlideTextPosition[]
      | ListEnumSlideTextPositionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SlideTextPosition[]
      | ListEnumSlideTextPositionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSlideTextPositionFilter<$PrismaModel>
      | $Enums.SlideTextPosition;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type EnumSlideAnimationFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SlideAnimation
      | EnumSlideAnimationFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SlideAnimation[]
      | ListEnumSlideAnimationFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SlideAnimation[]
      | ListEnumSlideAnimationFieldRefInput<$PrismaModel>;
    not?: NestedEnumSlideAnimationFilter<$PrismaModel> | $Enums.SlideAnimation;
  };

  export type HeroSlideCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    mobileImageUrl?: SortOrder;
    altText?: SortOrder;
    primaryButtonText?: SortOrder;
    primaryButtonUrl?: SortOrder;
    secondaryButtonText?: SortOrder;
    secondaryButtonUrl?: SortOrder;
    textPosition?: SortOrder;
    overlayOpacity?: SortOrder;
    textColor?: SortOrder;
    animationType?: SortOrder;
    displayDuration?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type HeroSlideAvgOrderByAggregateInput = {
    overlayOpacity?: SortOrder;
    displayDuration?: SortOrder;
    sortOrder?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
  };

  export type HeroSlideMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    mobileImageUrl?: SortOrder;
    altText?: SortOrder;
    primaryButtonText?: SortOrder;
    primaryButtonUrl?: SortOrder;
    secondaryButtonText?: SortOrder;
    secondaryButtonUrl?: SortOrder;
    textPosition?: SortOrder;
    overlayOpacity?: SortOrder;
    textColor?: SortOrder;
    animationType?: SortOrder;
    displayDuration?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type HeroSlideMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    subtitle?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    mobileImageUrl?: SortOrder;
    altText?: SortOrder;
    primaryButtonText?: SortOrder;
    primaryButtonUrl?: SortOrder;
    secondaryButtonText?: SortOrder;
    secondaryButtonUrl?: SortOrder;
    textPosition?: SortOrder;
    overlayOpacity?: SortOrder;
    textColor?: SortOrder;
    animationType?: SortOrder;
    displayDuration?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    showOnMobile?: SortOrder;
    showOnTablet?: SortOrder;
    showOnDesktop?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type HeroSlideSumOrderByAggregateInput = {
    overlayOpacity?: SortOrder;
    displayDuration?: SortOrder;
    sortOrder?: SortOrder;
    clickCount?: SortOrder;
    viewCount?: SortOrder;
  };

  export type EnumSlideTextPositionWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.SlideTextPosition
        | EnumSlideTextPositionFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.SlideTextPosition[]
        | ListEnumSlideTextPositionFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.SlideTextPosition[]
        | ListEnumSlideTextPositionFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumSlideTextPositionWithAggregatesFilter<$PrismaModel>
        | $Enums.SlideTextPosition;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumSlideTextPositionFilter<$PrismaModel>;
      _max?: NestedEnumSlideTextPositionFilter<$PrismaModel>;
    };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type EnumSlideAnimationWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SlideAnimation
      | EnumSlideAnimationFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SlideAnimation[]
      | ListEnumSlideAnimationFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SlideAnimation[]
      | ListEnumSlideAnimationFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSlideAnimationWithAggregatesFilter<$PrismaModel>
      | $Enums.SlideAnimation;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSlideAnimationFilter<$PrismaModel>;
    _max?: NestedEnumSlideAnimationFilter<$PrismaModel>;
  };

  export type SiteCustomizationCountOrderByAggregateInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrder;
    logoUrl?: SortOrder;
    faviconUrl?: SortOrder;
    primaryColor?: SortOrder;
    secondaryColor?: SortOrder;
    accentColor?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    linkColor?: SortOrder;
    primaryFont?: SortOrder;
    secondaryFont?: SortOrder;
    fontSize?: SortOrder;
    headerStyle?: SortOrder;
    footerStyle?: SortOrder;
    borderRadius?: SortOrder;
    showSearch?: SortOrder;
    showWishlist?: SortOrder;
    showCompare?: SortOrder;
    showReviews?: SortOrder;
    enableChat?: SortOrder;
    enableNewsletter?: SortOrder;
    contactEmail?: SortOrder;
    contactPhone?: SortOrder;
    contactAddress?: SortOrder;
    businessHours?: SortOrder;
    socialMedia?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    metaKeywords?: SortOrder;
    googleAnalytics?: SortOrder;
    privacyPolicyUrl?: SortOrder;
    termsOfServiceUrl?: SortOrder;
    isActive?: SortOrder;
    updatedAt?: SortOrder;
    updatedBy?: SortOrder;
  };

  export type SiteCustomizationMaxOrderByAggregateInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrder;
    logoUrl?: SortOrder;
    faviconUrl?: SortOrder;
    primaryColor?: SortOrder;
    secondaryColor?: SortOrder;
    accentColor?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    linkColor?: SortOrder;
    primaryFont?: SortOrder;
    secondaryFont?: SortOrder;
    fontSize?: SortOrder;
    headerStyle?: SortOrder;
    footerStyle?: SortOrder;
    borderRadius?: SortOrder;
    showSearch?: SortOrder;
    showWishlist?: SortOrder;
    showCompare?: SortOrder;
    showReviews?: SortOrder;
    enableChat?: SortOrder;
    enableNewsletter?: SortOrder;
    contactEmail?: SortOrder;
    contactPhone?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    metaKeywords?: SortOrder;
    googleAnalytics?: SortOrder;
    privacyPolicyUrl?: SortOrder;
    termsOfServiceUrl?: SortOrder;
    isActive?: SortOrder;
    updatedAt?: SortOrder;
    updatedBy?: SortOrder;
  };

  export type SiteCustomizationMinOrderByAggregateInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrder;
    logoUrl?: SortOrder;
    faviconUrl?: SortOrder;
    primaryColor?: SortOrder;
    secondaryColor?: SortOrder;
    accentColor?: SortOrder;
    backgroundColor?: SortOrder;
    textColor?: SortOrder;
    linkColor?: SortOrder;
    primaryFont?: SortOrder;
    secondaryFont?: SortOrder;
    fontSize?: SortOrder;
    headerStyle?: SortOrder;
    footerStyle?: SortOrder;
    borderRadius?: SortOrder;
    showSearch?: SortOrder;
    showWishlist?: SortOrder;
    showCompare?: SortOrder;
    showReviews?: SortOrder;
    enableChat?: SortOrder;
    enableNewsletter?: SortOrder;
    contactEmail?: SortOrder;
    contactPhone?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    metaKeywords?: SortOrder;
    googleAnalytics?: SortOrder;
    privacyPolicyUrl?: SortOrder;
    termsOfServiceUrl?: SortOrder;
    isActive?: SortOrder;
    updatedAt?: SortOrder;
    updatedBy?: SortOrder;
  };

  export type StaffUserRelationFilter = {
    is?: StaffUserWhereInput;
    isNot?: StaffUserWhereInput;
  };

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder;
    staffUserId?: SortOrder;
    actionType?: SortOrder;
    description?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    metadata?: SortOrder;
    success?: SortOrder;
    errorMessage?: SortOrder;
    timestamp?: SortOrder;
  };

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    staffUserId?: SortOrder;
    actionType?: SortOrder;
    description?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    success?: SortOrder;
    errorMessage?: SortOrder;
    timestamp?: SortOrder;
  };

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder;
    staffUserId?: SortOrder;
    actionType?: SortOrder;
    description?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    success?: SortOrder;
    errorMessage?: SortOrder;
    timestamp?: SortOrder;
  };

  export type EnumProfessionalTierFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ProfessionalTier
      | EnumProfessionalTierFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ProfessionalTier[]
      | ListEnumProfessionalTierFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ProfessionalTier[]
      | ListEnumProfessionalTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumProfessionalTierFilter<$PrismaModel>
      | $Enums.ProfessionalTier;
  };

  export type BusinessInfoNullableCompositeFilter = {
    equals?: BusinessInfoObjectEqualityInput | null;
    is?: BusinessInfoWhereInput | null;
    isNot?: BusinessInfoWhereInput | null;
    isSet?: boolean;
  };

  export type BusinessInfoObjectEqualityInput = {
    companyName: string;
    taxId?: string | null;
    licenseNumber?: string | null;
    website?: string | null;
    verified: boolean;
    verificationDocs?: string[];
    yearEstablished?: number | null;
    employeeCount?: string | null;
  };

  export type EnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CustomerType[]
      | ListEnumCustomerTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CustomerType[]
      | ListEnumCustomerTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType;
  };

  export type EnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>;
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>;
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel;
  };

  export type AddressListRelationFilter = {
    every?: AddressWhereInput;
    some?: AddressWhereInput;
    none?: AddressWhereInput;
  };

  export type OrderListRelationFilter = {
    every?: OrderWhereInput;
    some?: OrderWhereInput;
    none?: OrderWhereInput;
  };

  export type ProductReviewListRelationFilter = {
    every?: ProductReviewWhereInput;
    some?: ProductReviewWhereInput;
    none?: ProductReviewWhereInput;
  };

  export type BusinessInfoOrderByInput = {
    companyName?: SortOrder;
    taxId?: SortOrder;
    licenseNumber?: SortOrder;
    website?: SortOrder;
    verified?: SortOrder;
    verificationDocs?: SortOrder;
    yearEstablished?: SortOrder;
    employeeCount?: SortOrder;
  };

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProductReviewOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    emailVerified?: SortOrder;
    isActive?: SortOrder;
    professionalTier?: SortOrder;
    discountRate?: SortOrder;
    totalOrders?: SortOrder;
    totalSpent?: SortOrder;
    lifetimeValue?: SortOrder;
    averageOrderValue?: SortOrder;
    preferredPaymentMethod?: SortOrder;
    communicationPrefs?: SortOrder;
    timezone?: SortOrder;
    customerType?: SortOrder;
    riskLevel?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
  };

  export type CustomerAvgOrderByAggregateInput = {
    discountRate?: SortOrder;
    totalOrders?: SortOrder;
    totalSpent?: SortOrder;
    lifetimeValue?: SortOrder;
    averageOrderValue?: SortOrder;
  };

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    emailVerified?: SortOrder;
    isActive?: SortOrder;
    professionalTier?: SortOrder;
    discountRate?: SortOrder;
    totalOrders?: SortOrder;
    totalSpent?: SortOrder;
    lifetimeValue?: SortOrder;
    averageOrderValue?: SortOrder;
    preferredPaymentMethod?: SortOrder;
    timezone?: SortOrder;
    customerType?: SortOrder;
    riskLevel?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
  };

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    emailVerified?: SortOrder;
    isActive?: SortOrder;
    professionalTier?: SortOrder;
    discountRate?: SortOrder;
    totalOrders?: SortOrder;
    totalSpent?: SortOrder;
    lifetimeValue?: SortOrder;
    averageOrderValue?: SortOrder;
    preferredPaymentMethod?: SortOrder;
    timezone?: SortOrder;
    customerType?: SortOrder;
    riskLevel?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLogin?: SortOrder;
  };

  export type CustomerSumOrderByAggregateInput = {
    discountRate?: SortOrder;
    totalOrders?: SortOrder;
    totalSpent?: SortOrder;
    lifetimeValue?: SortOrder;
    averageOrderValue?: SortOrder;
  };

  export type EnumProfessionalTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ProfessionalTier
      | EnumProfessionalTierFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ProfessionalTier[]
      | ListEnumProfessionalTierFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ProfessionalTier[]
      | ListEnumProfessionalTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumProfessionalTierWithAggregatesFilter<$PrismaModel>
      | $Enums.ProfessionalTier;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumProfessionalTierFilter<$PrismaModel>;
    _max?: NestedEnumProfessionalTierFilter<$PrismaModel>;
  };

  export type EnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CustomerType[]
      | ListEnumCustomerTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CustomerType[]
      | ListEnumCustomerTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.CustomerType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>;
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>;
  };

  export type EnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>;
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel>
      | $Enums.RiskLevel;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>;
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>;
  };

  export type EnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AddressType[]
      | ListEnumAddressTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType;
  };

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput;
    isNot?: CustomerWhereInput;
  };

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    company?: SortOrder;
    address1?: SortOrder;
    address2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    type?: SortOrder;
    isDefault?: SortOrder;
    isValidated?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    company?: SortOrder;
    address1?: SortOrder;
    address2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    type?: SortOrder;
    isDefault?: SortOrder;
    isValidated?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    company?: SortOrder;
    address1?: SortOrder;
    address2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    postalCode?: SortOrder;
    country?: SortOrder;
    phone?: SortOrder;
    type?: SortOrder;
    isDefault?: SortOrder;
    isValidated?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AddressType[]
      | ListEnumAddressTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.AddressType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>;
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>;
  };

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null;
    isNot?: CategoryWhereInput | null;
  };

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput;
    some?: CategoryWhereInput;
    none?: CategoryWhereInput;
  };

  export type ProductListRelationFilter = {
    every?: ProductWhereInput;
    some?: ProductWhereInput;
    none?: ProductWhereInput;
  };

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrder;
    iconClass?: SortOrder;
    parentId?: SortOrder;
    image?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    isFeatured?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    productCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder;
    productCount?: SortOrder;
  };

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrder;
    iconClass?: SortOrder;
    parentId?: SortOrder;
    image?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    isFeatured?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    productCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrder;
    iconClass?: SortOrder;
    parentId?: SortOrder;
    image?: SortOrder;
    sortOrder?: SortOrder;
    isActive?: SortOrder;
    isFeatured?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    productCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder;
    productCount?: SortOrder;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ProductStatus
      | EnumProductStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ProductStatus[]
      | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ProductStatus[]
      | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus;
  };

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ApprovalStatus
      | EnumApprovalStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ApprovalStatus[]
      | ListEnumApprovalStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ApprovalStatus[]
      | ListEnumApprovalStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus;
  };

  export type VehicleCompatibilityNullableCompositeFilter = {
    equals?: VehicleCompatibilityObjectEqualityInput | null;
    is?: VehicleCompatibilityWhereInput | null;
    isNot?: VehicleCompatibilityWhereInput | null;
    isSet?: boolean;
  };

  export type VehicleCompatibilityObjectEqualityInput = {
    makes?: string[];
    models?: string[];
    years?: string[];
    engineTypes?: string[];
    transmissions?: string[];
    notes?: string | null;
  };

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput;
    isNot?: CategoryWhereInput;
  };

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput;
    some?: OrderItemWhereInput;
    none?: OrderItemWhereInput;
  };

  export type VehicleCompatibilityOrderByInput = {
    makes?: SortOrder;
    models?: SortOrder;
    years?: SortOrder;
    engineTypes?: SortOrder;
    transmissions?: SortOrder;
    notes?: SortOrder;
  };

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder;
    categoryId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    shortDescription?: SortOrder;
    regularPrice?: SortOrder;
    salePrice?: SortOrder;
    costPrice?: SortOrder;
    sku?: SortOrder;
    partNumber?: SortOrder;
    upc?: SortOrder;
    stockQuantity?: SortOrder;
    lowStockThreshold?: SortOrder;
    trackInventory?: SortOrder;
    allowBackorders?: SortOrder;
    professionalOnly?: SortOrder;
    minimumOrderQuantity?: SortOrder;
    status?: SortOrder;
    approvalStatus?: SortOrder;
    featured?: SortOrder;
    onSale?: SortOrder;
    newProduct?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    tags?: SortOrder;
    weight?: SortOrder;
    dimensions?: SortOrder;
    requiresShipping?: SortOrder;
    shippingClass?: SortOrder;
    version?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductAvgOrderByAggregateInput = {
    regularPrice?: SortOrder;
    salePrice?: SortOrder;
    costPrice?: SortOrder;
    stockQuantity?: SortOrder;
    lowStockThreshold?: SortOrder;
    minimumOrderQuantity?: SortOrder;
    weight?: SortOrder;
    version?: SortOrder;
  };

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder;
    categoryId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    shortDescription?: SortOrder;
    regularPrice?: SortOrder;
    salePrice?: SortOrder;
    costPrice?: SortOrder;
    sku?: SortOrder;
    partNumber?: SortOrder;
    upc?: SortOrder;
    stockQuantity?: SortOrder;
    lowStockThreshold?: SortOrder;
    trackInventory?: SortOrder;
    allowBackorders?: SortOrder;
    professionalOnly?: SortOrder;
    minimumOrderQuantity?: SortOrder;
    status?: SortOrder;
    approvalStatus?: SortOrder;
    featured?: SortOrder;
    onSale?: SortOrder;
    newProduct?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    weight?: SortOrder;
    requiresShipping?: SortOrder;
    shippingClass?: SortOrder;
    version?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder;
    categoryId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    shortDescription?: SortOrder;
    regularPrice?: SortOrder;
    salePrice?: SortOrder;
    costPrice?: SortOrder;
    sku?: SortOrder;
    partNumber?: SortOrder;
    upc?: SortOrder;
    stockQuantity?: SortOrder;
    lowStockThreshold?: SortOrder;
    trackInventory?: SortOrder;
    allowBackorders?: SortOrder;
    professionalOnly?: SortOrder;
    minimumOrderQuantity?: SortOrder;
    status?: SortOrder;
    approvalStatus?: SortOrder;
    featured?: SortOrder;
    onSale?: SortOrder;
    newProduct?: SortOrder;
    metaTitle?: SortOrder;
    metaDescription?: SortOrder;
    weight?: SortOrder;
    requiresShipping?: SortOrder;
    shippingClass?: SortOrder;
    version?: SortOrder;
    createdBy?: SortOrder;
    lastModifiedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductSumOrderByAggregateInput = {
    regularPrice?: SortOrder;
    salePrice?: SortOrder;
    costPrice?: SortOrder;
    stockQuantity?: SortOrder;
    lowStockThreshold?: SortOrder;
    minimumOrderQuantity?: SortOrder;
    weight?: SortOrder;
    version?: SortOrder;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ProductStatus
      | EnumProductStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ProductStatus[]
      | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ProductStatus[]
      | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumProductStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ProductStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumProductStatusFilter<$PrismaModel>;
    _max?: NestedEnumProductStatusFilter<$PrismaModel>;
  };

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ApprovalStatus
      | EnumApprovalStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ApprovalStatus[]
      | ListEnumApprovalStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ApprovalStatus[]
      | ListEnumApprovalStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ApprovalStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>;
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>;
  };

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus;
  };

  export type ProductRelationFilter = {
    is?: ProductWhereInput;
    isNot?: ProductWhereInput;
  };

  export type ProductReviewCountOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
    customerId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    verified?: SortOrder;
    helpful?: SortOrder;
    status?: SortOrder;
    moderatedBy?: SortOrder;
    moderatedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductReviewAvgOrderByAggregateInput = {
    rating?: SortOrder;
    helpful?: SortOrder;
  };

  export type ProductReviewMaxOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
    customerId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    verified?: SortOrder;
    helpful?: SortOrder;
    status?: SortOrder;
    moderatedBy?: SortOrder;
    moderatedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductReviewMinOrderByAggregateInput = {
    id?: SortOrder;
    productId?: SortOrder;
    customerId?: SortOrder;
    rating?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    verified?: SortOrder;
    helpful?: SortOrder;
    status?: SortOrder;
    moderatedBy?: SortOrder;
    moderatedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ProductReviewSumOrderByAggregateInput = {
    rating?: SortOrder;
    helpful?: SortOrder;
  };

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ReviewStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>;
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>;
  };

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.OrderStatus[]
      | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus;
  };

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus;
  };

  export type EnumFulfillmentStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.FulfillmentStatus
      | EnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FulfillmentStatus[]
      | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FulfillmentStatus[]
      | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFulfillmentStatusFilter<$PrismaModel>
      | $Enums.FulfillmentStatus;
  };

  export type EnumOrderPriorityFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.OrderPriority
      | EnumOrderPriorityFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.OrderPriority[]
      | ListEnumOrderPriorityFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.OrderPriority[]
      | ListEnumOrderPriorityFieldRefInput<$PrismaModel>;
    not?: NestedEnumOrderPriorityFilter<$PrismaModel> | $Enums.OrderPriority;
  };

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    orderNumber?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    fulfillmentStatus?: SortOrder;
    priorityLevel?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    shippingAmount?: SortOrder;
    discountAmount?: SortOrder;
    totalAmount?: SortOrder;
    paymentMethod?: SortOrder;
    paymentReference?: SortOrder;
    shippingAddress?: SortOrder;
    billingAddress?: SortOrder;
    shippingCarrier?: SortOrder;
    shippingMethod?: SortOrder;
    trackingNumber?: SortOrder;
    estimatedDelivery?: SortOrder;
    actualDelivery?: SortOrder;
    assignedToStaffId?: SortOrder;
    internalNotes?: SortOrder;
    customerNotes?: SortOrder;
    cancellationReason?: SortOrder;
    cancelledAt?: SortOrder;
    refundAmount?: SortOrder;
    refundReason?: SortOrder;
    refundedAt?: SortOrder;
    orderDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    shippingAmount?: SortOrder;
    discountAmount?: SortOrder;
    totalAmount?: SortOrder;
    refundAmount?: SortOrder;
  };

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    orderNumber?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    fulfillmentStatus?: SortOrder;
    priorityLevel?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    shippingAmount?: SortOrder;
    discountAmount?: SortOrder;
    totalAmount?: SortOrder;
    paymentMethod?: SortOrder;
    paymentReference?: SortOrder;
    shippingCarrier?: SortOrder;
    shippingMethod?: SortOrder;
    trackingNumber?: SortOrder;
    estimatedDelivery?: SortOrder;
    actualDelivery?: SortOrder;
    assignedToStaffId?: SortOrder;
    internalNotes?: SortOrder;
    customerNotes?: SortOrder;
    cancellationReason?: SortOrder;
    cancelledAt?: SortOrder;
    refundAmount?: SortOrder;
    refundReason?: SortOrder;
    refundedAt?: SortOrder;
    orderDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    orderNumber?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    fulfillmentStatus?: SortOrder;
    priorityLevel?: SortOrder;
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    shippingAmount?: SortOrder;
    discountAmount?: SortOrder;
    totalAmount?: SortOrder;
    paymentMethod?: SortOrder;
    paymentReference?: SortOrder;
    shippingCarrier?: SortOrder;
    shippingMethod?: SortOrder;
    trackingNumber?: SortOrder;
    estimatedDelivery?: SortOrder;
    actualDelivery?: SortOrder;
    assignedToStaffId?: SortOrder;
    internalNotes?: SortOrder;
    customerNotes?: SortOrder;
    cancellationReason?: SortOrder;
    cancelledAt?: SortOrder;
    refundAmount?: SortOrder;
    refundReason?: SortOrder;
    refundedAt?: SortOrder;
    orderDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrderSumOrderByAggregateInput = {
    subtotal?: SortOrder;
    taxAmount?: SortOrder;
    shippingAmount?: SortOrder;
    discountAmount?: SortOrder;
    totalAmount?: SortOrder;
    refundAmount?: SortOrder;
  };

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.OrderStatus[]
      | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.OrderStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>;
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>;
  };

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>;
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>;
  };

  export type EnumFulfillmentStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.FulfillmentStatus
        | EnumFulfillmentStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.FulfillmentStatus[]
        | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.FulfillmentStatus[]
        | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumFulfillmentStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.FulfillmentStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumFulfillmentStatusFilter<$PrismaModel>;
      _max?: NestedEnumFulfillmentStatusFilter<$PrismaModel>;
    };

  export type EnumOrderPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.OrderPriority
      | EnumOrderPriorityFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.OrderPriority[]
      | ListEnumOrderPriorityFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.OrderPriority[]
      | ListEnumOrderPriorityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumOrderPriorityWithAggregatesFilter<$PrismaModel>
      | $Enums.OrderPriority;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumOrderPriorityFilter<$PrismaModel>;
    _max?: NestedEnumOrderPriorityFilter<$PrismaModel>;
  };

  export type OrderRelationFilter = {
    is?: OrderWhereInput;
    isNot?: OrderWhereInput;
  };

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    quantity?: SortOrder;
    priceAtPurchase?: SortOrder;
    productNameAtPurchase?: SortOrder;
    quantityShipped?: SortOrder;
    quantityRefunded?: SortOrder;
  };

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder;
    priceAtPurchase?: SortOrder;
    quantityShipped?: SortOrder;
    quantityRefunded?: SortOrder;
  };

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    quantity?: SortOrder;
    priceAtPurchase?: SortOrder;
    productNameAtPurchase?: SortOrder;
    quantityShipped?: SortOrder;
    quantityRefunded?: SortOrder;
  };

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    productId?: SortOrder;
    quantity?: SortOrder;
    priceAtPurchase?: SortOrder;
    productNameAtPurchase?: SortOrder;
    quantityShipped?: SortOrder;
    quantityRefunded?: SortOrder;
  };

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder;
    priceAtPurchase?: SortOrder;
    quantityShipped?: SortOrder;
    quantityRefunded?: SortOrder;
  };

  export type StaffUserCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          StaffUserCreateWithoutRoleInput,
          StaffUserUncheckedCreateWithoutRoleInput
        >
      | StaffUserCreateWithoutRoleInput[]
      | StaffUserUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | StaffUserCreateOrConnectWithoutRoleInput
      | StaffUserCreateOrConnectWithoutRoleInput[];
    createMany?: StaffUserCreateManyRoleInputEnvelope;
    connect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
  };

  export type StaffUserUncheckedCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          StaffUserCreateWithoutRoleInput,
          StaffUserUncheckedCreateWithoutRoleInput
        >
      | StaffUserCreateWithoutRoleInput[]
      | StaffUserUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | StaffUserCreateOrConnectWithoutRoleInput
      | StaffUserCreateOrConnectWithoutRoleInput[];
    createMany?: StaffUserCreateManyRoleInputEnvelope;
    connect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
    unset?: boolean;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
    unset?: boolean;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type StaffUserUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          StaffUserCreateWithoutRoleInput,
          StaffUserUncheckedCreateWithoutRoleInput
        >
      | StaffUserCreateWithoutRoleInput[]
      | StaffUserUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | StaffUserCreateOrConnectWithoutRoleInput
      | StaffUserCreateOrConnectWithoutRoleInput[];
    upsert?:
      | StaffUserUpsertWithWhereUniqueWithoutRoleInput
      | StaffUserUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: StaffUserCreateManyRoleInputEnvelope;
    set?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
    disconnect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
    delete?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
    connect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
    update?:
      | StaffUserUpdateWithWhereUniqueWithoutRoleInput
      | StaffUserUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | StaffUserUpdateManyWithWhereWithoutRoleInput
      | StaffUserUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: StaffUserScalarWhereInput | StaffUserScalarWhereInput[];
  };

  export type StaffUserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          StaffUserCreateWithoutRoleInput,
          StaffUserUncheckedCreateWithoutRoleInput
        >
      | StaffUserCreateWithoutRoleInput[]
      | StaffUserUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | StaffUserCreateOrConnectWithoutRoleInput
      | StaffUserCreateOrConnectWithoutRoleInput[];
    upsert?:
      | StaffUserUpsertWithWhereUniqueWithoutRoleInput
      | StaffUserUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: StaffUserCreateManyRoleInputEnvelope;
    set?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
    disconnect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
    delete?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
    connect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[];
    update?:
      | StaffUserUpdateWithWhereUniqueWithoutRoleInput
      | StaffUserUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | StaffUserUpdateManyWithWhereWithoutRoleInput
      | StaffUserUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: StaffUserScalarWhereInput | StaffUserScalarWhereInput[];
  };

  export type StaffUserCreatedepartmentAccessInput = {
    set: string[];
  };

  export type RoleCreateNestedOneWithoutStaffUsersInput = {
    create?: XOR<
      RoleCreateWithoutStaffUsersInput,
      RoleUncheckedCreateWithoutStaffUsersInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutStaffUsersInput;
    connect?: RoleWhereUniqueInput;
  };

  export type ActivityLogCreateNestedManyWithoutStaffUserInput = {
    create?:
      | XOR<
          ActivityLogCreateWithoutStaffUserInput,
          ActivityLogUncheckedCreateWithoutStaffUserInput
        >
      | ActivityLogCreateWithoutStaffUserInput[]
      | ActivityLogUncheckedCreateWithoutStaffUserInput[];
    connectOrCreate?:
      | ActivityLogCreateOrConnectWithoutStaffUserInput
      | ActivityLogCreateOrConnectWithoutStaffUserInput[];
    createMany?: ActivityLogCreateManyStaffUserInputEnvelope;
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
  };

  export type ActivityLogUncheckedCreateNestedManyWithoutStaffUserInput = {
    create?:
      | XOR<
          ActivityLogCreateWithoutStaffUserInput,
          ActivityLogUncheckedCreateWithoutStaffUserInput
        >
      | ActivityLogCreateWithoutStaffUserInput[]
      | ActivityLogUncheckedCreateWithoutStaffUserInput[];
    connectOrCreate?:
      | ActivityLogCreateOrConnectWithoutStaffUserInput
      | ActivityLogCreateOrConnectWithoutStaffUserInput[];
    createMany?: ActivityLogCreateManyStaffUserInputEnvelope;
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
    unset?: boolean;
  };

  export type StaffUserUpdatedepartmentAccessInput = {
    set?: string[];
    push?: string | string[];
  };

  export type RoleUpdateOneRequiredWithoutStaffUsersNestedInput = {
    create?: XOR<
      RoleCreateWithoutStaffUsersInput,
      RoleUncheckedCreateWithoutStaffUsersInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutStaffUsersInput;
    upsert?: RoleUpsertWithoutStaffUsersInput;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      XOR<
        RoleUpdateToOneWithWhereWithoutStaffUsersInput,
        RoleUpdateWithoutStaffUsersInput
      >,
      RoleUncheckedUpdateWithoutStaffUsersInput
    >;
  };

  export type ActivityLogUpdateManyWithoutStaffUserNestedInput = {
    create?:
      | XOR<
          ActivityLogCreateWithoutStaffUserInput,
          ActivityLogUncheckedCreateWithoutStaffUserInput
        >
      | ActivityLogCreateWithoutStaffUserInput[]
      | ActivityLogUncheckedCreateWithoutStaffUserInput[];
    connectOrCreate?:
      | ActivityLogCreateOrConnectWithoutStaffUserInput
      | ActivityLogCreateOrConnectWithoutStaffUserInput[];
    upsert?:
      | ActivityLogUpsertWithWhereUniqueWithoutStaffUserInput
      | ActivityLogUpsertWithWhereUniqueWithoutStaffUserInput[];
    createMany?: ActivityLogCreateManyStaffUserInputEnvelope;
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
    update?:
      | ActivityLogUpdateWithWhereUniqueWithoutStaffUserInput
      | ActivityLogUpdateWithWhereUniqueWithoutStaffUserInput[];
    updateMany?:
      | ActivityLogUpdateManyWithWhereWithoutStaffUserInput
      | ActivityLogUpdateManyWithWhereWithoutStaffUserInput[];
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[];
  };

  export type ActivityLogUncheckedUpdateManyWithoutStaffUserNestedInput = {
    create?:
      | XOR<
          ActivityLogCreateWithoutStaffUserInput,
          ActivityLogUncheckedCreateWithoutStaffUserInput
        >
      | ActivityLogCreateWithoutStaffUserInput[]
      | ActivityLogUncheckedCreateWithoutStaffUserInput[];
    connectOrCreate?:
      | ActivityLogCreateOrConnectWithoutStaffUserInput
      | ActivityLogCreateOrConnectWithoutStaffUserInput[];
    upsert?:
      | ActivityLogUpsertWithWhereUniqueWithoutStaffUserInput
      | ActivityLogUpsertWithWhereUniqueWithoutStaffUserInput[];
    createMany?: ActivityLogCreateManyStaffUserInputEnvelope;
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[];
    update?:
      | ActivityLogUpdateWithWhereUniqueWithoutStaffUserInput
      | ActivityLogUpdateWithWhereUniqueWithoutStaffUserInput[];
    updateMany?:
      | ActivityLogUpdateManyWithWhereWithoutStaffUserInput
      | ActivityLogUpdateManyWithWhereWithoutStaffUserInput[];
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[];
  };

  export type EnumSettingDataTypeFieldUpdateOperationsInput = {
    set?: $Enums.SettingDataType;
  };

  export type EnumBannerPositionFieldUpdateOperationsInput = {
    set?: $Enums.BannerPosition;
  };

  export type EnumBannerTypeFieldUpdateOperationsInput = {
    set?: $Enums.BannerType;
  };

  export type EnumSlideTextPositionFieldUpdateOperationsInput = {
    set?: $Enums.SlideTextPosition;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumSlideAnimationFieldUpdateOperationsInput = {
    set?: $Enums.SlideAnimation;
  };

  export type StaffUserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<
      StaffUserCreateWithoutActivityLogsInput,
      StaffUserUncheckedCreateWithoutActivityLogsInput
    >;
    connectOrCreate?: StaffUserCreateOrConnectWithoutActivityLogsInput;
    connect?: StaffUserWhereUniqueInput;
  };

  export type StaffUserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<
      StaffUserCreateWithoutActivityLogsInput,
      StaffUserUncheckedCreateWithoutActivityLogsInput
    >;
    connectOrCreate?: StaffUserCreateOrConnectWithoutActivityLogsInput;
    upsert?: StaffUserUpsertWithoutActivityLogsInput;
    connect?: StaffUserWhereUniqueInput;
    update?: XOR<
      XOR<
        StaffUserUpdateToOneWithWhereWithoutActivityLogsInput,
        StaffUserUpdateWithoutActivityLogsInput
      >,
      StaffUserUncheckedUpdateWithoutActivityLogsInput
    >;
  };

  export type BusinessInfoNullableCreateEnvelopeInput = {
    set?: BusinessInfoCreateInput | null;
  };

  export type BusinessInfoCreateInput = {
    companyName: string;
    taxId?: string | null;
    licenseNumber?: string | null;
    website?: string | null;
    verified?: boolean;
    verificationDocs?: BusinessInfoCreateverificationDocsInput | string[];
    yearEstablished?: number | null;
    employeeCount?: string | null;
  };

  export type AddressCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          AddressCreateWithoutCustomerInput,
          AddressUncheckedCreateWithoutCustomerInput
        >
      | AddressCreateWithoutCustomerInput[]
      | AddressUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | AddressCreateOrConnectWithoutCustomerInput
      | AddressCreateOrConnectWithoutCustomerInput[];
    createMany?: AddressCreateManyCustomerInputEnvelope;
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
  };

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          OrderCreateWithoutCustomerInput,
          OrderUncheckedCreateWithoutCustomerInput
        >
      | OrderCreateWithoutCustomerInput[]
      | OrderUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutCustomerInput
      | OrderCreateOrConnectWithoutCustomerInput[];
    createMany?: OrderCreateManyCustomerInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type ProductReviewCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          ProductReviewCreateWithoutCustomerInput,
          ProductReviewUncheckedCreateWithoutCustomerInput
        >
      | ProductReviewCreateWithoutCustomerInput[]
      | ProductReviewUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | ProductReviewCreateOrConnectWithoutCustomerInput
      | ProductReviewCreateOrConnectWithoutCustomerInput[];
    createMany?: ProductReviewCreateManyCustomerInputEnvelope;
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
  };

  export type AddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          AddressCreateWithoutCustomerInput,
          AddressUncheckedCreateWithoutCustomerInput
        >
      | AddressCreateWithoutCustomerInput[]
      | AddressUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | AddressCreateOrConnectWithoutCustomerInput
      | AddressCreateOrConnectWithoutCustomerInput[];
    createMany?: AddressCreateManyCustomerInputEnvelope;
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          OrderCreateWithoutCustomerInput,
          OrderUncheckedCreateWithoutCustomerInput
        >
      | OrderCreateWithoutCustomerInput[]
      | OrderUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutCustomerInput
      | OrderCreateOrConnectWithoutCustomerInput[];
    createMany?: OrderCreateManyCustomerInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type ProductReviewUncheckedCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          ProductReviewCreateWithoutCustomerInput,
          ProductReviewUncheckedCreateWithoutCustomerInput
        >
      | ProductReviewCreateWithoutCustomerInput[]
      | ProductReviewUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | ProductReviewCreateOrConnectWithoutCustomerInput
      | ProductReviewCreateOrConnectWithoutCustomerInput[];
    createMany?: ProductReviewCreateManyCustomerInputEnvelope;
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
  };

  export type EnumProfessionalTierFieldUpdateOperationsInput = {
    set?: $Enums.ProfessionalTier;
  };

  export type BusinessInfoNullableUpdateEnvelopeInput = {
    set?: BusinessInfoCreateInput | null;
    upsert?: BusinessInfoUpsertInput;
    unset?: boolean;
  };

  export type EnumCustomerTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerType;
  };

  export type EnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel;
  };

  export type AddressUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          AddressCreateWithoutCustomerInput,
          AddressUncheckedCreateWithoutCustomerInput
        >
      | AddressCreateWithoutCustomerInput[]
      | AddressUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | AddressCreateOrConnectWithoutCustomerInput
      | AddressCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | AddressUpsertWithWhereUniqueWithoutCustomerInput
      | AddressUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: AddressCreateManyCustomerInputEnvelope;
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    update?:
      | AddressUpdateWithWhereUniqueWithoutCustomerInput
      | AddressUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | AddressUpdateManyWithWhereWithoutCustomerInput
      | AddressUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[];
  };

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          OrderCreateWithoutCustomerInput,
          OrderUncheckedCreateWithoutCustomerInput
        >
      | OrderCreateWithoutCustomerInput[]
      | OrderUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutCustomerInput
      | OrderCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutCustomerInput
      | OrderUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: OrderCreateManyCustomerInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutCustomerInput
      | OrderUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutCustomerInput
      | OrderUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type ProductReviewUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          ProductReviewCreateWithoutCustomerInput,
          ProductReviewUncheckedCreateWithoutCustomerInput
        >
      | ProductReviewCreateWithoutCustomerInput[]
      | ProductReviewUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | ProductReviewCreateOrConnectWithoutCustomerInput
      | ProductReviewCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | ProductReviewUpsertWithWhereUniqueWithoutCustomerInput
      | ProductReviewUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: ProductReviewCreateManyCustomerInputEnvelope;
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    disconnect?:
      | ProductReviewWhereUniqueInput
      | ProductReviewWhereUniqueInput[];
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    update?:
      | ProductReviewUpdateWithWhereUniqueWithoutCustomerInput
      | ProductReviewUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | ProductReviewUpdateManyWithWhereWithoutCustomerInput
      | ProductReviewUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?:
      | ProductReviewScalarWhereInput
      | ProductReviewScalarWhereInput[];
  };

  export type AddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          AddressCreateWithoutCustomerInput,
          AddressUncheckedCreateWithoutCustomerInput
        >
      | AddressCreateWithoutCustomerInput[]
      | AddressUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | AddressCreateOrConnectWithoutCustomerInput
      | AddressCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | AddressUpsertWithWhereUniqueWithoutCustomerInput
      | AddressUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: AddressCreateManyCustomerInputEnvelope;
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    update?:
      | AddressUpdateWithWhereUniqueWithoutCustomerInput
      | AddressUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | AddressUpdateManyWithWhereWithoutCustomerInput
      | AddressUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          OrderCreateWithoutCustomerInput,
          OrderUncheckedCreateWithoutCustomerInput
        >
      | OrderCreateWithoutCustomerInput[]
      | OrderUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutCustomerInput
      | OrderCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutCustomerInput
      | OrderUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: OrderCreateManyCustomerInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutCustomerInput
      | OrderUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutCustomerInput
      | OrderUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          ProductReviewCreateWithoutCustomerInput,
          ProductReviewUncheckedCreateWithoutCustomerInput
        >
      | ProductReviewCreateWithoutCustomerInput[]
      | ProductReviewUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | ProductReviewCreateOrConnectWithoutCustomerInput
      | ProductReviewCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | ProductReviewUpsertWithWhereUniqueWithoutCustomerInput
      | ProductReviewUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: ProductReviewCreateManyCustomerInputEnvelope;
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    disconnect?:
      | ProductReviewWhereUniqueInput
      | ProductReviewWhereUniqueInput[];
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    update?:
      | ProductReviewUpdateWithWhereUniqueWithoutCustomerInput
      | ProductReviewUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | ProductReviewUpdateManyWithWhereWithoutCustomerInput
      | ProductReviewUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?:
      | ProductReviewScalarWhereInput
      | ProductReviewScalarWhereInput[];
  };

  export type CustomerCreateNestedOneWithoutAddressesInput = {
    create?: XOR<
      CustomerCreateWithoutAddressesInput,
      CustomerUncheckedCreateWithoutAddressesInput
    >;
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput;
    connect?: CustomerWhereUniqueInput;
  };

  export type EnumAddressTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddressType;
  };

  export type CustomerUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<
      CustomerCreateWithoutAddressesInput,
      CustomerUncheckedCreateWithoutAddressesInput
    >;
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput;
    upsert?: CustomerUpsertWithoutAddressesInput;
    connect?: CustomerWhereUniqueInput;
    update?: XOR<
      XOR<
        CustomerUpdateToOneWithWhereWithoutAddressesInput,
        CustomerUpdateWithoutAddressesInput
      >,
      CustomerUncheckedUpdateWithoutAddressesInput
    >;
  };

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<
      CategoryCreateWithoutChildrenInput,
      CategoryUncheckedCreateWithoutChildrenInput
    >;
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput;
    connect?: CategoryWhereUniqueInput;
  };

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          CategoryCreateWithoutParentInput,
          CategoryUncheckedCreateWithoutParentInput
        >
      | CategoryCreateWithoutParentInput[]
      | CategoryUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CategoryCreateOrConnectWithoutParentInput
      | CategoryCreateOrConnectWithoutParentInput[];
    createMany?: CategoryCreateManyParentInputEnvelope;
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
  };

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?:
      | XOR<
          ProductCreateWithoutCategoryInput,
          ProductUncheckedCreateWithoutCategoryInput
        >
      | ProductCreateWithoutCategoryInput[]
      | ProductUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | ProductCreateOrConnectWithoutCategoryInput
      | ProductCreateOrConnectWithoutCategoryInput[];
    createMany?: ProductCreateManyCategoryInputEnvelope;
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
  };

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          CategoryCreateWithoutParentInput,
          CategoryUncheckedCreateWithoutParentInput
        >
      | CategoryCreateWithoutParentInput[]
      | CategoryUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CategoryCreateOrConnectWithoutParentInput
      | CategoryCreateOrConnectWithoutParentInput[];
    createMany?: CategoryCreateManyParentInputEnvelope;
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
  };

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?:
      | XOR<
          ProductCreateWithoutCategoryInput,
          ProductUncheckedCreateWithoutCategoryInput
        >
      | ProductCreateWithoutCategoryInput[]
      | ProductUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | ProductCreateOrConnectWithoutCategoryInput
      | ProductCreateOrConnectWithoutCategoryInput[];
    createMany?: ProductCreateManyCategoryInputEnvelope;
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
  };

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<
      CategoryCreateWithoutChildrenInput,
      CategoryUncheckedCreateWithoutChildrenInput
    >;
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput;
    upsert?: CategoryUpsertWithoutChildrenInput;
    disconnect?: boolean;
    delete?: CategoryWhereInput | boolean;
    connect?: CategoryWhereUniqueInput;
    update?: XOR<
      XOR<
        CategoryUpdateToOneWithWhereWithoutChildrenInput,
        CategoryUpdateWithoutChildrenInput
      >,
      CategoryUncheckedUpdateWithoutChildrenInput
    >;
  };

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          CategoryCreateWithoutParentInput,
          CategoryUncheckedCreateWithoutParentInput
        >
      | CategoryCreateWithoutParentInput[]
      | CategoryUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CategoryCreateOrConnectWithoutParentInput
      | CategoryCreateOrConnectWithoutParentInput[];
    upsert?:
      | CategoryUpsertWithWhereUniqueWithoutParentInput
      | CategoryUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: CategoryCreateManyParentInputEnvelope;
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
    update?:
      | CategoryUpdateWithWhereUniqueWithoutParentInput
      | CategoryUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | CategoryUpdateManyWithWhereWithoutParentInput
      | CategoryUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[];
  };

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?:
      | XOR<
          ProductCreateWithoutCategoryInput,
          ProductUncheckedCreateWithoutCategoryInput
        >
      | ProductCreateWithoutCategoryInput[]
      | ProductUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | ProductCreateOrConnectWithoutCategoryInput
      | ProductCreateOrConnectWithoutCategoryInput[];
    upsert?:
      | ProductUpsertWithWhereUniqueWithoutCategoryInput
      | ProductUpsertWithWhereUniqueWithoutCategoryInput[];
    createMany?: ProductCreateManyCategoryInputEnvelope;
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
    update?:
      | ProductUpdateWithWhereUniqueWithoutCategoryInput
      | ProductUpdateWithWhereUniqueWithoutCategoryInput[];
    updateMany?:
      | ProductUpdateManyWithWhereWithoutCategoryInput
      | ProductUpdateManyWithWhereWithoutCategoryInput[];
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[];
  };

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          CategoryCreateWithoutParentInput,
          CategoryUncheckedCreateWithoutParentInput
        >
      | CategoryCreateWithoutParentInput[]
      | CategoryUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CategoryCreateOrConnectWithoutParentInput
      | CategoryCreateOrConnectWithoutParentInput[];
    upsert?:
      | CategoryUpsertWithWhereUniqueWithoutParentInput
      | CategoryUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: CategoryCreateManyParentInputEnvelope;
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[];
    update?:
      | CategoryUpdateWithWhereUniqueWithoutParentInput
      | CategoryUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | CategoryUpdateManyWithWhereWithoutParentInput
      | CategoryUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[];
  };

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?:
      | XOR<
          ProductCreateWithoutCategoryInput,
          ProductUncheckedCreateWithoutCategoryInput
        >
      | ProductCreateWithoutCategoryInput[]
      | ProductUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | ProductCreateOrConnectWithoutCategoryInput
      | ProductCreateOrConnectWithoutCategoryInput[];
    upsert?:
      | ProductUpsertWithWhereUniqueWithoutCategoryInput
      | ProductUpsertWithWhereUniqueWithoutCategoryInput[];
    createMany?: ProductCreateManyCategoryInputEnvelope;
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[];
    update?:
      | ProductUpdateWithWhereUniqueWithoutCategoryInput
      | ProductUpdateWithWhereUniqueWithoutCategoryInput[];
    updateMany?:
      | ProductUpdateManyWithWhereWithoutCategoryInput
      | ProductUpdateManyWithWhereWithoutCategoryInput[];
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[];
  };

  export type ProductCreatetagsInput = {
    set: string[];
  };

  export type VehicleCompatibilityNullableCreateEnvelopeInput = {
    set?: VehicleCompatibilityCreateInput | null;
  };

  export type VehicleCompatibilityCreateInput = {
    makes?: VehicleCompatibilityCreatemakesInput | string[];
    models?: VehicleCompatibilityCreatemodelsInput | string[];
    years?: VehicleCompatibilityCreateyearsInput | string[];
    engineTypes?: VehicleCompatibilityCreateengineTypesInput | string[];
    transmissions?: VehicleCompatibilityCreatetransmissionsInput | string[];
    notes?: string | null;
  };

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<
      CategoryCreateWithoutProductsInput,
      CategoryUncheckedCreateWithoutProductsInput
    >;
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput;
    connect?: CategoryWhereUniqueInput;
  };

  export type ProductReviewCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<
          ProductReviewCreateWithoutProductInput,
          ProductReviewUncheckedCreateWithoutProductInput
        >
      | ProductReviewCreateWithoutProductInput[]
      | ProductReviewUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | ProductReviewCreateOrConnectWithoutProductInput
      | ProductReviewCreateOrConnectWithoutProductInput[];
    createMany?: ProductReviewCreateManyProductInputEnvelope;
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
  };

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutProductInput,
          OrderItemUncheckedCreateWithoutProductInput
        >
      | OrderItemCreateWithoutProductInput[]
      | OrderItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutProductInput
      | OrderItemCreateOrConnectWithoutProductInput[];
    createMany?: OrderItemCreateManyProductInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type ProductReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<
          ProductReviewCreateWithoutProductInput,
          ProductReviewUncheckedCreateWithoutProductInput
        >
      | ProductReviewCreateWithoutProductInput[]
      | ProductReviewUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | ProductReviewCreateOrConnectWithoutProductInput
      | ProductReviewCreateOrConnectWithoutProductInput[];
    createMany?: ProductReviewCreateManyProductInputEnvelope;
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
  };

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutProductInput,
          OrderItemUncheckedCreateWithoutProductInput
        >
      | OrderItemCreateWithoutProductInput[]
      | OrderItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutProductInput
      | OrderItemCreateOrConnectWithoutProductInput[];
    createMany?: OrderItemCreateManyProductInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
    unset?: boolean;
  };

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus;
  };

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus;
  };

  export type ProductUpdatetagsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type VehicleCompatibilityNullableUpdateEnvelopeInput = {
    set?: VehicleCompatibilityCreateInput | null;
    upsert?: VehicleCompatibilityUpsertInput;
    unset?: boolean;
  };

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<
      CategoryCreateWithoutProductsInput,
      CategoryUncheckedCreateWithoutProductsInput
    >;
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput;
    upsert?: CategoryUpsertWithoutProductsInput;
    connect?: CategoryWhereUniqueInput;
    update?: XOR<
      XOR<
        CategoryUpdateToOneWithWhereWithoutProductsInput,
        CategoryUpdateWithoutProductsInput
      >,
      CategoryUncheckedUpdateWithoutProductsInput
    >;
  };

  export type ProductReviewUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<
          ProductReviewCreateWithoutProductInput,
          ProductReviewUncheckedCreateWithoutProductInput
        >
      | ProductReviewCreateWithoutProductInput[]
      | ProductReviewUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | ProductReviewCreateOrConnectWithoutProductInput
      | ProductReviewCreateOrConnectWithoutProductInput[];
    upsert?:
      | ProductReviewUpsertWithWhereUniqueWithoutProductInput
      | ProductReviewUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: ProductReviewCreateManyProductInputEnvelope;
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    disconnect?:
      | ProductReviewWhereUniqueInput
      | ProductReviewWhereUniqueInput[];
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    update?:
      | ProductReviewUpdateWithWhereUniqueWithoutProductInput
      | ProductReviewUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | ProductReviewUpdateManyWithWhereWithoutProductInput
      | ProductReviewUpdateManyWithWhereWithoutProductInput[];
    deleteMany?:
      | ProductReviewScalarWhereInput
      | ProductReviewScalarWhereInput[];
  };

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutProductInput,
          OrderItemUncheckedCreateWithoutProductInput
        >
      | OrderItemCreateWithoutProductInput[]
      | OrderItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutProductInput
      | OrderItemCreateOrConnectWithoutProductInput[];
    upsert?:
      | OrderItemUpsertWithWhereUniqueWithoutProductInput
      | OrderItemUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: OrderItemCreateManyProductInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?:
      | OrderItemUpdateWithWhereUniqueWithoutProductInput
      | OrderItemUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | OrderItemUpdateManyWithWhereWithoutProductInput
      | OrderItemUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type ProductReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<
          ProductReviewCreateWithoutProductInput,
          ProductReviewUncheckedCreateWithoutProductInput
        >
      | ProductReviewCreateWithoutProductInput[]
      | ProductReviewUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | ProductReviewCreateOrConnectWithoutProductInput
      | ProductReviewCreateOrConnectWithoutProductInput[];
    upsert?:
      | ProductReviewUpsertWithWhereUniqueWithoutProductInput
      | ProductReviewUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: ProductReviewCreateManyProductInputEnvelope;
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    disconnect?:
      | ProductReviewWhereUniqueInput
      | ProductReviewWhereUniqueInput[];
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[];
    update?:
      | ProductReviewUpdateWithWhereUniqueWithoutProductInput
      | ProductReviewUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | ProductReviewUpdateManyWithWhereWithoutProductInput
      | ProductReviewUpdateManyWithWhereWithoutProductInput[];
    deleteMany?:
      | ProductReviewScalarWhereInput
      | ProductReviewScalarWhereInput[];
  };

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutProductInput,
          OrderItemUncheckedCreateWithoutProductInput
        >
      | OrderItemCreateWithoutProductInput[]
      | OrderItemUncheckedCreateWithoutProductInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutProductInput
      | OrderItemCreateOrConnectWithoutProductInput[];
    upsert?:
      | OrderItemUpsertWithWhereUniqueWithoutProductInput
      | OrderItemUpsertWithWhereUniqueWithoutProductInput[];
    createMany?: OrderItemCreateManyProductInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?:
      | OrderItemUpdateWithWhereUniqueWithoutProductInput
      | OrderItemUpdateWithWhereUniqueWithoutProductInput[];
    updateMany?:
      | OrderItemUpdateManyWithWhereWithoutProductInput
      | OrderItemUpdateManyWithWhereWithoutProductInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<
      ProductCreateWithoutReviewsInput,
      ProductUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput;
    connect?: ProductWhereUniqueInput;
  };

  export type CustomerCreateNestedOneWithoutReviewsInput = {
    create?: XOR<
      CustomerCreateWithoutReviewsInput,
      CustomerUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: CustomerCreateOrConnectWithoutReviewsInput;
    connect?: CustomerWhereUniqueInput;
  };

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus;
  };

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<
      ProductCreateWithoutReviewsInput,
      ProductUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput;
    upsert?: ProductUpsertWithoutReviewsInput;
    connect?: ProductWhereUniqueInput;
    update?: XOR<
      XOR<
        ProductUpdateToOneWithWhereWithoutReviewsInput,
        ProductUpdateWithoutReviewsInput
      >,
      ProductUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type CustomerUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<
      CustomerCreateWithoutReviewsInput,
      CustomerUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: CustomerCreateOrConnectWithoutReviewsInput;
    upsert?: CustomerUpsertWithoutReviewsInput;
    connect?: CustomerWhereUniqueInput;
    update?: XOR<
      XOR<
        CustomerUpdateToOneWithWhereWithoutReviewsInput,
        CustomerUpdateWithoutReviewsInput
      >,
      CustomerUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<
      CustomerCreateWithoutOrdersInput,
      CustomerUncheckedCreateWithoutOrdersInput
    >;
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput;
    connect?: CustomerWhereUniqueInput;
  };

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutOrderInput,
          OrderItemUncheckedCreateWithoutOrderInput
        >
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutOrderInput
      | OrderItemCreateOrConnectWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutOrderInput,
          OrderItemUncheckedCreateWithoutOrderInput
        >
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutOrderInput
      | OrderItemCreateOrConnectWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus;
  };

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus;
  };

  export type EnumFulfillmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.FulfillmentStatus;
  };

  export type EnumOrderPriorityFieldUpdateOperationsInput = {
    set?: $Enums.OrderPriority;
  };

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<
      CustomerCreateWithoutOrdersInput,
      CustomerUncheckedCreateWithoutOrdersInput
    >;
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput;
    upsert?: CustomerUpsertWithoutOrdersInput;
    connect?: CustomerWhereUniqueInput;
    update?: XOR<
      XOR<
        CustomerUpdateToOneWithWhereWithoutOrdersInput,
        CustomerUpdateWithoutOrdersInput
      >,
      CustomerUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutOrderInput,
          OrderItemUncheckedCreateWithoutOrderInput
        >
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutOrderInput
      | OrderItemCreateOrConnectWithoutOrderInput[];
    upsert?:
      | OrderItemUpsertWithWhereUniqueWithoutOrderInput
      | OrderItemUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?:
      | OrderItemUpdateWithWhereUniqueWithoutOrderInput
      | OrderItemUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | OrderItemUpdateManyWithWhereWithoutOrderInput
      | OrderItemUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutOrderInput,
          OrderItemUncheckedCreateWithoutOrderInput
        >
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutOrderInput
      | OrderItemCreateOrConnectWithoutOrderInput[];
    upsert?:
      | OrderItemUpsertWithWhereUniqueWithoutOrderInput
      | OrderItemUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?:
      | OrderItemUpdateWithWhereUniqueWithoutOrderInput
      | OrderItemUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | OrderItemUpdateManyWithWhereWithoutOrderInput
      | OrderItemUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<
      OrderCreateWithoutOrderItemsInput,
      OrderUncheckedCreateWithoutOrderItemsInput
    >;
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput;
    connect?: OrderWhereUniqueInput;
  };

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<
      ProductCreateWithoutOrderItemsInput,
      ProductUncheckedCreateWithoutOrderItemsInput
    >;
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput;
    connect?: ProductWhereUniqueInput;
  };

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<
      OrderCreateWithoutOrderItemsInput,
      OrderUncheckedCreateWithoutOrderItemsInput
    >;
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput;
    upsert?: OrderUpsertWithoutOrderItemsInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<
        OrderUpdateToOneWithWhereWithoutOrderItemsInput,
        OrderUpdateWithoutOrderItemsInput
      >,
      OrderUncheckedUpdateWithoutOrderItemsInput
    >;
  };

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<
      ProductCreateWithoutOrderItemsInput,
      ProductUncheckedCreateWithoutOrderItemsInput
    >;
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput;
    upsert?: ProductUpsertWithoutOrderItemsInput;
    connect?: ProductWhereUniqueInput;
    update?: XOR<
      XOR<
        ProductUpdateToOneWithWhereWithoutOrderItemsInput,
        ProductUpdateWithoutOrderItemsInput
      >,
      ProductUncheckedUpdateWithoutOrderItemsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
    isSet?: boolean;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, "path">
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, "path">>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
    isSet?: boolean;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
      isSet?: boolean;
    };

  export type NestedEnumSettingDataTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SettingDataType
      | EnumSettingDataTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SettingDataType[]
      | ListEnumSettingDataTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SettingDataType[]
      | ListEnumSettingDataTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSettingDataTypeFilter<$PrismaModel>
      | $Enums.SettingDataType;
  };

  export type NestedEnumSettingDataTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.SettingDataType
      | EnumSettingDataTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SettingDataType[]
      | ListEnumSettingDataTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SettingDataType[]
      | ListEnumSettingDataTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSettingDataTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.SettingDataType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSettingDataTypeFilter<$PrismaModel>;
    _max?: NestedEnumSettingDataTypeFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    isSet?: boolean;
  };

  export type NestedEnumBannerPositionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.BannerPosition
      | EnumBannerPositionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BannerPosition[]
      | ListEnumBannerPositionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BannerPosition[]
      | ListEnumBannerPositionFieldRefInput<$PrismaModel>;
    not?: NestedEnumBannerPositionFilter<$PrismaModel> | $Enums.BannerPosition;
  };

  export type NestedEnumBannerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BannerType | EnumBannerTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.BannerType[] | ListEnumBannerTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.BannerType[] | ListEnumBannerTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumBannerTypeFilter<$PrismaModel> | $Enums.BannerType;
  };

  export type NestedEnumBannerPositionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.BannerPosition
      | EnumBannerPositionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BannerPosition[]
      | ListEnumBannerPositionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BannerPosition[]
      | ListEnumBannerPositionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBannerPositionWithAggregatesFilter<$PrismaModel>
      | $Enums.BannerPosition;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBannerPositionFilter<$PrismaModel>;
    _max?: NestedEnumBannerPositionFilter<$PrismaModel>;
  };

  export type NestedEnumBannerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BannerType | EnumBannerTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.BannerType[] | ListEnumBannerTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.BannerType[] | ListEnumBannerTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBannerTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.BannerType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBannerTypeFilter<$PrismaModel>;
    _max?: NestedEnumBannerTypeFilter<$PrismaModel>;
  };

  export type NestedEnumSlideTextPositionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SlideTextPosition
      | EnumSlideTextPositionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SlideTextPosition[]
      | ListEnumSlideTextPositionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SlideTextPosition[]
      | ListEnumSlideTextPositionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSlideTextPositionFilter<$PrismaModel>
      | $Enums.SlideTextPosition;
  };

  export type NestedEnumSlideAnimationFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SlideAnimation
      | EnumSlideAnimationFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SlideAnimation[]
      | ListEnumSlideAnimationFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SlideAnimation[]
      | ListEnumSlideAnimationFieldRefInput<$PrismaModel>;
    not?: NestedEnumSlideAnimationFilter<$PrismaModel> | $Enums.SlideAnimation;
  };

  export type NestedEnumSlideTextPositionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.SlideTextPosition
      | EnumSlideTextPositionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SlideTextPosition[]
      | ListEnumSlideTextPositionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SlideTextPosition[]
      | ListEnumSlideTextPositionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSlideTextPositionWithAggregatesFilter<$PrismaModel>
      | $Enums.SlideTextPosition;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSlideTextPositionFilter<$PrismaModel>;
    _max?: NestedEnumSlideTextPositionFilter<$PrismaModel>;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedEnumSlideAnimationWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.SlideAnimation
      | EnumSlideAnimationFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SlideAnimation[]
      | ListEnumSlideAnimationFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SlideAnimation[]
      | ListEnumSlideAnimationFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSlideAnimationWithAggregatesFilter<$PrismaModel>
      | $Enums.SlideAnimation;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSlideAnimationFilter<$PrismaModel>;
    _max?: NestedEnumSlideAnimationFilter<$PrismaModel>;
  };

  export type NestedEnumProfessionalTierFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ProfessionalTier
      | EnumProfessionalTierFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ProfessionalTier[]
      | ListEnumProfessionalTierFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ProfessionalTier[]
      | ListEnumProfessionalTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumProfessionalTierFilter<$PrismaModel>
      | $Enums.ProfessionalTier;
  };

  export type BusinessInfoWhereInput = {
    AND?: BusinessInfoWhereInput | BusinessInfoWhereInput[];
    OR?: BusinessInfoWhereInput[];
    NOT?: BusinessInfoWhereInput | BusinessInfoWhereInput[];
    companyName?: StringFilter<"BusinessInfo"> | string;
    taxId?: StringNullableFilter<"BusinessInfo"> | string | null;
    licenseNumber?: StringNullableFilter<"BusinessInfo"> | string | null;
    website?: StringNullableFilter<"BusinessInfo"> | string | null;
    verified?: BoolFilter<"BusinessInfo"> | boolean;
    verificationDocs?: StringNullableListFilter<"BusinessInfo">;
    yearEstablished?: IntNullableFilter<"BusinessInfo"> | number | null;
    employeeCount?: StringNullableFilter<"BusinessInfo"> | string | null;
  };

  export type NestedEnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CustomerType[]
      | ListEnumCustomerTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CustomerType[]
      | ListEnumCustomerTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType;
  };

  export type NestedEnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>;
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>;
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel;
  };

  export type NestedEnumProfessionalTierWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ProfessionalTier
      | EnumProfessionalTierFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ProfessionalTier[]
      | ListEnumProfessionalTierFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ProfessionalTier[]
      | ListEnumProfessionalTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumProfessionalTierWithAggregatesFilter<$PrismaModel>
      | $Enums.ProfessionalTier;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumProfessionalTierFilter<$PrismaModel>;
    _max?: NestedEnumProfessionalTierFilter<$PrismaModel>;
  };

  export type NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.CustomerType
        | EnumCustomerTypeFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.CustomerType[]
        | ListEnumCustomerTypeFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.CustomerType[]
        | ListEnumCustomerTypeFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel>
        | $Enums.CustomerType;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumCustomerTypeFilter<$PrismaModel>;
      _max?: NestedEnumCustomerTypeFilter<$PrismaModel>;
    };

  export type NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>;
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel>
      | $Enums.RiskLevel;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>;
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>;
  };

  export type NestedEnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AddressType[]
      | ListEnumAddressTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType;
  };

  export type NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.AddressType[]
        | ListEnumAddressTypeFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.AddressType[]
        | ListEnumAddressTypeFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel>
        | $Enums.AddressType;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumAddressTypeFilter<$PrismaModel>;
      _max?: NestedEnumAddressTypeFilter<$PrismaModel>;
    };

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ProductStatus
      | EnumProductStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ProductStatus[]
      | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ProductStatus[]
      | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus;
  };

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ApprovalStatus
      | EnumApprovalStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ApprovalStatus[]
      | ListEnumApprovalStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ApprovalStatus[]
      | ListEnumApprovalStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus;
  };

  export type VehicleCompatibilityWhereInput = {
    AND?: VehicleCompatibilityWhereInput | VehicleCompatibilityWhereInput[];
    OR?: VehicleCompatibilityWhereInput[];
    NOT?: VehicleCompatibilityWhereInput | VehicleCompatibilityWhereInput[];
    makes?: StringNullableListFilter<"VehicleCompatibility">;
    models?: StringNullableListFilter<"VehicleCompatibility">;
    years?: StringNullableListFilter<"VehicleCompatibility">;
    engineTypes?: StringNullableListFilter<"VehicleCompatibility">;
    transmissions?: StringNullableListFilter<"VehicleCompatibility">;
    notes?: StringNullableFilter<"VehicleCompatibility"> | string | null;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type NestedEnumProductStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ProductStatus
      | EnumProductStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ProductStatus[]
      | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ProductStatus[]
      | ListEnumProductStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumProductStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ProductStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumProductStatusFilter<$PrismaModel>;
    _max?: NestedEnumProductStatusFilter<$PrismaModel>;
  };

  export type NestedEnumApprovalStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ApprovalStatus
      | EnumApprovalStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ApprovalStatus[]
      | ListEnumApprovalStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ApprovalStatus[]
      | ListEnumApprovalStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ApprovalStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>;
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>;
  };

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReviewStatus[]
      | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus;
  };

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.ReviewStatus
        | EnumReviewStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.ReviewStatus[]
        | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.ReviewStatus[]
        | ListEnumReviewStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.ReviewStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumReviewStatusFilter<$PrismaModel>;
      _max?: NestedEnumReviewStatusFilter<$PrismaModel>;
    };

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.OrderStatus[]
      | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus;
  };

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus;
  };

  export type NestedEnumFulfillmentStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.FulfillmentStatus
      | EnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FulfillmentStatus[]
      | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FulfillmentStatus[]
      | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFulfillmentStatusFilter<$PrismaModel>
      | $Enums.FulfillmentStatus;
  };

  export type NestedEnumOrderPriorityFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.OrderPriority
      | EnumOrderPriorityFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.OrderPriority[]
      | ListEnumOrderPriorityFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.OrderPriority[]
      | ListEnumOrderPriorityFieldRefInput<$PrismaModel>;
    not?: NestedEnumOrderPriorityFilter<$PrismaModel> | $Enums.OrderPriority;
  };

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.OrderStatus[]
        | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.OrderStatus[]
        | ListEnumOrderStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.OrderStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumOrderStatusFilter<$PrismaModel>;
      _max?: NestedEnumOrderStatusFilter<$PrismaModel>;
    };

  export type NestedEnumPaymentStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>;
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>;
  };

  export type NestedEnumFulfillmentStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.FulfillmentStatus
      | EnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FulfillmentStatus[]
      | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FulfillmentStatus[]
      | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFulfillmentStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.FulfillmentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumFulfillmentStatusFilter<$PrismaModel>;
    _max?: NestedEnumFulfillmentStatusFilter<$PrismaModel>;
  };

  export type NestedEnumOrderPriorityWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.OrderPriority
      | EnumOrderPriorityFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.OrderPriority[]
      | ListEnumOrderPriorityFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.OrderPriority[]
      | ListEnumOrderPriorityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumOrderPriorityWithAggregatesFilter<$PrismaModel>
      | $Enums.OrderPriority;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumOrderPriorityFilter<$PrismaModel>;
    _max?: NestedEnumOrderPriorityFilter<$PrismaModel>;
  };

  export type StaffUserCreateWithoutRoleInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLogin?: Date | string | null;
    lastLoginIp?: string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordChangedAt?: Date | string;
    mustChangePassword?: boolean;
    avatar?: string | null;
    timezone?: string;
    language?: string;
    canAccessAdmin?: boolean;
    departmentAccess?: StaffUserCreatedepartmentAccessInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    activityLogs?: ActivityLogCreateNestedManyWithoutStaffUserInput;
  };

  export type StaffUserUncheckedCreateWithoutRoleInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLogin?: Date | string | null;
    lastLoginIp?: string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordChangedAt?: Date | string;
    mustChangePassword?: boolean;
    avatar?: string | null;
    timezone?: string;
    language?: string;
    canAccessAdmin?: boolean;
    departmentAccess?: StaffUserCreatedepartmentAccessInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutStaffUserInput;
  };

  export type StaffUserCreateOrConnectWithoutRoleInput = {
    where: StaffUserWhereUniqueInput;
    create: XOR<
      StaffUserCreateWithoutRoleInput,
      StaffUserUncheckedCreateWithoutRoleInput
    >;
  };

  export type StaffUserCreateManyRoleInputEnvelope = {
    data: StaffUserCreateManyRoleInput | StaffUserCreateManyRoleInput[];
  };

  export type StaffUserUpsertWithWhereUniqueWithoutRoleInput = {
    where: StaffUserWhereUniqueInput;
    update: XOR<
      StaffUserUpdateWithoutRoleInput,
      StaffUserUncheckedUpdateWithoutRoleInput
    >;
    create: XOR<
      StaffUserCreateWithoutRoleInput,
      StaffUserUncheckedCreateWithoutRoleInput
    >;
  };

  export type StaffUserUpdateWithWhereUniqueWithoutRoleInput = {
    where: StaffUserWhereUniqueInput;
    data: XOR<
      StaffUserUpdateWithoutRoleInput,
      StaffUserUncheckedUpdateWithoutRoleInput
    >;
  };

  export type StaffUserUpdateManyWithWhereWithoutRoleInput = {
    where: StaffUserScalarWhereInput;
    data: XOR<
      StaffUserUpdateManyMutationInput,
      StaffUserUncheckedUpdateManyWithoutRoleInput
    >;
  };

  export type StaffUserScalarWhereInput = {
    AND?: StaffUserScalarWhereInput | StaffUserScalarWhereInput[];
    OR?: StaffUserScalarWhereInput[];
    NOT?: StaffUserScalarWhereInput | StaffUserScalarWhereInput[];
    id?: StringFilter<"StaffUser"> | string;
    roleId?: StringFilter<"StaffUser"> | string;
    firstName?: StringFilter<"StaffUser"> | string;
    lastName?: StringFilter<"StaffUser"> | string;
    email?: StringFilter<"StaffUser"> | string;
    phone?: StringNullableFilter<"StaffUser"> | string | null;
    passwordHash?: StringFilter<"StaffUser"> | string;
    isActive?: BoolFilter<"StaffUser"> | boolean;
    emailVerified?: BoolFilter<"StaffUser"> | boolean;
    twoFactorEnabled?: BoolFilter<"StaffUser"> | boolean;
    twoFactorSecret?: StringNullableFilter<"StaffUser"> | string | null;
    lastLogin?: DateTimeNullableFilter<"StaffUser"> | Date | string | null;
    lastLoginIp?: StringNullableFilter<"StaffUser"> | string | null;
    loginAttempts?: IntFilter<"StaffUser"> | number;
    lockedUntil?: DateTimeNullableFilter<"StaffUser"> | Date | string | null;
    passwordChangedAt?: DateTimeFilter<"StaffUser"> | Date | string;
    mustChangePassword?: BoolFilter<"StaffUser"> | boolean;
    avatar?: StringNullableFilter<"StaffUser"> | string | null;
    timezone?: StringFilter<"StaffUser"> | string;
    language?: StringFilter<"StaffUser"> | string;
    canAccessAdmin?: BoolFilter<"StaffUser"> | boolean;
    departmentAccess?: StringNullableListFilter<"StaffUser">;
    createdAt?: DateTimeFilter<"StaffUser"> | Date | string;
    updatedAt?: DateTimeFilter<"StaffUser"> | Date | string;
    createdBy?: StringNullableFilter<"StaffUser"> | string | null;
    lastModifiedBy?: StringNullableFilter<"StaffUser"> | string | null;
  };

  export type RoleCreateWithoutStaffUsersInput = {
    id?: string;
    roleName: string;
    hierarchyLevel: number;
    permissions: InputJsonValue;
    description?: string | null;
    isActive?: boolean;
    maxUsers?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleUncheckedCreateWithoutStaffUsersInput = {
    id?: string;
    roleName: string;
    hierarchyLevel: number;
    permissions: InputJsonValue;
    description?: string | null;
    isActive?: boolean;
    maxUsers?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleCreateOrConnectWithoutStaffUsersInput = {
    where: RoleWhereUniqueInput;
    create: XOR<
      RoleCreateWithoutStaffUsersInput,
      RoleUncheckedCreateWithoutStaffUsersInput
    >;
  };

  export type ActivityLogCreateWithoutStaffUserInput = {
    id?: string;
    actionType: string;
    description: string;
    entityType?: string | null;
    entityId?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    metadata?: InputJsonValue | null;
    success?: boolean;
    errorMessage?: string | null;
    timestamp?: Date | string;
  };

  export type ActivityLogUncheckedCreateWithoutStaffUserInput = {
    id?: string;
    actionType: string;
    description: string;
    entityType?: string | null;
    entityId?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    metadata?: InputJsonValue | null;
    success?: boolean;
    errorMessage?: string | null;
    timestamp?: Date | string;
  };

  export type ActivityLogCreateOrConnectWithoutStaffUserInput = {
    where: ActivityLogWhereUniqueInput;
    create: XOR<
      ActivityLogCreateWithoutStaffUserInput,
      ActivityLogUncheckedCreateWithoutStaffUserInput
    >;
  };

  export type ActivityLogCreateManyStaffUserInputEnvelope = {
    data:
      | ActivityLogCreateManyStaffUserInput
      | ActivityLogCreateManyStaffUserInput[];
  };

  export type RoleUpsertWithoutStaffUsersInput = {
    update: XOR<
      RoleUpdateWithoutStaffUsersInput,
      RoleUncheckedUpdateWithoutStaffUsersInput
    >;
    create: XOR<
      RoleCreateWithoutStaffUsersInput,
      RoleUncheckedCreateWithoutStaffUsersInput
    >;
    where?: RoleWhereInput;
  };

  export type RoleUpdateToOneWithWhereWithoutStaffUsersInput = {
    where?: RoleWhereInput;
    data: XOR<
      RoleUpdateWithoutStaffUsersInput,
      RoleUncheckedUpdateWithoutStaffUsersInput
    >;
  };

  export type RoleUpdateWithoutStaffUsersInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    hierarchyLevel?: IntFieldUpdateOperationsInput | number;
    permissions?: InputJsonValue | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    maxUsers?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateWithoutStaffUsersInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    hierarchyLevel?: IntFieldUpdateOperationsInput | number;
    permissions?: InputJsonValue | InputJsonValue;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    maxUsers?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityLogUpsertWithWhereUniqueWithoutStaffUserInput = {
    where: ActivityLogWhereUniqueInput;
    update: XOR<
      ActivityLogUpdateWithoutStaffUserInput,
      ActivityLogUncheckedUpdateWithoutStaffUserInput
    >;
    create: XOR<
      ActivityLogCreateWithoutStaffUserInput,
      ActivityLogUncheckedCreateWithoutStaffUserInput
    >;
  };

  export type ActivityLogUpdateWithWhereUniqueWithoutStaffUserInput = {
    where: ActivityLogWhereUniqueInput;
    data: XOR<
      ActivityLogUpdateWithoutStaffUserInput,
      ActivityLogUncheckedUpdateWithoutStaffUserInput
    >;
  };

  export type ActivityLogUpdateManyWithWhereWithoutStaffUserInput = {
    where: ActivityLogScalarWhereInput;
    data: XOR<
      ActivityLogUpdateManyMutationInput,
      ActivityLogUncheckedUpdateManyWithoutStaffUserInput
    >;
  };

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[];
    OR?: ActivityLogScalarWhereInput[];
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[];
    id?: StringFilter<"ActivityLog"> | string;
    staffUserId?: StringFilter<"ActivityLog"> | string;
    actionType?: StringFilter<"ActivityLog"> | string;
    description?: StringFilter<"ActivityLog"> | string;
    entityType?: StringNullableFilter<"ActivityLog"> | string | null;
    entityId?: StringNullableFilter<"ActivityLog"> | string | null;
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null;
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null;
    metadata?: JsonNullableFilter<"ActivityLog">;
    success?: BoolFilter<"ActivityLog"> | boolean;
    errorMessage?: StringNullableFilter<"ActivityLog"> | string | null;
    timestamp?: DateTimeFilter<"ActivityLog"> | Date | string;
  };

  export type StaffUserCreateWithoutActivityLogsInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLogin?: Date | string | null;
    lastLoginIp?: string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordChangedAt?: Date | string;
    mustChangePassword?: boolean;
    avatar?: string | null;
    timezone?: string;
    language?: string;
    canAccessAdmin?: boolean;
    departmentAccess?: StaffUserCreatedepartmentAccessInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    role: RoleCreateNestedOneWithoutStaffUsersInput;
  };

  export type StaffUserUncheckedCreateWithoutActivityLogsInput = {
    id?: string;
    roleId: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLogin?: Date | string | null;
    lastLoginIp?: string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordChangedAt?: Date | string;
    mustChangePassword?: boolean;
    avatar?: string | null;
    timezone?: string;
    language?: string;
    canAccessAdmin?: boolean;
    departmentAccess?: StaffUserCreatedepartmentAccessInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
  };

  export type StaffUserCreateOrConnectWithoutActivityLogsInput = {
    where: StaffUserWhereUniqueInput;
    create: XOR<
      StaffUserCreateWithoutActivityLogsInput,
      StaffUserUncheckedCreateWithoutActivityLogsInput
    >;
  };

  export type StaffUserUpsertWithoutActivityLogsInput = {
    update: XOR<
      StaffUserUpdateWithoutActivityLogsInput,
      StaffUserUncheckedUpdateWithoutActivityLogsInput
    >;
    create: XOR<
      StaffUserCreateWithoutActivityLogsInput,
      StaffUserUncheckedCreateWithoutActivityLogsInput
    >;
    where?: StaffUserWhereInput;
  };

  export type StaffUserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: StaffUserWhereInput;
    data: XOR<
      StaffUserUpdateWithoutActivityLogsInput,
      StaffUserUncheckedUpdateWithoutActivityLogsInput
    >;
  };

  export type StaffUserUpdateWithoutActivityLogsInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: RoleUpdateOneRequiredWithoutStaffUsersNestedInput;
  };

  export type StaffUserUncheckedUpdateWithoutActivityLogsInput = {
    roleId?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BusinessInfoCreateverificationDocsInput = {
    set: string[];
  };

  export type AddressCreateWithoutCustomerInput = {
    id?: string;
    firstName?: string | null;
    lastName?: string | null;
    company?: string | null;
    address1: string;
    address2?: string | null;
    city: string;
    state: string;
    postalCode: string;
    country?: string;
    phone?: string | null;
    type?: $Enums.AddressType;
    isDefault?: boolean;
    isValidated?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressUncheckedCreateWithoutCustomerInput = {
    id?: string;
    firstName?: string | null;
    lastName?: string | null;
    company?: string | null;
    address1: string;
    address2?: string | null;
    city: string;
    state: string;
    postalCode: string;
    country?: string;
    phone?: string | null;
    type?: $Enums.AddressType;
    isDefault?: boolean;
    isValidated?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressCreateOrConnectWithoutCustomerInput = {
    where: AddressWhereUniqueInput;
    create: XOR<
      AddressCreateWithoutCustomerInput,
      AddressUncheckedCreateWithoutCustomerInput
    >;
  };

  export type AddressCreateManyCustomerInputEnvelope = {
    data: AddressCreateManyCustomerInput | AddressCreateManyCustomerInput[];
  };

  export type OrderCreateWithoutCustomerInput = {
    id?: string;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    paymentStatus?: $Enums.PaymentStatus;
    fulfillmentStatus?: $Enums.FulfillmentStatus;
    priorityLevel?: $Enums.OrderPriority;
    subtotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    shippingAddress: InputJsonValue;
    billingAddress: InputJsonValue;
    shippingCarrier?: string | null;
    shippingMethod?: string | null;
    trackingNumber?: string | null;
    estimatedDelivery?: Date | string | null;
    actualDelivery?: Date | string | null;
    assignedToStaffId?: string | null;
    internalNotes?: string | null;
    customerNotes?: string | null;
    cancellationReason?: string | null;
    cancelledAt?: Date | string | null;
    refundAmount?: number | null;
    refundReason?: string | null;
    refundedAt?: Date | string | null;
    orderDate?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    paymentStatus?: $Enums.PaymentStatus;
    fulfillmentStatus?: $Enums.FulfillmentStatus;
    priorityLevel?: $Enums.OrderPriority;
    subtotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    shippingAddress: InputJsonValue;
    billingAddress: InputJsonValue;
    shippingCarrier?: string | null;
    shippingMethod?: string | null;
    trackingNumber?: string | null;
    estimatedDelivery?: Date | string | null;
    actualDelivery?: Date | string | null;
    assignedToStaffId?: string | null;
    internalNotes?: string | null;
    customerNotes?: string | null;
    cancellationReason?: string | null;
    cancelledAt?: Date | string | null;
    refundAmount?: number | null;
    refundReason?: string | null;
    refundedAt?: Date | string | null;
    orderDate?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput;
    create: XOR<
      OrderCreateWithoutCustomerInput,
      OrderUncheckedCreateWithoutCustomerInput
    >;
  };

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[];
  };

  export type ProductReviewCreateWithoutCustomerInput = {
    id?: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    product: ProductCreateNestedOneWithoutReviewsInput;
  };

  export type ProductReviewUncheckedCreateWithoutCustomerInput = {
    id?: string;
    productId: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductReviewCreateOrConnectWithoutCustomerInput = {
    where: ProductReviewWhereUniqueInput;
    create: XOR<
      ProductReviewCreateWithoutCustomerInput,
      ProductReviewUncheckedCreateWithoutCustomerInput
    >;
  };

  export type ProductReviewCreateManyCustomerInputEnvelope = {
    data:
      | ProductReviewCreateManyCustomerInput
      | ProductReviewCreateManyCustomerInput[];
  };

  export type BusinessInfoUpsertInput = {
    set: BusinessInfoCreateInput | null;
    update: BusinessInfoUpdateInput;
  };

  export type AddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AddressWhereUniqueInput;
    update: XOR<
      AddressUpdateWithoutCustomerInput,
      AddressUncheckedUpdateWithoutCustomerInput
    >;
    create: XOR<
      AddressCreateWithoutCustomerInput,
      AddressUncheckedCreateWithoutCustomerInput
    >;
  };

  export type AddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AddressWhereUniqueInput;
    data: XOR<
      AddressUpdateWithoutCustomerInput,
      AddressUncheckedUpdateWithoutCustomerInput
    >;
  };

  export type AddressUpdateManyWithWhereWithoutCustomerInput = {
    where: AddressScalarWhereInput;
    data: XOR<
      AddressUpdateManyMutationInput,
      AddressUncheckedUpdateManyWithoutCustomerInput
    >;
  };

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[];
    OR?: AddressScalarWhereInput[];
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[];
    id?: StringFilter<"Address"> | string;
    customerId?: StringFilter<"Address"> | string;
    firstName?: StringNullableFilter<"Address"> | string | null;
    lastName?: StringNullableFilter<"Address"> | string | null;
    company?: StringNullableFilter<"Address"> | string | null;
    address1?: StringFilter<"Address"> | string;
    address2?: StringNullableFilter<"Address"> | string | null;
    city?: StringFilter<"Address"> | string;
    state?: StringFilter<"Address"> | string;
    postalCode?: StringFilter<"Address"> | string;
    country?: StringFilter<"Address"> | string;
    phone?: StringNullableFilter<"Address"> | string | null;
    type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType;
    isDefault?: BoolFilter<"Address"> | boolean;
    isValidated?: BoolFilter<"Address"> | boolean;
    createdAt?: DateTimeFilter<"Address"> | Date | string;
    updatedAt?: DateTimeFilter<"Address"> | Date | string;
  };

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput;
    update: XOR<
      OrderUpdateWithoutCustomerInput,
      OrderUncheckedUpdateWithoutCustomerInput
    >;
    create: XOR<
      OrderCreateWithoutCustomerInput,
      OrderUncheckedCreateWithoutCustomerInput
    >;
  };

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput;
    data: XOR<
      OrderUpdateWithoutCustomerInput,
      OrderUncheckedUpdateWithoutCustomerInput
    >;
  };

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput;
    data: XOR<
      OrderUpdateManyMutationInput,
      OrderUncheckedUpdateManyWithoutCustomerInput
    >;
  };

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[];
    OR?: OrderScalarWhereInput[];
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[];
    id?: StringFilter<"Order"> | string;
    customerId?: StringFilter<"Order"> | string;
    orderNumber?: StringFilter<"Order"> | string;
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus;
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFilter<"Order">
      | $Enums.FulfillmentStatus;
    priorityLevel?: EnumOrderPriorityFilter<"Order"> | $Enums.OrderPriority;
    subtotal?: FloatFilter<"Order"> | number;
    taxAmount?: FloatFilter<"Order"> | number;
    shippingAmount?: FloatFilter<"Order"> | number;
    discountAmount?: FloatFilter<"Order"> | number;
    totalAmount?: FloatFilter<"Order"> | number;
    paymentMethod?: StringNullableFilter<"Order"> | string | null;
    paymentReference?: StringNullableFilter<"Order"> | string | null;
    shippingAddress?: JsonFilter<"Order">;
    billingAddress?: JsonFilter<"Order">;
    shippingCarrier?: StringNullableFilter<"Order"> | string | null;
    shippingMethod?: StringNullableFilter<"Order"> | string | null;
    trackingNumber?: StringNullableFilter<"Order"> | string | null;
    estimatedDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null;
    actualDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null;
    assignedToStaffId?: StringNullableFilter<"Order"> | string | null;
    internalNotes?: StringNullableFilter<"Order"> | string | null;
    customerNotes?: StringNullableFilter<"Order"> | string | null;
    cancellationReason?: StringNullableFilter<"Order"> | string | null;
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null;
    refundAmount?: FloatNullableFilter<"Order"> | number | null;
    refundReason?: StringNullableFilter<"Order"> | string | null;
    refundedAt?: DateTimeNullableFilter<"Order"> | Date | string | null;
    orderDate?: DateTimeFilter<"Order"> | Date | string;
    createdAt?: DateTimeFilter<"Order"> | Date | string;
    updatedAt?: DateTimeFilter<"Order"> | Date | string;
  };

  export type ProductReviewUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ProductReviewWhereUniqueInput;
    update: XOR<
      ProductReviewUpdateWithoutCustomerInput,
      ProductReviewUncheckedUpdateWithoutCustomerInput
    >;
    create: XOR<
      ProductReviewCreateWithoutCustomerInput,
      ProductReviewUncheckedCreateWithoutCustomerInput
    >;
  };

  export type ProductReviewUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ProductReviewWhereUniqueInput;
    data: XOR<
      ProductReviewUpdateWithoutCustomerInput,
      ProductReviewUncheckedUpdateWithoutCustomerInput
    >;
  };

  export type ProductReviewUpdateManyWithWhereWithoutCustomerInput = {
    where: ProductReviewScalarWhereInput;
    data: XOR<
      ProductReviewUpdateManyMutationInput,
      ProductReviewUncheckedUpdateManyWithoutCustomerInput
    >;
  };

  export type ProductReviewScalarWhereInput = {
    AND?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[];
    OR?: ProductReviewScalarWhereInput[];
    NOT?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[];
    id?: StringFilter<"ProductReview"> | string;
    productId?: StringFilter<"ProductReview"> | string;
    customerId?: StringFilter<"ProductReview"> | string;
    rating?: IntFilter<"ProductReview"> | number;
    title?: StringFilter<"ProductReview"> | string;
    content?: StringFilter<"ProductReview"> | string;
    verified?: BoolFilter<"ProductReview"> | boolean;
    helpful?: IntFilter<"ProductReview"> | number;
    status?: EnumReviewStatusFilter<"ProductReview"> | $Enums.ReviewStatus;
    moderatedBy?: StringNullableFilter<"ProductReview"> | string | null;
    moderatedAt?:
      | DateTimeNullableFilter<"ProductReview">
      | Date
      | string
      | null;
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string;
    updatedAt?: DateTimeFilter<"ProductReview"> | Date | string;
  };

  export type CustomerCreateWithoutAddressesInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    orders?: OrderCreateNestedManyWithoutCustomerInput;
    reviews?: ProductReviewCreateNestedManyWithoutCustomerInput;
  };

  export type CustomerUncheckedCreateWithoutAddressesInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput;
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput;
  };

  export type CustomerCreateOrConnectWithoutAddressesInput = {
    where: CustomerWhereUniqueInput;
    create: XOR<
      CustomerCreateWithoutAddressesInput,
      CustomerUncheckedCreateWithoutAddressesInput
    >;
  };

  export type CustomerUpsertWithoutAddressesInput = {
    update: XOR<
      CustomerUpdateWithoutAddressesInput,
      CustomerUncheckedUpdateWithoutAddressesInput
    >;
    create: XOR<
      CustomerCreateWithoutAddressesInput,
      CustomerUncheckedCreateWithoutAddressesInput
    >;
    where?: CustomerWhereInput;
  };

  export type CustomerUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CustomerWhereInput;
    data: XOR<
      CustomerUpdateWithoutAddressesInput,
      CustomerUncheckedUpdateWithoutAddressesInput
    >;
  };

  export type CustomerUpdateWithoutAddressesInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orders?: OrderUpdateManyWithoutCustomerNestedInput;
    reviews?: ProductReviewUpdateManyWithoutCustomerNestedInput;
  };

  export type CustomerUncheckedUpdateWithoutAddressesInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput;
    reviews?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput;
  };

  export type CategoryCreateWithoutChildrenInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: CategoryCreateNestedOneWithoutChildrenInput;
    products?: ProductCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    parentId?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput;
    create: XOR<
      CategoryCreateWithoutChildrenInput,
      CategoryUncheckedCreateWithoutChildrenInput
    >;
  };

  export type CategoryCreateWithoutParentInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: CategoryCreateNestedManyWithoutParentInput;
    products?: ProductCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput;
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput;
    create: XOR<
      CategoryCreateWithoutParentInput,
      CategoryUncheckedCreateWithoutParentInput
    >;
  };

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[];
  };

  export type ProductCreateWithoutCategoryInput = {
    id?: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    reviews?: ProductReviewCreateNestedManyWithoutProductInput;
    orderItems?: OrderItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput;
    create: XOR<
      ProductCreateWithoutCategoryInput,
      ProductUncheckedCreateWithoutCategoryInput
    >;
  };

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[];
  };

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<
      CategoryUpdateWithoutChildrenInput,
      CategoryUncheckedUpdateWithoutChildrenInput
    >;
    create: XOR<
      CategoryCreateWithoutChildrenInput,
      CategoryUncheckedCreateWithoutChildrenInput
    >;
    where?: CategoryWhereInput;
  };

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput;
    data: XOR<
      CategoryUpdateWithoutChildrenInput,
      CategoryUncheckedUpdateWithoutChildrenInput
    >;
  };

  export type CategoryUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: CategoryUpdateOneWithoutChildrenNestedInput;
    products?: ProductUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput;
    update: XOR<
      CategoryUpdateWithoutParentInput,
      CategoryUncheckedUpdateWithoutParentInput
    >;
    create: XOR<
      CategoryCreateWithoutParentInput,
      CategoryUncheckedCreateWithoutParentInput
    >;
  };

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput;
    data: XOR<
      CategoryUpdateWithoutParentInput,
      CategoryUncheckedUpdateWithoutParentInput
    >;
  };

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput;
    data: XOR<
      CategoryUpdateManyMutationInput,
      CategoryUncheckedUpdateManyWithoutParentInput
    >;
  };

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[];
    OR?: CategoryScalarWhereInput[];
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[];
    id?: StringFilter<"Category"> | string;
    name?: StringFilter<"Category"> | string;
    slug?: StringFilter<"Category"> | string;
    description?: StringNullableFilter<"Category"> | string | null;
    iconClass?: StringNullableFilter<"Category"> | string | null;
    parentId?: StringNullableFilter<"Category"> | string | null;
    image?: StringNullableFilter<"Category"> | string | null;
    sortOrder?: IntFilter<"Category"> | number;
    isActive?: BoolFilter<"Category"> | boolean;
    isFeatured?: BoolFilter<"Category"> | boolean;
    metaTitle?: StringNullableFilter<"Category"> | string | null;
    metaDescription?: StringNullableFilter<"Category"> | string | null;
    productCount?: IntFilter<"Category"> | number;
    createdAt?: DateTimeFilter<"Category"> | Date | string;
    updatedAt?: DateTimeFilter<"Category"> | Date | string;
  };

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput;
    update: XOR<
      ProductUpdateWithoutCategoryInput,
      ProductUncheckedUpdateWithoutCategoryInput
    >;
    create: XOR<
      ProductCreateWithoutCategoryInput,
      ProductUncheckedCreateWithoutCategoryInput
    >;
  };

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput;
    data: XOR<
      ProductUpdateWithoutCategoryInput,
      ProductUncheckedUpdateWithoutCategoryInput
    >;
  };

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput;
    data: XOR<
      ProductUpdateManyMutationInput,
      ProductUncheckedUpdateManyWithoutCategoryInput
    >;
  };

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[];
    OR?: ProductScalarWhereInput[];
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[];
    id?: StringFilter<"Product"> | string;
    categoryId?: StringFilter<"Product"> | string;
    name?: StringFilter<"Product"> | string;
    description?: StringFilter<"Product"> | string;
    shortDescription?: StringNullableFilter<"Product"> | string | null;
    regularPrice?: FloatFilter<"Product"> | number;
    salePrice?: FloatNullableFilter<"Product"> | number | null;
    costPrice?: FloatNullableFilter<"Product"> | number | null;
    sku?: StringFilter<"Product"> | string;
    partNumber?: StringNullableFilter<"Product"> | string | null;
    upc?: StringNullableFilter<"Product"> | string | null;
    stockQuantity?: IntFilter<"Product"> | number;
    lowStockThreshold?: IntFilter<"Product"> | number;
    trackInventory?: BoolFilter<"Product"> | boolean;
    allowBackorders?: BoolFilter<"Product"> | boolean;
    professionalOnly?: BoolFilter<"Product"> | boolean;
    minimumOrderQuantity?: IntFilter<"Product"> | number;
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFilter<"Product">
      | $Enums.ApprovalStatus;
    featured?: BoolFilter<"Product"> | boolean;
    onSale?: BoolFilter<"Product"> | boolean;
    newProduct?: BoolFilter<"Product"> | boolean;
    metaTitle?: StringNullableFilter<"Product"> | string | null;
    metaDescription?: StringNullableFilter<"Product"> | string | null;
    tags?: StringNullableListFilter<"Product">;
    weight?: FloatNullableFilter<"Product"> | number | null;
    dimensions?: JsonNullableFilter<"Product">;
    requiresShipping?: BoolFilter<"Product"> | boolean;
    shippingClass?: StringNullableFilter<"Product"> | string | null;
    version?: IntFilter<"Product"> | number;
    createdBy?: StringNullableFilter<"Product"> | string | null;
    lastModifiedBy?: StringNullableFilter<"Product"> | string | null;
    createdAt?: DateTimeFilter<"Product"> | Date | string;
    updatedAt?: DateTimeFilter<"Product"> | Date | string;
  };

  export type VehicleCompatibilityCreatemakesInput = {
    set: string[];
  };

  export type VehicleCompatibilityCreatemodelsInput = {
    set: string[];
  };

  export type VehicleCompatibilityCreateyearsInput = {
    set: string[];
  };

  export type VehicleCompatibilityCreateengineTypesInput = {
    set: string[];
  };

  export type VehicleCompatibilityCreatetransmissionsInput = {
    set: string[];
  };

  export type CategoryCreateWithoutProductsInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    parent?: CategoryCreateNestedOneWithoutChildrenInput;
    children?: CategoryCreateNestedManyWithoutParentInput;
  };

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    parentId?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput;
    create: XOR<
      CategoryCreateWithoutProductsInput,
      CategoryUncheckedCreateWithoutProductsInput
    >;
  };

  export type ProductReviewCreateWithoutProductInput = {
    id?: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    customer: CustomerCreateNestedOneWithoutReviewsInput;
  };

  export type ProductReviewUncheckedCreateWithoutProductInput = {
    id?: string;
    customerId: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductReviewCreateOrConnectWithoutProductInput = {
    where: ProductReviewWhereUniqueInput;
    create: XOR<
      ProductReviewCreateWithoutProductInput,
      ProductReviewUncheckedCreateWithoutProductInput
    >;
  };

  export type ProductReviewCreateManyProductInputEnvelope = {
    data:
      | ProductReviewCreateManyProductInput
      | ProductReviewCreateManyProductInput[];
  };

  export type OrderItemCreateWithoutProductInput = {
    id?: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
    order: OrderCreateNestedOneWithoutOrderItemsInput;
  };

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string;
    orderId: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
  };

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput;
    create: XOR<
      OrderItemCreateWithoutProductInput,
      OrderItemUncheckedCreateWithoutProductInput
    >;
  };

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[];
  };

  export type VehicleCompatibilityUpsertInput = {
    set: VehicleCompatibilityCreateInput | null;
    update: VehicleCompatibilityUpdateInput;
  };

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<
      CategoryUpdateWithoutProductsInput,
      CategoryUncheckedUpdateWithoutProductsInput
    >;
    create: XOR<
      CategoryCreateWithoutProductsInput,
      CategoryUncheckedCreateWithoutProductsInput
    >;
    where?: CategoryWhereInput;
  };

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput;
    data: XOR<
      CategoryUpdateWithoutProductsInput,
      CategoryUncheckedUpdateWithoutProductsInput
    >;
  };

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    parent?: CategoryUpdateOneWithoutChildrenNestedInput;
    children?: CategoryUpdateManyWithoutParentNestedInput;
  };

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type ProductReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput;
    update: XOR<
      ProductReviewUpdateWithoutProductInput,
      ProductReviewUncheckedUpdateWithoutProductInput
    >;
    create: XOR<
      ProductReviewCreateWithoutProductInput,
      ProductReviewUncheckedCreateWithoutProductInput
    >;
  };

  export type ProductReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput;
    data: XOR<
      ProductReviewUpdateWithoutProductInput,
      ProductReviewUncheckedUpdateWithoutProductInput
    >;
  };

  export type ProductReviewUpdateManyWithWhereWithoutProductInput = {
    where: ProductReviewScalarWhereInput;
    data: XOR<
      ProductReviewUpdateManyMutationInput,
      ProductReviewUncheckedUpdateManyWithoutProductInput
    >;
  };

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput;
    update: XOR<
      OrderItemUpdateWithoutProductInput,
      OrderItemUncheckedUpdateWithoutProductInput
    >;
    create: XOR<
      OrderItemCreateWithoutProductInput,
      OrderItemUncheckedCreateWithoutProductInput
    >;
  };

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput;
    data: XOR<
      OrderItemUpdateWithoutProductInput,
      OrderItemUncheckedUpdateWithoutProductInput
    >;
  };

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput;
    data: XOR<
      OrderItemUpdateManyMutationInput,
      OrderItemUncheckedUpdateManyWithoutProductInput
    >;
  };

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
    OR?: OrderItemScalarWhereInput[];
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
    id?: StringFilter<"OrderItem"> | string;
    orderId?: StringFilter<"OrderItem"> | string;
    productId?: StringFilter<"OrderItem"> | string;
    quantity?: IntFilter<"OrderItem"> | number;
    priceAtPurchase?: FloatFilter<"OrderItem"> | number;
    productNameAtPurchase?: StringFilter<"OrderItem"> | string;
    quantityShipped?: IntFilter<"OrderItem"> | number;
    quantityRefunded?: IntFilter<"OrderItem"> | number;
  };

  export type ProductCreateWithoutReviewsInput = {
    id?: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    category: CategoryCreateNestedOneWithoutProductsInput;
    orderItems?: OrderItemCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string;
    categoryId: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput;
    create: XOR<
      ProductCreateWithoutReviewsInput,
      ProductUncheckedCreateWithoutReviewsInput
    >;
  };

  export type CustomerCreateWithoutReviewsInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    addresses?: AddressCreateNestedManyWithoutCustomerInput;
    orders?: OrderCreateNestedManyWithoutCustomerInput;
  };

  export type CustomerUncheckedCreateWithoutReviewsInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerInput;
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput;
  };

  export type CustomerCreateOrConnectWithoutReviewsInput = {
    where: CustomerWhereUniqueInput;
    create: XOR<
      CustomerCreateWithoutReviewsInput,
      CustomerUncheckedCreateWithoutReviewsInput
    >;
  };

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<
      ProductUpdateWithoutReviewsInput,
      ProductUncheckedUpdateWithoutReviewsInput
    >;
    create: XOR<
      ProductCreateWithoutReviewsInput,
      ProductUncheckedCreateWithoutReviewsInput
    >;
    where?: ProductWhereInput;
  };

  export type ProductUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProductWhereInput;
    data: XOR<
      ProductUpdateWithoutReviewsInput,
      ProductUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type ProductUpdateWithoutReviewsInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput;
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    categoryId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type CustomerUpsertWithoutReviewsInput = {
    update: XOR<
      CustomerUpdateWithoutReviewsInput,
      CustomerUncheckedUpdateWithoutReviewsInput
    >;
    create: XOR<
      CustomerCreateWithoutReviewsInput,
      CustomerUncheckedCreateWithoutReviewsInput
    >;
    where?: CustomerWhereInput;
  };

  export type CustomerUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CustomerWhereInput;
    data: XOR<
      CustomerUpdateWithoutReviewsInput,
      CustomerUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type CustomerUpdateWithoutReviewsInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    addresses?: AddressUpdateManyWithoutCustomerNestedInput;
    orders?: OrderUpdateManyWithoutCustomerNestedInput;
  };

  export type CustomerUncheckedUpdateWithoutReviewsInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    addresses?: AddressUncheckedUpdateManyWithoutCustomerNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput;
  };

  export type CustomerCreateWithoutOrdersInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    addresses?: AddressCreateNestedManyWithoutCustomerInput;
    reviews?: ProductReviewCreateNestedManyWithoutCustomerInput;
  };

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    emailVerified?: boolean;
    isActive?: boolean;
    professionalTier?: $Enums.ProfessionalTier;
    discountRate?: number;
    businessInfo?: XOR<
      BusinessInfoNullableCreateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: number;
    totalSpent?: number;
    lifetimeValue?: number;
    averageOrderValue?: number;
    preferredPaymentMethod?: string | null;
    communicationPrefs?: InputJsonValue | null;
    timezone?: string;
    customerType?: $Enums.CustomerType;
    riskLevel?: $Enums.RiskLevel;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLogin?: Date | string | null;
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerInput;
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput;
  };

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput;
    create: XOR<
      CustomerCreateWithoutOrdersInput,
      CustomerUncheckedCreateWithoutOrdersInput
    >;
  };

  export type OrderItemCreateWithoutOrderInput = {
    id?: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
    product: ProductCreateNestedOneWithoutOrderItemsInput;
  };

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string;
    productId: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
  };

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    create: XOR<
      OrderItemCreateWithoutOrderInput,
      OrderItemUncheckedCreateWithoutOrderInput
    >;
  };

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[];
  };

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<
      CustomerUpdateWithoutOrdersInput,
      CustomerUncheckedUpdateWithoutOrdersInput
    >;
    create: XOR<
      CustomerCreateWithoutOrdersInput,
      CustomerUncheckedCreateWithoutOrdersInput
    >;
    where?: CustomerWhereInput;
  };

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput;
    data: XOR<
      CustomerUpdateWithoutOrdersInput,
      CustomerUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type CustomerUpdateWithoutOrdersInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    addresses?: AddressUpdateManyWithoutCustomerNestedInput;
    reviews?: ProductReviewUpdateManyWithoutCustomerNestedInput;
  };

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    professionalTier?:
      | EnumProfessionalTierFieldUpdateOperationsInput
      | $Enums.ProfessionalTier;
    discountRate?: FloatFieldUpdateOperationsInput | number;
    businessInfo?: XOR<
      BusinessInfoNullableUpdateEnvelopeInput,
      BusinessInfoCreateInput
    > | null;
    totalOrders?: IntFieldUpdateOperationsInput | number;
    totalSpent?: FloatFieldUpdateOperationsInput | number;
    lifetimeValue?: FloatFieldUpdateOperationsInput | number;
    averageOrderValue?: FloatFieldUpdateOperationsInput | number;
    preferredPaymentMethod?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    communicationPrefs?: InputJsonValue | InputJsonValue | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    customerType?:
      | EnumCustomerTypeFieldUpdateOperationsInput
      | $Enums.CustomerType;
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    addresses?: AddressUncheckedUpdateManyWithoutCustomerNestedInput;
    reviews?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput;
  };

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    update: XOR<
      OrderItemUpdateWithoutOrderInput,
      OrderItemUncheckedUpdateWithoutOrderInput
    >;
    create: XOR<
      OrderItemCreateWithoutOrderInput,
      OrderItemUncheckedCreateWithoutOrderInput
    >;
  };

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    data: XOR<
      OrderItemUpdateWithoutOrderInput,
      OrderItemUncheckedUpdateWithoutOrderInput
    >;
  };

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput;
    data: XOR<
      OrderItemUpdateManyMutationInput,
      OrderItemUncheckedUpdateManyWithoutOrderInput
    >;
  };

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    paymentStatus?: $Enums.PaymentStatus;
    fulfillmentStatus?: $Enums.FulfillmentStatus;
    priorityLevel?: $Enums.OrderPriority;
    subtotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    shippingAddress: InputJsonValue;
    billingAddress: InputJsonValue;
    shippingCarrier?: string | null;
    shippingMethod?: string | null;
    trackingNumber?: string | null;
    estimatedDelivery?: Date | string | null;
    actualDelivery?: Date | string | null;
    assignedToStaffId?: string | null;
    internalNotes?: string | null;
    customerNotes?: string | null;
    cancellationReason?: string | null;
    cancelledAt?: Date | string | null;
    refundAmount?: number | null;
    refundReason?: string | null;
    refundedAt?: Date | string | null;
    orderDate?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    customer: CustomerCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string;
    customerId: string;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    paymentStatus?: $Enums.PaymentStatus;
    fulfillmentStatus?: $Enums.FulfillmentStatus;
    priorityLevel?: $Enums.OrderPriority;
    subtotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    shippingAddress: InputJsonValue;
    billingAddress: InputJsonValue;
    shippingCarrier?: string | null;
    shippingMethod?: string | null;
    trackingNumber?: string | null;
    estimatedDelivery?: Date | string | null;
    actualDelivery?: Date | string | null;
    assignedToStaffId?: string | null;
    internalNotes?: string | null;
    customerNotes?: string | null;
    cancellationReason?: string | null;
    cancelledAt?: Date | string | null;
    refundAmount?: number | null;
    refundReason?: string | null;
    refundedAt?: Date | string | null;
    orderDate?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput;
    create: XOR<
      OrderCreateWithoutOrderItemsInput,
      OrderUncheckedCreateWithoutOrderItemsInput
    >;
  };

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    category: CategoryCreateNestedOneWithoutProductsInput;
    reviews?: ProductReviewCreateNestedManyWithoutProductInput;
  };

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string;
    categoryId: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput;
  };

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput;
    create: XOR<
      ProductCreateWithoutOrderItemsInput,
      ProductUncheckedCreateWithoutOrderItemsInput
    >;
  };

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<
      OrderUpdateWithoutOrderItemsInput,
      OrderUncheckedUpdateWithoutOrderItemsInput
    >;
    create: XOR<
      OrderCreateWithoutOrderItemsInput,
      OrderUncheckedCreateWithoutOrderItemsInput
    >;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput;
    data: XOR<
      OrderUpdateWithoutOrderItemsInput,
      OrderUncheckedUpdateWithoutOrderItemsInput
    >;
  };

  export type OrderUpdateWithoutOrderItemsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    customerId?: StringFieldUpdateOperationsInput | string;
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<
      ProductUpdateWithoutOrderItemsInput,
      ProductUncheckedUpdateWithoutOrderItemsInput
    >;
    create: XOR<
      ProductCreateWithoutOrderItemsInput,
      ProductUncheckedCreateWithoutOrderItemsInput
    >;
    where?: ProductWhereInput;
  };

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput;
    data: XOR<
      ProductUpdateWithoutOrderItemsInput,
      ProductUncheckedUpdateWithoutOrderItemsInput
    >;
  };

  export type ProductUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput;
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    categoryId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type StaffUserCreateManyRoleInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    isActive?: boolean;
    emailVerified?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    lastLogin?: Date | string | null;
    lastLoginIp?: string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordChangedAt?: Date | string;
    mustChangePassword?: boolean;
    avatar?: string | null;
    timezone?: string;
    language?: string;
    canAccessAdmin?: boolean;
    departmentAccess?: StaffUserCreatedepartmentAccessInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
  };

  export type StaffUserUpdateWithoutRoleInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    activityLogs?: ActivityLogUpdateManyWithoutStaffUserNestedInput;
  };

  export type StaffUserUncheckedUpdateWithoutRoleInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutStaffUserNestedInput;
  };

  export type StaffUserUncheckedUpdateManyWithoutRoleInput = {
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    lastLogin?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    language?: StringFieldUpdateOperationsInput | string;
    canAccessAdmin?: BoolFieldUpdateOperationsInput | boolean;
    departmentAccess?: StaffUserUpdatedepartmentAccessInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ActivityLogCreateManyStaffUserInput = {
    id?: string;
    actionType: string;
    description: string;
    entityType?: string | null;
    entityId?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    metadata?: InputJsonValue | null;
    success?: boolean;
    errorMessage?: string | null;
    timestamp?: Date | string;
  };

  export type ActivityLogUpdateWithoutStaffUserInput = {
    actionType?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: InputJsonValue | InputJsonValue | null;
    success?: BoolFieldUpdateOperationsInput | boolean;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityLogUncheckedUpdateWithoutStaffUserInput = {
    actionType?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: InputJsonValue | InputJsonValue | null;
    success?: BoolFieldUpdateOperationsInput | boolean;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ActivityLogUncheckedUpdateManyWithoutStaffUserInput = {
    actionType?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: InputJsonValue | InputJsonValue | null;
    success?: BoolFieldUpdateOperationsInput | boolean;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressCreateManyCustomerInput = {
    id?: string;
    firstName?: string | null;
    lastName?: string | null;
    company?: string | null;
    address1: string;
    address2?: string | null;
    city: string;
    state: string;
    postalCode: string;
    country?: string;
    phone?: string | null;
    type?: $Enums.AddressType;
    isDefault?: boolean;
    isValidated?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderCreateManyCustomerInput = {
    id?: string;
    orderNumber: string;
    status?: $Enums.OrderStatus;
    paymentStatus?: $Enums.PaymentStatus;
    fulfillmentStatus?: $Enums.FulfillmentStatus;
    priorityLevel?: $Enums.OrderPriority;
    subtotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    paymentMethod?: string | null;
    paymentReference?: string | null;
    shippingAddress: InputJsonValue;
    billingAddress: InputJsonValue;
    shippingCarrier?: string | null;
    shippingMethod?: string | null;
    trackingNumber?: string | null;
    estimatedDelivery?: Date | string | null;
    actualDelivery?: Date | string | null;
    assignedToStaffId?: string | null;
    internalNotes?: string | null;
    customerNotes?: string | null;
    cancellationReason?: string | null;
    cancelledAt?: Date | string | null;
    refundAmount?: number | null;
    refundReason?: string | null;
    refundedAt?: Date | string | null;
    orderDate?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductReviewCreateManyCustomerInput = {
    id?: string;
    productId: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type BusinessInfoUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string;
    taxId?: NullableStringFieldUpdateOperationsInput | string | null;
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    verificationDocs?: BusinessInfoUpdateverificationDocsInput | string[];
    yearEstablished?: NullableIntFieldUpdateOperationsInput | number | null;
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AddressUpdateWithoutCustomerInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null;
    lastName?: NullableStringFieldUpdateOperationsInput | string | null;
    company?: NullableStringFieldUpdateOperationsInput | string | null;
    address1?: StringFieldUpdateOperationsInput | string;
    address2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isValidated?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressUncheckedUpdateWithoutCustomerInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null;
    lastName?: NullableStringFieldUpdateOperationsInput | string | null;
    company?: NullableStringFieldUpdateOperationsInput | string | null;
    address1?: StringFieldUpdateOperationsInput | string;
    address2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isValidated?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressUncheckedUpdateManyWithoutCustomerInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null;
    lastName?: NullableStringFieldUpdateOperationsInput | string | null;
    company?: NullableStringFieldUpdateOperationsInput | string | null;
    address1?: StringFieldUpdateOperationsInput | string;
    address2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    postalCode?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isValidated?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderUpdateWithoutCustomerInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string;
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    fulfillmentStatus?:
      | EnumFulfillmentStatusFieldUpdateOperationsInput
      | $Enums.FulfillmentStatus;
    priorityLevel?:
      | EnumOrderPriorityFieldUpdateOperationsInput
      | $Enums.OrderPriority;
    subtotal?: FloatFieldUpdateOperationsInput | number;
    taxAmount?: FloatFieldUpdateOperationsInput | number;
    shippingAmount?: FloatFieldUpdateOperationsInput | number;
    discountAmount?: FloatFieldUpdateOperationsInput | number;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingAddress?: InputJsonValue | InputJsonValue;
    billingAddress?: InputJsonValue | InputJsonValue;
    shippingCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    estimatedDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualDelivery?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    assignedToStaffId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    cancellationReason?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cancelledAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null;
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null;
    refundedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductReviewUpdateWithoutCustomerInput = {
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ProductReviewUncheckedUpdateWithoutCustomerInput = {
    productId?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductReviewUncheckedUpdateManyWithoutCustomerInput = {
    productId?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CategoryCreateManyParentInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    iconClass?: string | null;
    image?: string | null;
    sortOrder?: number;
    isActive?: boolean;
    isFeatured?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    productCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProductCreateManyCategoryInput = {
    id?: string;
    name: string;
    description: string;
    shortDescription?: string | null;
    regularPrice: number;
    salePrice?: number | null;
    costPrice?: number | null;
    sku: string;
    partNumber?: string | null;
    upc?: string | null;
    stockQuantity?: number;
    lowStockThreshold?: number;
    trackInventory?: boolean;
    allowBackorders?: boolean;
    professionalOnly?: boolean;
    minimumOrderQuantity?: number;
    status?: $Enums.ProductStatus;
    approvalStatus?: $Enums.ApprovalStatus;
    featured?: boolean;
    onSale?: boolean;
    newProduct?: boolean;
    metaTitle?: string | null;
    metaDescription?: string | null;
    tags?: ProductCreatetagsInput | string[];
    weight?: number | null;
    dimensions?: InputJsonValue | null;
    requiresShipping?: boolean;
    shippingClass?: string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableCreateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: number;
    createdBy?: string | null;
    lastModifiedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CategoryUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: CategoryUpdateManyWithoutParentNestedInput;
    products?: ProductUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryUncheckedUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput;
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    iconClass?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    sortOrder?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isFeatured?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    productCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput;
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput;
  };

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    regularPrice?: FloatFieldUpdateOperationsInput | number;
    salePrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    sku?: StringFieldUpdateOperationsInput | string;
    partNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    upc?: NullableStringFieldUpdateOperationsInput | string | null;
    stockQuantity?: IntFieldUpdateOperationsInput | number;
    lowStockThreshold?: IntFieldUpdateOperationsInput | number;
    trackInventory?: BoolFieldUpdateOperationsInput | boolean;
    allowBackorders?: BoolFieldUpdateOperationsInput | boolean;
    professionalOnly?: BoolFieldUpdateOperationsInput | boolean;
    minimumOrderQuantity?: IntFieldUpdateOperationsInput | number;
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus;
    approvalStatus?:
      | EnumApprovalStatusFieldUpdateOperationsInput
      | $Enums.ApprovalStatus;
    featured?: BoolFieldUpdateOperationsInput | boolean;
    onSale?: BoolFieldUpdateOperationsInput | boolean;
    newProduct?: BoolFieldUpdateOperationsInput | boolean;
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    tags?: ProductUpdatetagsInput | string[];
    weight?: NullableFloatFieldUpdateOperationsInput | number | null;
    dimensions?: InputJsonValue | InputJsonValue | null;
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean;
    shippingClass?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleCompatibility?: XOR<
      VehicleCompatibilityNullableUpdateEnvelopeInput,
      VehicleCompatibilityCreateInput
    > | null;
    version?: IntFieldUpdateOperationsInput | number;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductReviewCreateManyProductInput = {
    id?: string;
    customerId: string;
    rating: number;
    title: string;
    content: string;
    verified?: boolean;
    helpful?: number;
    status?: $Enums.ReviewStatus;
    moderatedBy?: string | null;
    moderatedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderItemCreateManyProductInput = {
    id?: string;
    orderId: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
  };

  export type VehicleCompatibilityUpdateInput = {
    makes?: VehicleCompatibilityUpdatemakesInput | string[];
    models?: VehicleCompatibilityUpdatemodelsInput | string[];
    years?: VehicleCompatibilityUpdateyearsInput | string[];
    engineTypes?: VehicleCompatibilityUpdateengineTypesInput | string[];
    transmissions?: VehicleCompatibilityUpdatetransmissionsInput | string[];
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ProductReviewUpdateWithoutProductInput = {
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    customer?: CustomerUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ProductReviewUncheckedUpdateWithoutProductInput = {
    customerId?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProductReviewUncheckedUpdateManyWithoutProductInput = {
    customerId?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    helpful?: IntFieldUpdateOperationsInput | number;
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus;
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    moderatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput;
  };

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    orderId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    orderId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemCreateManyOrderInput = {
    id?: string;
    productId: string;
    quantity: number;
    priceAtPurchase: number;
    productNameAtPurchase: string;
    quantityShipped?: number;
    quantityRefunded?: number;
  };

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput;
  };

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    productId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    productId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    priceAtPurchase?: FloatFieldUpdateOperationsInput | number;
    productNameAtPurchase?: StringFieldUpdateOperationsInput | string;
    quantityShipped?: IntFieldUpdateOperationsInput | number;
    quantityRefunded?: IntFieldUpdateOperationsInput | number;
  };

  export type BusinessInfoUpdateverificationDocsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type VehicleCompatibilityUpdatemakesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type VehicleCompatibilityUpdatemodelsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type VehicleCompatibilityUpdateyearsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type VehicleCompatibilityUpdateengineTypesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type VehicleCompatibilityUpdatetransmissionsInput = {
    set?: string[];
    push?: string | string[];
  };

  /**
   * Aliases for legacy arg types
   */
  /**
   * @deprecated Use RoleCountOutputTypeDefaultArgs instead
   */
  export type RoleCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = RoleCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use StaffUserCountOutputTypeDefaultArgs instead
   */
  export type StaffUserCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = StaffUserCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
   */
  export type CustomerCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CustomerCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
   */
  export type CategoryCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CategoryCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ProductCountOutputTypeDefaultArgs instead
   */
  export type ProductCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ProductCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use OrderCountOutputTypeDefaultArgs instead
   */
  export type OrderCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = OrderCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use BusinessInfoDefaultArgs instead
   */
  export type BusinessInfoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = BusinessInfoDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use VehicleCompatibilityDefaultArgs instead
   */
  export type VehicleCompatibilityArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = VehicleCompatibilityDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use RoleDefaultArgs instead
   */
  export type RoleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = RoleDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use StaffUserDefaultArgs instead
   */
  export type StaffUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = StaffUserDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use SettingDefaultArgs instead
   */
  export type SettingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = SettingDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use BannerDefaultArgs instead
   */
  export type BannerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = BannerDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use HeroSlideDefaultArgs instead
   */
  export type HeroSlideArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = HeroSlideDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use SiteCustomizationDefaultArgs instead
   */
  export type SiteCustomizationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = SiteCustomizationDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ActivityLogDefaultArgs instead
   */
  export type ActivityLogArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ActivityLogDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CustomerDefaultArgs instead
   */
  export type CustomerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CustomerDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AddressDefaultArgs instead
   */
  export type AddressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = AddressDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CategoryDefaultArgs instead
   */
  export type CategoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CategoryDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ProductDefaultArgs instead
   */
  export type ProductArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ProductDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ProductReviewDefaultArgs instead
   */
  export type ProductReviewArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ProductReviewDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use OrderDefaultArgs instead
   */
  export type OrderArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = OrderDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use OrderItemDefaultArgs instead
   */
  export type OrderItemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = OrderItemDefaultArgs<ExtArgs>;

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
